<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html" version="2.0" class="hidden">
<link type="text/css" id="dark-mode" rel="stylesheet" href=""/>
<style type="text/css" id="dark-mode-Ñustom-style"/>
<style type="text/css" id="dark-mode-theme-changer-style"/>
<channel>
<title>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</title>
<description>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</description>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
<image>
<url>https://cdn-images-1.medium.com/fit/c/150/150/0*B8-_pQzPr4S4bxYR</url>
<title>Stories by Mert Pehlivan on Medium</title>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
</image>
<generator>Medium</generator>
<lastBuildDate>Wed, 18 Jun 2025 04:43:41 GMT</lastBuildDate>
<atom:link href="https://medium.com/@pehlivanmert/feed" rel="self" type="application/rss+xml"/>
<webMaster>
<![CDATA[ yourfriends@medium.com ]]>
</webMaster>
<atom:link href="http://medium.superfeedr.com" rel="hub"/>
<item>
<title>
<![CDATA[ Java ve Yapay Zeka: Yeni DÃ¶nemin KapÄ±larÄ± AralanÄ±yor mu? ]]>
</title>
<link>https://pehlivanmert.medium.com/java-ve-yapay-zeka-yeni-d%C3%B6nemin-kap%C4%B1lar%C4%B1-aralan%C4%B1yor-mu-facc0a6d77c8?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/facc0a6d77c8</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 18 Jun 2025 01:07:20 GMT</pubDate>
<atom:updated>2025-06-18T01:07:20.305Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qBWnKbUvnfLp74YIbEmkig.png" /></figure><p>Son dÃ¶nemde Yapay Zeka (YZ) alanÄ±ndaki hÄ±zlÄ± geliÅŸmeler, sektÃ¶rÃ¼n gÃ¼ndemini belirliyor. Genellikle Python ile Ã¶zdeÅŸleÅŸtirilen YZ geliÅŸtirme sÃ¼reÃ§leri, Java platformunda da dikkat Ã§ekici ilerlemeler kaydediyor. Oracle'Ä±n "Java for AI" sunumu, bu konudaki mevcut ve gelecekteki Ã§alÄ±ÅŸmalarÄ± oldukÃ§a detaylÄ± bir ÅŸekilde ele alÄ±yor. Bir yazÄ±lÄ±mcÄ± olarak bu yenilikleri keÅŸfetmek oldukÃ§a heyecan vericiydi ve sizinle de paylaÅŸmak istedim.</p><p>Java, yÃ¼ksek performans ve geliÅŸtirici verimliliÄŸi gibi temel Ã¶zellikleriyle bilinen, genel amaÃ§lÄ± bir programlama platformu. Bu gÃ¼Ã§lÃ¼ yanlar, YZ'nÄ±n Ã¶zel gereksinimlerini karÅŸÄ±lamak Ã¼zere titizlikle adapte ediliyor. Sunumda da belirtildiÄŸi gibi, platforma eklenen yenilikler sadece YZ odaklÄ± deÄŸil, aynÄ± zamanda daha geniÅŸ kullanÄ±m alanlarÄ±na hitap ediyor; bu da Java'nÄ±n uzun soluklu baÅŸarÄ±sÄ±nÄ±n ardÄ±ndaki temel felsefelerden biri.</p><h3>Java'nÄ±n YZ Ä°Ã§in Ã–ne Ã‡Ä±kan Ã–zellikleri</h3><p>Sunumda, YZ geliÅŸtirmeleri iÃ§in kritik kabul edilen dÃ¶rt temel Java platformu Ã¶zelliÄŸi tanÄ±tÄ±lÄ±yor:</p><ul><li>Foreign Function and Memory API (Proje Panama): Java dÄ±ÅŸÄ±ndaki belleÄŸi (off-heap memory) daha verimli kullanmayÄ± ve yerel kÃ¼tÃ¼phanelerle etkileÅŸimi gÃ¼venli, hÄ±zlÄ± ve Ã¼retken bir hale getirmeyi saÄŸlÄ±yor. Ã–zellikle sÄ±fÄ±r kopyalama senaryolarÄ±nda bu Ã¶zellik kritik Ã¶neme sahip.</li><li>Vector API (Proje Panama): Java'da SIMD (Single Instruction, Multiple Data) programlamayÄ± mÃ¼mkÃ¼n kÄ±larak CPU'nun etkin kullanÄ±mÄ±nÄ± saÄŸlÄ±yor. YZ ve makine Ã¶ÄŸrenimi algoritmalarÄ± iÃ§in temel olan sayÄ±sal hesaplamalarÄ± (Ã¶rneÄŸin nokta Ã§arpÄ±mÄ±) ciddi oranda hÄ±zlandÄ±rÄ±yor.</li><li>Value Classes and Objects (Proje Valhalla): YÄ±ÄŸÄ±n iÃ§i (on-heap) belleÄŸin optimal kullanÄ±mÄ±nÄ± hedefliyor ve Float16, Bfloat16 gibi YZ'da sÄ±kÃ§a kullanÄ±lan yeni sayÄ± tÃ¼rlerinin platforma entegrasyonunu kolaylaÅŸtÄ±racak.</li><li>Code Reflection (Proje Babylon): GPU'lar (CUDA) veya ONNX gibi farklÄ± programlama modelleriyle etkileÅŸimi mÃ¼mkÃ¼n kÄ±lÄ±yor. Java kodunun otomatik tÃ¼revini (auto-differentiation) destekleyerek, platformun bu tÃ¼r spesifik detaylarÄ± kÃ¼tÃ¼phanelere devretmesini saÄŸlÄ±yor, bu da geliÅŸtiricilere esneklik sunuyor.</li></ul><h3>Mevcut Durum ve Gelecek Potansiyeli</h3><p>YZ model geliÅŸtirmenin bÃ¼yÃ¼k bir kÄ±smÄ± ÅŸu anda Python'da yoÄŸunlaÅŸmÄ±ÅŸ durumda. Ancak sunumda bahsedilen Ã¶zelliklerin Java'yÄ± YZ ekosisteminde daha rekabetÃ§i bir konuma getirme potansiyeli dikkat Ã§ekici. Bu Ã¶zellikler olmadan da YZ Ã§Ã¶zÃ¼mleri geliÅŸtirilebilir; ancak sunuma gÃ¶re, bu yeni araÃ§lar tasarÄ±m, geliÅŸtirme, sÃ¼rdÃ¼rme ve evrim sÃ¼reÃ§lerini Ã¶nemli Ã¶lÃ§Ã¼de kolaylaÅŸtÄ±rÄ±yor.</p><p>Sunumda, yeni Ã¶zelliklerin pratik uygulamalarÄ±nÄ± gÃ¶steren Ã§arpÄ±cÄ± Ã¶rneklere de yer veriliyor:</p><ul><li>Llama Model Ã‡Ä±karÄ±mÄ±: FFM ve Vector API kullanÄ±larak Java'da Llama 2 modelinin performansÄ±ndaki artÄ±ÅŸ (1.3 tokenden ~15 token/saniyeye) gÃ¶z dolduruyor.</li><li>Anomali Tespiti (MSET 2): Matris API, FFM API ve Vector API kullanarak Java'da uygulanan bu algoritmanÄ±n, CUDA, MATLAB ve Python/NumPy implementasyonlarÄ±ndan daha iyi performans gÃ¶sterdiÄŸi ve halihazÄ±rda Ã¼retimde kullanÄ±ldÄ±ÄŸÄ± belirtiliyor.</li><li>ONNX Script for Java: Code Reflection ve FFM API kullanarak Java kodundan ONNX makine Ã¶ÄŸrenimi modelleri oluÅŸturma yeteneÄŸi sergileniyor.</li></ul><h3>Kilit Bilgiler ve Daha FazlasÄ±</h3><ul><li>Proje Panama (FFM ve Vector API) Java 22&#39;den itibaren kullanÄ±labilir durumda (FFM API final sÃ¼rÃ¼mde, Vector API ise halen geliÅŸtirme aÅŸamasÄ±nda).</li><li>Proje Valhalla ve Proje Babylon ise aktif olarak geliÅŸtirilmeye devam eden gelecek vaat eden Ã¶zellikler.</li><li>Java'nÄ±n YZ alanÄ±ndaki bu yenilikleri, temel olarak bellek kullanÄ±mÄ±nÄ± optimize etmeyi, donanÄ±m kullanÄ±mÄ±nÄ± verimli hale getirmeyi, yerel kodlarla etkileÅŸimi gÃ¼Ã§lendirmeyi ve yeni sayÄ± tÃ¼rlerini desteklemeyi hedefliyor.</li></ul><p>TÃ¼m bu geliÅŸmeler Ä±ÅŸÄ±ÄŸÄ±nda, Java platformunun YZ, yÃ¼ksek performanslÄ± hesaplama ve bÃ¼yÃ¼k veri alanlarÄ±ndaki zorluklarÄ± ele almak iÃ§in dinamik bir geliÅŸim iÃ§inde olduÄŸunu sÃ¶yleyebiliriz. Bu Ã¶zellikler, Java'da performans odaklÄ± YZ Ã§Ã¶zÃ¼mleri oluÅŸturma potansiyelini artÄ±rÄ±yor.</p><p>Bu konuya daha derinlemesine bakmak isterseniz, ilgili <a href="https://www.youtube.com/watch?v=-XnyJad88Ss&amp;t=2s">Oracle OpenJDK topluluÄŸu sunumunu</a> izlemenizi ÅŸiddetle tavsiye ederim. GerÃ§ekten ufuk aÃ§Ä±cÄ± bilgiler iÃ§eriyor.</p><p>Siz bu geliÅŸmeler hakkÄ±nda ne dÃ¼ÅŸÃ¼nÃ¼yorsunuz? Java'nÄ±n YZ ekosistemindeki yeri gelecekte nasÄ±l ÅŸekillenebilir?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=facc0a6d77c8" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Gelecek KapÄ±mÄ±zda: Yapay ZekÃ¢ YazÄ±lÄ±mcÄ±larÄ±n Sonunu Mu Getirecek, Yoksa Yeni Bir Ã‡aÄŸ MÄ± BaÅŸlatacak? ]]>
</title>
<link>https://pehlivanmert.medium.com/gelecek-kap%C4%B1m%C4%B1zda-yapay-zek%C3%A2-yaz%C4%B1l%C4%B1mc%C4%B1lar%C4%B1n-sonunu-mu-getirecek-yoksa-yeni-bir-%C3%A7a%C4%9F-m%C4%B1-ba%C5%9Flatacak-4235efc6f12b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4235efc6f12b</guid>
<category>
<![CDATA[ development ]]>
</category>
<category>
<![CDATA[ ai ]]>
</category>
<category>
<![CDATA[ developer-tools ]]>
</category>
<category>
<![CDATA[ developer ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 04 Jun 2025 16:39:51 GMT</pubDate>
<atom:updated>2025-06-04T16:39:51.283Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j76ggknKxckfMfZssQgy1g.png" /></figure><p>Son yÄ±llarda yapay zekÃ¢ (YZ) rÃ¼zgarÄ±, yazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ±nda fÄ±rtÄ±nalar estiriyor. Kod tamamlama, otomatik hata dÃ¼zeltme gibi YZ destekli araÃ§lar sayesinde projelerimiz hÄ±zla ÅŸekilleniyor; Copilot gibi yardÄ±mcÄ±lar iÅŸlerimizi %55&#39;e varan oranlarda hÄ±zlandÄ±rabiliyor. BirÃ§oÄŸumuz bu devrimi kucaklayarak verimliliÄŸimizin arttÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Ancak, bir kesim yazÄ±lÄ±mcÄ± hÃ¢lÃ¢ endiÅŸeli: Ya YZ, iÅŸimizi tamamen elimizden alÄ±rsa?</p><p>EndiÅŸelerin aksine, PwC'nin 2025 YZ Ä°ÅŸ Barometresi bize umut veriyor: YZ'nin etkilediÄŸi pek Ã§ok meslekte hem istihdam hem de Ã¼cret seviyeleri artÄ±ÅŸ gÃ¶steriyor. Peki, yazÄ±lÄ±mcÄ±larÄ±n geleceÄŸi nasÄ±l ÅŸekillenecek? Gelin, bu sorunun kÄ±sa ve uzun vadeli etkilerine yakÄ±ndan bakalÄ±m.</p><h3>KÄ±sa Vadede YazÄ±lÄ±mcÄ±lar Ä°Ã§in FÄ±rsatlar ve Zorluklar</h3><h4>Yeni BaÅŸlayanlar ve Junior GeliÅŸtiriciler: Ã–ÄŸrenme ve Adaptasyon Vakti!</h4><p>Junior yazÄ±lÄ±mcÄ±lar iÃ§in YZ araÃ§larÄ± gerÃ§ek bir oyun deÄŸiÅŸtirici. StackOverflow anketine gÃ¶re, kod yazmayÄ± Ã¶ÄŸrenenlerin %82&#39;si YZ araÃ§larÄ±nÄ± kullanÄ±yor veya kullanmayÄ± planlÄ±yor. Bilimsel Ã§alÄ±ÅŸmalar da gÃ¶steriyor ki, Copilot gibi araÃ§lar Ã¶zellikle deneyimsiz geliÅŸtiricilere bÃ¼yÃ¼k fayda saÄŸlÄ±yor. Rutin kodlama gÃ¶revlerini hÄ±zla halletmelerine olanak tanÄ±rken, temel becerilerini pekiÅŸtirmelerine yardÄ±mcÄ± oluyor.</p><p>Ancak dikkat! YZ'nin Ã¼rettiÄŸi kodun doÄŸruluÄŸunu ve kalitesini kontrol etme, algoritma mantÄ±ÄŸÄ±nÄ± kavrayarak kodu denetleme sorumluluÄŸu hÃ¢lÃ¢ juniorlarÄ±n omuzlarÄ±nda. Bu, kÄ±sa vadede onlar iÃ§in muazzam bir Ã¶ÄŸrenme fÄ±rsatÄ± sunarken, aynÄ± zamanda YZ Ã¶nerilerine temkinli yaklaÅŸmayÄ± Ã¶ÄŸrenmeleri gerektiÄŸi anlamÄ±na geliyor.</p><h4>Orta Seviye GeliÅŸtiriciler: Verimlilikte Vites ArtÄ±rma ZamanÄ±!</h4><p>Profesyonel yazÄ±lÄ±mcÄ±larÄ±n %70&#39;i kÄ±sa vadede YZ araÃ§larÄ±nÄ± kullanmaya baÅŸlamÄ±ÅŸ veya planlÄ±yor. Orta seviye geliÅŸtiriciler, deneyimleri sayesinde YZ'nin kod Ã¶nerilerini eleÅŸtirel bir gÃ¶zle deÄŸerlendirip, sadece tekrarlÄ± iÅŸleri hÄ±zlandÄ±rmak iÃ§in kullanabilirler. YZ, bu grup iÃ§in zaman alan ve tekrarlayan iÅŸleri otomatikleÅŸtirerek, onlarÄ± daha karmaÅŸÄ±k problemlere ve mimari tasarÄ±ma odaklanmaya teÅŸvik edecek. BÃ¶ylece hem verimlilik kazanacaklar hem de Ã¼st dÃ¼zey gÃ¶revlerle birlikte yÃ¶netim becerilerini geliÅŸtirme imkanÄ± bulacaklar.</p><h4>KÄ±demli (Senior) GeliÅŸtiriciler: Stratejik Liderlik Ã–n Planda!</h4><p>Deneyimli yazÄ±lÄ±mcÄ±lar, genellikle mimari tasarÄ±m, ekip yÃ¶netimi ve karmaÅŸÄ±k problem Ã§Ã¶zme gibi kritik roller Ã¼stlenirler. Copilot ile yapÄ±lan deneyler, Ã¶zellikle 25â€“44 yaÅŸ arasÄ± geliÅŸtiricilerin YZ araÃ§larÄ±ndan Ã¶nemli Ã¶lÃ§Ã¼de fayda saÄŸladÄ±ÄŸÄ±nÄ± gÃ¶steriyor. KÄ±sa vadede kÄ±demli geliÅŸtiriciler, tekrarlÄ± kodlama iÅŸleriyle uÄŸraÅŸmak yerine, ekiplerine rehberlik etmeye, sÃ¼reÃ§leri iyileÅŸtirmeye ve yeni teknolojileri entegre etmeye odaklanacaklar. YZ onlara zaman kazandÄ±rÄ±rken, asÄ±l katma deÄŸer yaratan karmaÅŸÄ±k iÅŸlerin sorumluluÄŸu yine kÄ±demli ekibin Ã¼zerinde kalacak.</p><h3>Uzun Vadede YazÄ±lÄ±mcÄ±lar Ä°Ã§in BÃ¼yÃ¼k DÃ¶nÃ¼ÅŸÃ¼mler</h3><h4>Yeni BaÅŸlayanlar ve Junior GeliÅŸtiriciler: SÃ¼rekli Ã–ÄŸrenmenin Ã–nemi</h4><p>Uzun vadede, YZ'nin kod Ã¼retme yeteneÄŸinin artmasÄ±yla juniorlarÄ±n rollerinde kÃ¶klÃ¼ deÄŸiÅŸiklikler gÃ¶rÃ¼lebilir. Bir Ã§alÄ±ÅŸma, 2040&#39;ta makinelerin kendi kodlarÄ±nÄ±n Ã§oÄŸunu yazabileceÄŸini Ã¶ngÃ¶rÃ¼yor. Ancak endiÅŸelenmeyin! Bu senaryoda bile geliÅŸtiricilerin tamamen ortadan kalkmayacaÄŸÄ± tahmin ediliyor; Ã§Ã¼nkÃ¼ insanlarÄ±n Ã¶zellikle <strong>veri hazÄ±rlama, algoritma tasarÄ±mÄ± ve sistem entegrasyonu</strong> gibi alanlara odaklanmasÄ± gerekecek.</p><p>Zaten yazÄ±lÄ±mcÄ±lar olarak sÃ¼rekli Ã¶ÄŸrenmeye alÄ±ÅŸkÄ±n bir grubuz; 2015â€“2022 arasÄ±nda gerekli becerilerin %30&#39;dan fazla deÄŸiÅŸtiÄŸini gÃ¶rÃ¼yoruz. TÃ¼rkiye'de de geleceÄŸe yÃ¶nelik raporlar, Ã§alÄ±ÅŸanlarÄ±n %59&#39;unun yeniden eÄŸitime ihtiyaÃ§ duyacaÄŸÄ±nÄ± vurguluyor. KÄ±sacasÄ±, junior geliÅŸtiriciler iÃ§in uzun vadeli yol haritasÄ±, YZ ile Ã§alÄ±ÅŸmayÄ± Ã¶ÄŸrenmek ve sÃ¼rekli yeni beceriler kazanmak Ã¼zerine kurulu olacak.</p><h4>Orta Seviye GeliÅŸtiriciler: LiderliÄŸe ve YaratÄ±cÄ±lÄ±ÄŸa DoÄŸru!</h4><p>GeÃ§miÅŸteki teknolojik devrimler yeni uzmanlÄ±klar ve iÅŸ alanlarÄ± yaratarak yazÄ±lÄ±mcÄ± talebini artÄ±rdÄ±. Benzer ÅŸekilde, yazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ± 2030 ve Ã¶tesine evrildikÃ§e, kodun bir kÄ±smÄ±nÄ±n YZ'ye devredilmesi beklense de geliÅŸtiricilere her zaman ihtiyaÃ§ duyulacak. YZ destekli otomasyon rutin iÅŸleri Ã¼stlenirken, yÃ¼ksek dÃ¼zeyde <strong>yaratÄ±cÄ±lÄ±k ve problem Ã§Ã¶zme</strong> gerektiren gÃ¶revler insanlara bÄ±rakÄ±lacak. Orta dÃ¼zey geliÅŸtiriciler ise uzun vadede <strong>ekip liderliÄŸi, proje yÃ¶netimi ve yeni nesil uygulamalarÄ±n geliÅŸtirilmesi</strong> gibi rollere kayarak deÄŸer katmaya devam edecekler. Yani kodun Ã§oÄŸu otomatikleÅŸse bile, yazÄ±lÄ±mcÄ±larÄ±n yÃ¶nlendirme ve uyarlama rolÃ¼ sÃ¼recek.</p><h4>KÄ±demli (Senior) GeliÅŸtiriciler: OrganizasyonlarÄ±n Rehberleri!</h4><p>Uzun dÃ¶nemde de kÄ±demli geliÅŸtiriciler <strong>stratejik karar alma, bÃ¼yÃ¼k sistemleri tasarlama ve ekipleri yÃ¶nlendirme</strong> gÃ¶revlerinde kilit Ã¶nemde kalacak. Yapay zekÃ¢ uygulamalarÄ± yaygÄ±nlaÅŸtÄ±kÃ§a, bu yazÄ±lÄ±mcÄ±lar yeni sÃ¼reÃ§leri uyarlama, proje planlama ve veri temelli karar alma konularÄ±nda ekiplerine Ã¶ncÃ¼lÃ¼k edecekler. AyrÄ±ca, kurum iÃ§i eÄŸitim programlarÄ± ve hackathonlar dÃ¼zenleyerek, daha az deneyimli meslektaÅŸlarÄ±nÄ±n YZ araÃ§larÄ±nÄ± Ã¶ÄŸrenmesine katkÄ± saÄŸlayacaklarÄ± Ã¶ngÃ¶rÃ¼lÃ¼yor. BÃ¶ylece kÄ±demli geliÅŸtiriciler, hÄ±zla deÄŸiÅŸen teknolojik ortamda organizasyonlarÄ±n yol gÃ¶sterici figÃ¼rleri olmaya devam edecekler.</p><h3>YZ'nin DiÄŸer Mesleklere Etkisi ve KÃ¼resel Trendler</h3><p>Yapay zekÃ¢ etkisi sadece yazÄ±lÄ±mcÄ±larla sÄ±nÄ±rlÄ± kalmayacak. DÃ¼nya Ekonomik Forumu (WEF) 2030 projeksiyonlarÄ±na gÃ¶re, yazÄ±lÄ±m geliÅŸtiriciler ve YZ/ML uzmanlarÄ± gibi teknoloji odaklÄ± roller en hÄ±zlÄ± bÃ¼yÃ¼yen meslek gruplarÄ± arasÄ±nda yer alacak. Buna karÅŸÄ±lÄ±k, kasiyer, sekreter ve veri giriÅŸi gibi rutin ofis iÅŸleri azalma eÄŸiliminde. WEF ayrÄ±ca, 2025â€“2030 arasÄ±nda dÃ¼nya genelinde <strong>170 milyon yeni iÅŸ yaratÄ±lacaÄŸÄ±nÄ±</strong>, yaklaÅŸÄ±k 92 milyon iÅŸ kaybÄ± olacaÄŸÄ±nÄ± (net yaklaÅŸÄ±k +78 milyon) Ã¶ngÃ¶rÃ¼yor. Bu veriler, YZ'nin genel istihdama bÃ¼yÃ¼k oranda olumlu yansÄ±dÄ±ÄŸÄ±nÄ± gÃ¶steriyor.</p><p>Ã–zellikle saÄŸlÄ±k, eÄŸitim ve yenilenebilir enerji gibi insan merkezli sektÃ¶rlerde bÃ¼yÃ¼me sÃ¼rerken; montaj, lojistik ve mÃ¼ÅŸteri hizmetleri gibi otomasyona uygun iÅŸler gÃ¶zden geÃ§irme gerektirecek. Ã–zetle, dÃ¼ÅŸÃ¼k vasÄ±flÄ± ve tekrarlÄ± iÅŸlerde risk yÃ¼ksek, yÃ¼ksek teknoloji ve yaratÄ±cÄ± iÅŸlerde ise yeni fÄ±rsatlar Ã¶ne Ã§Ä±kÄ±yor.</p><h3>TÃ¼rkiye ve Avrupa BirliÄŸi Perspektifi: DÃ¶nÃ¼ÅŸÃ¼m BaÅŸlÄ±yor!</h3><p>TÃ¼rkiye Ã¶zelinde, Google destekli bir Ã§alÄ±ÅŸma Ã¶nÃ¼mÃ¼zdeki 10 yÄ±lda YZ'nin ulusal GSYH'ye %5&#39;e yakÄ±n katkÄ± saÄŸlayabileceÄŸini ve mevcut iÅŸ pozisyonlarÄ±nÄ±n %59&#39;unun YZ'den etkilenebileceÄŸini Ã¶ngÃ¶rÃ¼yor. YaklaÅŸÄ±k 17 milyon iÅŸ YZ ile Ã¼retkenlik kazanÄ±rken, 13 milyon iÅŸ otomasyondan fazla etkilenmeyip sabit kalacak; geriye kalan %4 ise tamamen dÃ¶nÃ¼ÅŸÃ¼me uÄŸrayacak. Bu tablo, TÃ¼rkiye'de net bir iÅŸ kaybÄ± beklenmediÄŸini gÃ¶steriyor. Ancak, YZ'nin iÅŸyerlerine entegrasyonunda <strong>ÅŸeffaflÄ±k, iÅŸÃ§i haklarÄ± ve yeniden eÄŸitim</strong> Ã¶ncelikli konular arasÄ±nda.</p><p>Avrupa BirliÄŸi genelinde de benzer bir iyimserlik hakim; ECB anketinde Ã§alÄ±ÅŸanlarÄ±n %41&#39;i YZ'nin iÅŸlerini iyileÅŸtireceÄŸini dÃ¼ÅŸÃ¼nÃ¼rken, yalnÄ±zca %20&#39;si olumsuz etkiler bekliyor. Ã–nemli olan, bu deÄŸiÅŸime hazÄ±rlanmak ve yaÅŸam boyu Ã¶ÄŸrenme yaklaÅŸÄ±mÄ±nÄ± benimsemek.</p><h3>GeleceÄŸe NasÄ±l HazÄ±rlanmalÄ±yÄ±z?</h3><p>Yapay zekÃ¢nÄ±n geliÅŸimi, yazÄ±lÄ±m sektÃ¶rÃ¼ ve diÄŸer meslek gruplarÄ± iÃ§in hem fÄ±rsatlar hem de meydan okumalar getiriyor. Mevcut veriler Ä±ÅŸÄ±ÄŸÄ±nda, genel kanÄ± yeni iÅŸ yaratma eÄŸilimlerinin aÄŸÄ±r bastÄ±ÄŸÄ± yÃ¶nÃ¼nde; ancak dÃ¶nÃ¼ÅŸÃ¼mden en Ã§ok etkilenecek alanlarda <strong>beceri ve yeniden eÄŸitim ihtiyacÄ±</strong> artacak. Bir yazÄ±lÄ±mcÄ± olarak aÅŸaÄŸÄ±daki Ã§Ä±karÄ±mlarÄ± Ã¶ncelikli gÃ¶rÃ¼yorum:</p><ul><li><strong>SÃ¼rekli Ã–ÄŸrenme:</strong> Yapay zekÃ¢ ve makine Ã¶ÄŸrenimi temellerini, yeni YZ araÃ§larÄ±nÄ± Ã¶ÄŸrenmek ÅŸart. Kurslar, sertifikalar ve proje Ã§alÄ±ÅŸmalarÄ±yla becerimizi gÃ¼ncel tutmalÄ±yÄ±z.</li><li><strong>YZ AraÃ§larÄ±na Uyum SaÄŸlama:</strong> Kod tamamlama, veri analizi ve otomasyon araÃ§larÄ±nÄ± aktif kullanmak, verimliliÄŸimizi artÄ±rÄ±r. Deneme atÃ¶lyeleri veya hackathon'lar dÃ¼zenleyerek bilgi paylaÅŸabiliriz.</li><li><strong>Esneklik ve Ä°letiÅŸim:</strong> Ä°ÅŸ dÃ¼nyasÄ±nda YZ uygulamalarÄ±nÄ± benimserken iÅŸverenlerle yakÄ±n iÅŸbirliÄŸi yapmalÄ±, belirsizliklere karÅŸÄ± ÅŸeffaflÄ±k talep etmeliyiz. Diyalog kanallarÄ± bu sÃ¼reÃ§te kritik Ã¶nemde.</li><li><strong>Yeni UzmanlÄ±klara YÃ¶nelim:</strong> Veri bilimi, yapay zekÃ¢ mÃ¼hendisliÄŸi ve YZ uygulama geliÅŸtirme gibi alanlara yatÄ±rÄ±m yapmak gelecek iÃ§in avantaj saÄŸlayacak.</li><li><strong>DeÄŸer OluÅŸturmaya Odaklanma:</strong> TekrarlÄ± ve kolay otomatikleÅŸebilir iÅŸler yerine yaratÄ±cÄ±, problem Ã§Ã¶zmeye yÃ¶nelik gÃ¶revlerde uzmanlaÅŸmak Ã¶nemli. Mimari tasarÄ±m, kullanÄ±cÄ± deneyimi, stratejik planlama gibi insan becerisi gerektiren konularda kendimizi geliÅŸtirmeliyiz.</li></ul><p>SonuÃ§ olarak, kÄ±sa vadede Ã¼retkenlik artÄ±ÅŸÄ± Ã¶ne Ã§Ä±karken uzun vadede iÅŸ dÃ¼nyasÄ± dÃ¶nÃ¼ÅŸtÃ¼kÃ§e rolleri uyarlamak kaÃ§Ä±nÄ±lmaz olacak. YazÄ±lÄ±m geliÅŸtiricileri, YZ Ã§aÄŸÄ±nda yeni araÃ§lara ayak uydurarak katma deÄŸer yaratmayÄ± sÃ¼rdÃ¼recekler. DoÄŸru eÄŸitim ve politika adÄ±mlarÄ±yla, TÃ¼rkiye ve AB'de de bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼n yeni iÅŸ fÄ±rsatlarÄ±na dÃ¶nÃ¼ÅŸmesi hedefleniyor. Ancak herkesin bu deÄŸiÅŸime hazÄ±rlanmasÄ±, <strong>yaÅŸam boyu Ã¶ÄŸrenme</strong> yaklaÅŸÄ±mÄ±nÄ± benimsemesi ÅŸart. UnutmayÄ±n, yapay zekÃ¢ bÃ¼yÃ¼k ihtimalle iÅŸleri yok etmeyecek, sadece dÃ¶nÃ¼ÅŸtÃ¼recek; Ã¶nemli olan bu dÃ¶nÃ¼ÅŸÃ¼mden en kÃ¢rlÄ± Ã§Ä±kan taraf olmaktÄ±r.</p><p><strong>Peki siz bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼n neresinde yer almayÄ± hedefliyorsunuz?</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4235efc6f12b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot'u Quarkus ile DeÄŸiÅŸtirdim: Daha HÄ±zlÄ±, Daha Hafif Java UygulamalarÄ±na GeliÅŸtiriciâ€¦ ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-bootu-quarkus-ile-de%C4%9Fi%C5%9Ftirdim-daha-h%C4%B1zl%C4%B1-daha-hafif-java-uygulamalar%C4%B1na-geli%C5%9Ftirici-3d7a41a19117?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/3d7a41a19117</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 27 May 2025 21:25:19 GMT</pubDate>
<atom:updated>2025-05-27T21:30:04.497Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jePivlT6_mBMahzWD2TCQQ.png" /></figure><h3>Spring Bootâ€™u Quarkus ile DeÄŸiÅŸtirdim: Daha HÄ±zlÄ±, Daha Hafif Java UygulamalarÄ±na GeliÅŸtirici YolculuÄŸum ğŸš€</h3><p><strong>TanÄ±dÄ±k bir dosttan yeni bir yarÄ±ÅŸmacÄ±ya geÃ§iÅŸ deneyimimi paylaÅŸtÄ±ÄŸÄ±m, iÃ§gÃ¶rÃ¼lerim ve kod Ã¶rnekleriyle dolu bir yazÄ± kaleme aldÄ±m.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*41fzbNVSA4wcJZiJaDlYLA.png" /></figure><p>YÄ±llardÄ±r <strong>Spring Boot</strong>, Java uygulamalarÄ± geliÅŸtirmek iÃ§in vazgeÃ§ilmez frameworkâ€™Ã¼m oldu. SaÄŸlam, devasa bir topluluÄŸa ve akla gelebilecek neredeyse her ihtiyacÄ± karÅŸÄ±layan bir ekosisteme sahip. Ancak son zamanlarda, sÄ±k sÄ±k â€œSÃ¼personik AtomaltÄ± Javaâ€ olarak lanse edilen <strong>Quarkus</strong> etrafÄ±ndaki heyecanÄ± duyuyordum. Ä°nanÄ±lmaz hÄ±zlÄ± aÃ§Ä±lÄ±ÅŸ sÃ¼releri, dÃ¼ÅŸÃ¼k bellek kullanÄ±mÄ± ve GraalVM ile sorunsuz native derleme vaatleri gÃ¶rmezden gelinemeyecek kadar cazipti.</p><p>Bu yÃ¼zden bir denemeye karar verdim: Mevcut Spring Boot mikroservislerimden birini seÃ§tim ve Quarkusâ€™a taÅŸÄ±dÄ±m. Bu makale benim hikayemâ€Šâ€”â€Šnedenleri, nasÄ±llarÄ±, zorluklarÄ± ve sonuÃ§larÄ±. AmacÄ±m, benzer bir geÃ§iÅŸ yapmayÄ± merak eden junior ve orta seviye geliÅŸtirici arkadaÅŸlarÄ±ma pratik bir yol haritasÄ± sunmak. Quarkusâ€™un gerÃ§ekten de sÃ¶ylendiÄŸi kadar iyi olup olmadÄ±ÄŸÄ±nÄ± ve geliÅŸtirme iÅŸ akÄ±ÅŸÄ±nÄ±z iÃ§in ne anlama geldiÄŸini keÅŸfedeceÄŸiz.</p><p>Bu yazÄ±da ÅŸunlarÄ± ele alacaÄŸÄ±z:</p><ul><li>Spring Boot dÃ¼nyasÄ±nda neden Quarkusâ€™u dÃ¼ÅŸÃ¼nmelisiniz?</li><li>BaÅŸlangÄ±Ã§taki Spring Boot uygulamamÄ±za hÄ±zlÄ± bir bakÄ±ÅŸ.</li><li>Kod Ã¶rnekleriyle Quarkusâ€™a adÄ±m adÄ±m geÃ§iÅŸ sÃ¼reci.</li><li>Proje kurulumu, REST denetleyicileri ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonundaki temel farklar.</li><li>Performans gÃ¶zlemleri (kavramsal).</li><li>KarÅŸÄ±laÅŸÄ±lan zorluklar ve bunlarÄ±n Ã¼stesinden gelmek iÃ§in ipuÃ§larÄ±.</li></ul><h3>ğŸ¤” Neden Spring Bootâ€™un Konfor AlanÄ±ndan Ã‡Ä±kÄ±p Quarkusâ€™a YÃ¶nelmeli?</h3><p>Spring Boot harika, ancak Ã¶zellikle mikroservislerin, sunucusuz (serverless) yapÄ±larÄ±n ve konteynerleÅŸtirmenin yaygÄ±nlaÅŸtÄ±ÄŸÄ±, aÃ§Ä±lÄ±ÅŸ sÃ¼resi ve bellek kullanÄ±mÄ±nÄ±n kritik olduÄŸu bir dÃ¼nyada her zaman mÃ¼kemmel bir seÃ§im olmayabilir. Junior ve orta seviye geliÅŸtiriciler, daha fazla uygulama daÄŸÄ±tmaya baÅŸladÄ±kÃ§a bu zorluklarla sÄ±kÃ§a karÅŸÄ±laÅŸÄ±rlar.</p><p>Quarkusâ€™ta ilgimi Ã§ekenler ÅŸunlar oldu:</p><ul><li><strong>IÅŸÄ±k HÄ±zÄ±nda AÃ§Ä±lÄ±ÅŸ SÃ¼releri:</strong> Quarkus uygulamalarÄ± milisaniyeler iÃ§inde baÅŸlayabilir. Bu, geliÅŸtirme (daha hÄ±zlÄ± geri bildirim dÃ¶ngÃ¼leri!) ve konteynerleÅŸtirilmiÅŸ ortamlarda Ã¶lÃ§eklendirme iÃ§in oyunun kurallarÄ±nÄ± deÄŸiÅŸtiriyor.</li><li><strong>AzaltÄ±lmÄ±ÅŸ Bellek KullanÄ±mÄ±:</strong> Quarkus, inanÄ±lmaz derecede bellek verimli olacak ÅŸekilde tasarlanmÄ±ÅŸtÄ±r; bu da daha dÃ¼ÅŸÃ¼k altyapÄ± maliyetleri ve daha yÃ¼ksek yoÄŸunluklu daÄŸÄ±tÄ±mlar anlamÄ±na gelir.</li><li><strong>GraalVM ile Native Derleme:</strong> Bu, Java kodunuzu native bir yÃ¼rÃ¼tÃ¼lebilir dosyaya derlemenizi saÄŸlar, bu da daha da hÄ±zlÄ± aÃ§Ä±lÄ±ÅŸ ve daha kÃ¼Ã§Ã¼k Ã§alÄ±ÅŸma zamanÄ± boyutuyla sonuÃ§lanÄ±r. Bu bazÄ± karmaÅŸÄ±klÄ±klar getirse de (bunlara deÄŸineceÄŸiz), faydalarÄ± Ã§ok bÃ¼yÃ¼k olabilir.</li><li><strong>GeliÅŸtirici MutluluÄŸu (Developer Joy):</strong> Quarkus, canlÄ± kodlama (live coding), birleÅŸik yapÄ±landÄ±rma ve popÃ¼ler Java kÃ¼tÃ¼phaneleri ile standartlarÄ± iÃ§in kapsamlÄ± destek gibi Ã¶zelliklerle harika bir geliÅŸtirici deneyimi sunmayÄ± amaÃ§lar. Bu, junior geliÅŸtiricilerin yeni sistemleri hÄ±zla anlamalarÄ±na ve oluÅŸturmalarÄ±na yardÄ±mcÄ± olur.</li><li><strong>Ä°mperatif ve Reaktif ArasÄ±nda KÃ¶prÃ¼:</strong> Quarkus, hem geleneksel imperatif programlamayÄ± (Spring Boot geliÅŸtiricilerine tanÄ±dÄ±k) hem de reaktif programlama modellerini destekler.</li></ul><p>Quarkusâ€™un arkasÄ±ndaki temel fikir, Ã§alÄ±ÅŸma zamanÄ± yerine <strong>derleme zamanÄ±nda</strong> mÃ¼mkÃ¼n olduÄŸunca fazla iÅŸ yapmaktÄ±r. Bu, baÄŸÄ±mlÄ±lÄ±k enjeksiyonunu, yapÄ±landÄ±rma iÅŸlemeyi ve framework baÅŸlatmayÄ± iÃ§erir, bu da daha yalÄ±n ve daha hÄ±zlÄ± uygulamalara yol aÃ§ar. Bu yaklaÅŸÄ±m, sadece â€œhÄ±zlÄ± Ã§Ã¶zÃ¼mlerâ€ yerine, temel kavramlarÄ±n saÄŸlam bir ÅŸekilde anlaÅŸÄ±lmasÄ±nÄ± teÅŸvik ederek daha derin bir anlayÄ±ÅŸ gerektirir.</p><h3>ğŸ BaÅŸlangÄ±Ã§ NoktamÄ±z: Basit Bir Spring Boot REST Servisi</h3><p>Ä°ÅŸleri odaklÄ± tutmak iÃ§in Ã§ok basit bir Spring Boot uygulamasÄ± hayal edelim. Bir selamlama mesajÄ± dÃ¶ndÃ¼ren tek bir REST endpointâ€™i var.</p><p><strong>pom.xml (Spring Bootâ€Šâ€”â€ŠTemel BaÄŸÄ±mlÄ±lÄ±klar):</strong></p><p>Bunun bir GitHub Gistâ€™ten gÃ¶mÃ¼ldÃ¼ÄŸÃ¼nÃ¼ veya Mediumâ€™un kod bloÄŸu Ã¶zelliÄŸini kullandÄ±ÄŸÄ±nÄ±zÄ± hayal edin.</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;/dependencies&gt;</pre><p><strong>GreetingController.java (Spring Boot):</strong></p><pre>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class GreetingController {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Kodda sabit deÄŸerlerden kaÃ§Ä±nÄ±n, sabitler kullanÄ±n [cite: 187]<br> @GetMapping(&quot;/hello-spring&quot;)<br> public String greet(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;DÃ¼nya&quot;) String name) {<br> return String.format(template, name);<br> }<br>}</pre><p>Bu standart bir Spring Boot kurulumu. Åimdi, Quarkusâ€™ta aynÄ±sÄ±nÄ± nasÄ±l baÅŸarabileceÄŸimize bakalÄ±m.</p><h3>ğŸ› ï¸ GeÃ§iÅŸ: Spring Bootâ€™tan Quarkusâ€™a AdÄ±m AdÄ±m</h3><p>GeÃ§iÅŸ, Quarkusâ€™un kurallarÄ±nÄ± ve REST, CDI ve yapÄ±landÄ±rma gibi yaygÄ±n gÃ¶revleri nasÄ±l ele aldÄ±ÄŸÄ±nÄ± anlamayÄ± iÃ§erir. Bunu parÃ§a parÃ§a oluÅŸturacak ve deÄŸiÅŸikliklerin ardÄ±ndaki â€œnedenâ€i aÃ§Ä±klayacaÄŸÄ±z.</p><h4><strong>1. Yeni Bir Quarkus Projesi OluÅŸturma</strong></h4><p>Quarkus CLI, Maven eklentisi veya <a href="https://code.quarkus.io/">code.quarkus.io</a> adresinden bir Quarkus projesi oluÅŸturabilirsiniz. Bu Ã¶rnek iÃ§in Maven pom.xml deÄŸiÅŸikliklerine odaklanacaÄŸÄ±z.</p><p><strong>pom.xml (Quarkusâ€Šâ€”â€ŠTemel BaÄŸÄ±mlÄ±lÄ±klar):</strong></p><pre>&lt;dependencyManagement&gt;<br> &lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;<br> &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;<br> &lt;version&gt;&lt;span class=&quot;math-inline&quot;&gt;\{quarkus\.platform\.version\}&lt;/version\&gt;&lt;/31\&gt; &lt;type\&gt;pom&lt;/type\&gt;<br>&lt;scope\&gt;import&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;&lt;/32\&gt;<br>&lt;/dependencyManagement\&gt;<br>&lt;dependencies\&gt;<br>&lt;&lt;34\&gt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive\-jackson&lt;/artifactId\&gt; &lt;/dependency\&gt;&lt;/34\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-arc&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-junit5&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.rest\-assured&lt;/groupId\&gt;<br>&lt;artifactId\&gt;rest\-assured&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;<br>&lt;build\&gt;<br>&lt;plugins\&gt;<br>&lt;&lt;33\&gt;plugin\&gt;<br>&lt;groupId\&gt;io\.quarkus\.platform&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-maven\-plugin&lt;/artifactId\&gt;<br>&lt;version\&gt;&lt;/span&gt;{quarkus.platform.version}&lt;/version&gt;<br> &lt;executions&gt;<br> &lt;execution&gt;<br> &lt;goals&gt;<br> &lt;goal&gt;build&lt;/goal&gt;<br> &lt;goal&gt;generate-code&lt;/goal&gt;<br> &lt;goal&gt;generate-code-tests&lt;/goal&gt;<br> &lt;/goals&gt;<br> &lt;/execution&gt;<br> &lt;/executions&gt;<br> &lt;/plugin&gt;<br> &lt;/plugins&gt;<br>&lt;/build&gt;</pre><ul><li><strong>Temel deÄŸiÅŸiklikler:</strong> BaÄŸÄ±mlÄ±lÄ±k yÃ¶netimi iÃ§in quarkus-bom&#39;u import ediyoruz.</li><li>Spring Web MVC yerine JAX-RS (Quarkusâ€™un kullandÄ±ÄŸÄ± Java EE/Jakarta EEâ€™deki REST standardÄ±) iÃ§in quarkus-resteasy-reactive kullanÄ±lÄ±r.</li><li>quarkus-arc, Quarkus&#39;un CDI (Contexts and Dependency Injection) Ã¼zerine kurulu ArC DI Ã§Ã¶zÃ¼mÃ¼dÃ¼r.</li></ul><h4>2. Quarkusâ€™ta REST Endpointâ€™i OluÅŸturma</h4><p>Quarkus, REST endpointâ€™lerini tanÄ±mlamak iÃ§in JAX-RS anotasyonlarÄ±nÄ± kullanÄ±r. Bunlar standart Java EE anotasyonlarÄ±dÄ±r, bu nedenle Spring dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸtÄ±ysanÄ±z tanÄ±dÄ±k gelebilirler.</p><p><strong>GreetingResource.java (Quarkus):</strong></p><p>(Not: JAX-RSâ€™te denetleyicilere genellikle â€œResourceâ€ denir)</p><pre>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus&quot;) // Bu kaynak iÃ§in temel yol<br>public class GreetingResource {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Sabit kodlanmÄ±ÅŸ dizelerden kaÃ§Ä±nÄ±n, sabitler kullanÄ±n [cite: 187]<br> @GET // HTTP GET metodu<br> @Produces(MediaType.TEXT_PLAIN) // YanÄ±tÄ±n iÃ§erik tÃ¼rÃ¼<br> public String greet(@QueryParam(&quot;name&quot;) String name) { // @RequestParam yerine @QueryParam<br> // name null veya boÅŸsa varsayÄ±lan bir deÄŸer kullanÄ±n<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus DÃ¼nyasÄ±&quot;;<br> return String.format(template, displayName);<br> }<br>}</pre><ul><li>@Path: Bu kaynak iÃ§in temel URI yolunu tanÄ±mlar.</li><li>@GET: Bu metodun HTTP GET isteklerini iÅŸlediÄŸini belirtir.</li><li>@Produces(MediaType.TEXT_PLAIN): YanÄ±t iÃ§erik tÃ¼rÃ¼nÃ¼ gÃ¶sterir.</li><li>@QueryParam(&quot;name&quot;): &quot;name&quot; adlÄ± sorgu parametresinin deÄŸerini enjekte eder. Bu, Spring&#39;in @RequestParam&#39;Ä±na benzer.</li></ul><p>Bu yapÄ± aÃ§Ä±ktÄ±r ve tek bir sorumluluÄŸa odaklanÄ±r, temiz kod ilkelerine uyar.</p><h4>3. BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu (CDI)</h4><p>Quarkus, CDI implementasyonu olan ArCâ€™yi kullanÄ±r. Bunun gibi basit durumlar iÃ§in hemen Ã§ok fazla fark gÃ¶rmeyebilirsiniz, ancak uygulamanÄ±z bÃ¼yÃ¼dÃ¼kÃ§e @ApplicationScoped, @Inject vb. CDI anotasyonlarÄ±nÄ± kullanacaksÄ±nÄ±z.</p><p>GreetingResource&#39;umuzun bir servise ihtiyacÄ± olsaydÄ± ÅŸÃ¶yle gÃ¶rÃ¼nÃ¼rdÃ¼:</p><p><strong>GreetingService.java (Quarkus):</strong></p><pre>import jakarta.enterprise.context.ApplicationScoped; // CDI anotasyonu<br>@ApplicationScoped // Bu bean, uygulamanÄ±n Ã¶mrÃ¼ boyunca yaÅŸayacaktÄ±r<br>public class GreetingService {<br> public String getGreetingMessage(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Servisi&quot;;<br> return String.format(&quot;Servisten merhaba, %s!&quot;, displayName);<br> }<br>}</pre><p><strong>GreetingResource.java (Quarkusâ€Šâ€”â€Šenjekte edilmiÅŸ servisle):</strong></p><pre>import jakarta.inject.Inject; // Enjeksiyon iÃ§in CDI anotasyonu<br>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus-service&quot;)<br>public class GreetingResource {<br> @Inject // GreetingService&#39;i enjekte et<br> GreetingService service;<br> @GET<br> @Produces(MediaType.TEXT_PLAIN)<br> public String greet(@QueryParam(&quot;name&quot;) String name) {<br> return service.getGreetingMessage(name);<br> }<br>}</pre><p>Bu, Springâ€™in @Autowired ve @Service/@Component&#39;Ä±na Ã§ok benzer. Servisler ve metotlar iÃ§in anlamlÄ± isimler kullanmak aÃ§Ä±klÄ±k iÃ§in Ã¶nemlidir.</p><h4>4. YapÄ±landÄ±rma</h4><p>Quarkusâ€™ta yapÄ±landÄ±rma, Spring Bootâ€™ta olduÄŸu gibi src/main/resources iÃ§indeki application.properties aracÄ±lÄ±ÄŸÄ±yla yapÄ±lÄ±r.</p><p>Ã–rnek src/main/resources/application.properties:</p><pre>quarkus.application.name=my-quarkus-app<br>quarkus.application.version=1.0.0<br># HTTP portunu deÄŸiÅŸtirmek iÃ§in (varsayÄ±lan 8080&#39;dir)<br>quarkus.http.port=8081<br># Ã–zel Ã¶zellikler<br>greeting.message.prefix=Aloha</pre><p>Bu Ã¶zellikleri @ConfigProperty kullanarak enjekte edebilirsiniz:</p><pre>import org.eclipse.microprofile.config.inject.ConfigProperty;<br>import jakarta.enterprise.context.ApplicationScoped;<br>@ApplicationScoped<br>public class ConfigurableGreetingService {<br> @ConfigProperty(name = &quot;greeting.message.prefix&quot;, defaultValue = &quot;Merhaba&quot;)<br> String prefix;<br> public String greetWithConfig(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Config DÃ¼nyasÄ±&quot;;<br> return String.format(&quot;%s, %s!&quot;, prefix, displayName);<br> }<br>}</pre><p>Bu isimler birden fazla yerde kullanÄ±lÄ±yorsa, Ã¶zellik adlarÄ± iÃ§in isimlendirilmiÅŸ sabitler kullanmak iyi bir uygulamadÄ±r.</p><h4>5. GeliÅŸtirme Modunda Ã‡alÄ±ÅŸtÄ±rma</h4><p>Quarkusâ€™un en havalÄ± Ã¶zelliklerinden biri geliÅŸtirme modudur:</p><pre>./mvnw quarkus:dev</pre><p>Veya Gradle kullanÄ±yorsanÄ±z:</p><pre>./gradlew quarkusDev</pre><p>Bu, uygulamayÄ± baÅŸlatÄ±r ve kodunuzda yaptÄ±ÄŸÄ±nÄ±z herhangi bir deÄŸiÅŸiklik neredeyse anÄ±nda otomatik olarak yeniden yÃ¼klenir. Bu, geliÅŸtirme dÃ¶ngÃ¼sÃ¼nÃ¼ Ã¶nemli Ã¶lÃ§Ã¼de hÄ±zlandÄ±rÄ±r.</p><h4>6. Ãœretim iÃ§in Derleme</h4><p>Standart bir JAR oluÅŸturabilirsiniz:</p><pre>./mvnw package</pre><p>Bu, target/quarkus-app/ dizininde Ã§alÄ±ÅŸtÄ±rÄ±labilir bir JAR oluÅŸturur.</p><p><strong>Native yÃ¼rÃ¼tÃ¼lebilir dosya</strong> oluÅŸturmak iÃ§in (GraalVMâ€™in kurulu ve yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmasÄ±nÄ± gerektirir):</p><pre>./mvnw package -Pnative</pre><p>Bu, target/ dizininde native bir yÃ¼rÃ¼tÃ¼lebilir dosya Ã¼retecektir. Bu dosya kendi kendine yeterlidir ve inanÄ±lmaz hÄ±zlÄ± baÅŸlar. Native yÃ¼rÃ¼tÃ¼lebilir dosyalar oluÅŸturma sÃ¼reci, Ã¶zellikle bazÄ± kÃ¼tÃ¼phaneler iÃ§in yansÄ±ma (reflection) ihtiyaÃ§larÄ±nÄ± anlamak aÃ§Ä±sÄ±ndan kendi baÅŸÄ±na bir Ã¶ÄŸrenme eÄŸrisi olabilir.</p><h3>ğŸ“Š Performans:</h3><h4><em>Kavramsal Grafik 1: BaÅŸlangÄ±Ã§ SÃ¼resi</em></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zaD-sBfXUd3f-iFYMjXvLQ.png" /></figure><h4><strong>Kavramsal Grafik 2: Bellek KullanÄ±mÄ± (YerleÅŸik KÃ¼me Boyutuâ€Šâ€”â€ŠRSS)</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sVt2Wf45BvPtgeeijhH8Eg.png" /></figure><h3>âš ï¸ Zorluklar ve Ã–ÄŸrenimler</h3><p>GeÃ§iÅŸ genellikle olumluydu, ancak Ã¶ÄŸrenmek bazen zorlayÄ±cÄ± oldu.</p><ul><li><strong>FarklÄ± Ekosistem ve APIâ€™ler:</strong> BirÃ§ok kavram benzer olsa da, belirli APIâ€™ler ve kÃ¼tÃ¼phaneler (Ã¶rneÄŸin, REST iÃ§in JAX-RS, yapÄ±landÄ±rma iÃ§in MicroProfile Config) Springâ€™inkinden farklÄ±dÄ±r. Bu, bazÄ± ÅŸeyleri unutmayÄ± ve yeniden Ã¶ÄŸrenmeyi gerektirir. Bu, yeni kod tabanlarÄ± veya frameworkâ€™lerle karÅŸÄ±laÅŸan junior geliÅŸtiriciler iÃ§in yaygÄ±n bir engeldir.</li><li><strong>Native Derleme Ä°ncelikleri:</strong> UygulamanÄ±z Ã§ok fazla yansÄ±ma (reflection) veya dinamik sÄ±nÄ±f yÃ¼kleme kullanÄ±yorsa native yÃ¼rÃ¼tÃ¼lebilir dosyalar oluÅŸturmak bazen zor olabilir, Ã§Ã¼nkÃ¼ GraalVMâ€™in derleme zamanÄ±nda bunlarÄ± bilmesi gerekir. Quarkus Ã§ok yardÄ±mcÄ± olur, ancak zaman zaman ipuÃ§larÄ± vermeniz gerekebilir. Bu, sadece yÃ¼zeysel kodlamanÄ±n Ã¶tesinde daha derin bir anlayÄ±ÅŸa duyulan ihtiyacÄ± pekiÅŸtirir.</li><li><strong>Daha KÃ¼Ã§Ã¼k (ama BÃ¼yÃ¼yen) Topluluk:</strong> Quarkusâ€™un topluluÄŸu aktif ve hÄ±zla bÃ¼yÃ¼yor olsa da, henÃ¼z Spring kadar geniÅŸ deÄŸil. Bu, Ã§ok Ã¶zel sorunlara Ã§Ã¶zÃ¼m bulmanÄ±n bazen biraz daha fazla araÅŸtÄ±rma gerektirebileceÄŸi anlamÄ±na gelir.</li><li><strong>â€œDerleme ZamanÄ±ndaâ€ DÃ¼ÅŸÃ¼nmek:</strong> Daha fazlasÄ±nÄ± derleme zamanÄ±nda yapmaya geÃ§iÅŸ gÃ¼Ã§lÃ¼dÃ¼r ancak hafif bir zihinsel uyum gerektirir. Springâ€™de Ã§alÄ±ÅŸma zamanÄ±nda â€œsadece Ã§alÄ±ÅŸanâ€ bazÄ± ÅŸeyler, Quarkusâ€™ta derleme zamanÄ± dostu olmak iÃ§in aÃ§Ä±k yapÄ±landÄ±rma veya eklentiler gerektirebilir.</li></ul><p>Bu karmaÅŸÄ±k fikirleri basitleÅŸtirmek ve bunlarÄ±, temel bilgilerini hala geliÅŸtirmekte olan geliÅŸtiriciler iÃ§in sindirilebilir parÃ§alara ayÄ±rmak Ã§ok Ã¶nemlidir. Burada analojiler yardÄ±mcÄ± olabilir; Ã¶rneÄŸin, Quarkusâ€™un derleme zamanÄ± iÅŸlemesini, bir ÅŸefin piÅŸirmeden Ã¶nce tÃ¼m malzemeleri hazÄ±rlamasÄ± (mise en place) gibi dÃ¼ÅŸÃ¼nmek, Spring Bootâ€™un ise daha fazla hazÄ±rlÄ±ÄŸÄ± gerÃ§ek piÅŸirme iÅŸlemi sÄ±rasÄ±nda yapmasÄ±na karÅŸÄ±lÄ±k gelir.</p><h3>âœ… Karar: Spring Boot vs. Quarkusâ€Šâ€”â€ŠBenim Ã‡Ä±karÄ±mÄ±m</h3><p>Peki, Spring Bootâ€™u Quarkus ile deÄŸiÅŸtirmek buna deÄŸer miydi? <strong>Bu Ã¶zel mikroservis iÃ§in kesinlikle evet.</strong></p><p>BaÅŸlangÄ±Ã§ sÃ¼resi ve bellek azaltÄ±mÄ±ndaki performans kazanÄ±mlarÄ±, JVM modunda bile Ã¶nemliydi. CanlÄ± yeniden yÃ¼kleme ile geliÅŸtirici deneyimi harika. Quarkus modern, yalÄ±n ve bulut tabanlÄ± uygulamalar iÃ§in mÃ¼kemmel bir ÅŸekilde uygun hissettiriyor.</p><p><strong>Quarkusâ€™u ne zaman dÃ¼ÅŸÃ¼nmelisiniz:</strong></p><ul><li>Yeni mikroservisler veya sunucusuz iÅŸlevler oluÅŸtururken.</li><li>DÃ¼ÅŸÃ¼k bellek ayak izi ve hÄ±zlÄ± baÅŸlangÄ±Ã§ kritik olduÄŸunda.</li><li>GraalVM native derlemesinden yararlanmakla ilgileniyorsanÄ±z.</li><li>Kaynak verimliliÄŸinin maliyet tasarrufuna dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼ uygulamalar iÃ§in.</li></ul><p><strong>Spring Boot ne zaman hala daha iyi bir seÃ§im olabilir:</strong></p><ul><li>Tam bir yeniden yazÄ±mÄ±n mÃ¼mkÃ¼n olmadÄ±ÄŸÄ± bÃ¼yÃ¼k, mevcut monolitik uygulamalar.</li><li>HenÃ¼z doÄŸrudan Quarkus eÅŸdeÄŸerleri olmayan belirli Springâ€™e Ã¶zgÃ¼ kÃ¼tÃ¼phanelere veya modÃ¼llere bÃ¼yÃ¼k Ã¶lÃ§Ã¼de baÄŸÄ±mlÄ± projeler.</li><li>Mevcut derin Spring uzmanlÄ±ÄŸÄ±nÄ±n, acil proje hedefleri iÃ§in yeni bir frameworkâ€™Ã¼n Ã¶ÄŸrenme eÄŸrisinden daha aÄŸÄ±r bastÄ±ÄŸÄ± ekipler.</li></ul><p>Bu geÃ§iÅŸ, geliÅŸtiriciler olarak sÃ¼rekli olarak yeni araÃ§larÄ± ve paradigmalarÄ± keÅŸfetmemiz gerektiÄŸi fikrini pekiÅŸtiren deÄŸerli bir Ã¶ÄŸrenme deneyimi oldu. Mesele â€œX her zaman Yâ€™den iyidirâ€ deÄŸil, Ã¶dÃ¼nleÅŸimleri anlamak ve iÅŸ iÃ§in doÄŸru aracÄ± seÃ§mektir. Bu yolculuk aynÄ± zamanda, Ã¶zellikle yapay zeka gibi araÃ§larÄ±n derinlemesine anlamadan hÄ±zlÄ± Ã§Ã¶zÃ¼mler sunabileceÄŸi bir dÃ¶nemde, sadece framework sihrine gÃ¼venmek yerine temel Java kavramlarÄ±nÄ± anlamanÄ±n Ã¶nemini de vurguladÄ±.</p><h3>ğŸš€ SÄ±ra Sizde! Sonraki AdÄ±mlar ve Daha Fazla KeÅŸif</h3><p>Quarkus ilginizi Ã§ektiyse, baÅŸlamanÄ±za yardÄ±mcÄ± olacak bazÄ± kaynaklar ÅŸunlardÄ±r:</p><ul><li><strong>Quarkus KÄ±lavuzlarÄ±:</strong> <a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a>â€Šâ€”â€ŠResmi belgeler mÃ¼kemmeldir ve neredeyse her ÅŸey iÃ§in adÄ±m adÄ±m kÄ±lavuzlar sunar.</li><li><strong>Quarkus YouTube KanalÄ±:</strong> Harika eÄŸitimler ve konuÅŸmalar sunar.</li><li>Daha bÃ¼yÃ¼k projelere giriÅŸmeden Ã¶nce frameworkâ€™e alÄ±ÅŸmak iÃ§in kÃ¼Ã§Ã¼k bir <strong>â€œoyuncak uygulamaâ€</strong> oluÅŸturmayÄ± deneyin.</li></ul><h4>ğŸ’¬ Sizin DÃ¼ÅŸÃ¼nceleriniz Neler?</h4><p>Deneyimlerinizi duymak isterim!</p><ul><li>Quarkusâ€™u denediniz mi? Ä°zleniminiz neydi?</li><li>Spring Bootâ€™tan veya baÅŸka bir frameworkâ€™ten geÃ§meyi dÃ¼ÅŸÃ¼nÃ¼yor musunuz?</li><li>Ã–ngÃ¶rdÃ¼ÄŸÃ¼nÃ¼z en bÃ¼yÃ¼k zorluklar veya faydalar nelerdir?</li></ul><p>YorumlarÄ±nÄ±zÄ± aÅŸaÄŸÄ±ya bÄ±rakÄ±n! Birlikte Ã¶ÄŸrenelim. Ve bu makaleyi faydalÄ± bulduysanÄ±z, alkÄ±ÅŸlamayÄ± unutmayÄ±n ğŸ‘! EtkileÅŸiminiz, Medium algoritmasÄ±na bu iÃ§eriÄŸin deÄŸerli olduÄŸu sinyalini vermeye yardÄ±mcÄ± olur.</p><p>Java, Quarkus, Spring Boot, Mikroservisler, YazÄ±lÄ±m GeliÅŸtirme, Programlama</p><p><em>(Sorumluluk Reddi: Performans rakamlarÄ± kavramsal olup aÃ§Ä±klama amaÃ§lÄ±dÄ±r. GerÃ§ek sonuÃ§lar uygulamaya, iÅŸ yÃ¼kÃ¼ne ve ortama gÃ¶re deÄŸiÅŸiklik gÃ¶sterecektir.)</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d7a41a19117" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile E-posta GÃ¶nderimi ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-e-posta-g%C3%B6nderimi-d6715e02cefa?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/d6715e02cefa</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 06:12:35 GMT</pubDate>
<atom:updated>2025-05-09T06:12:35.054Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/737/1*JB9KkS2Ay2msUHwKXxCljw.png" /></figure><p>GÃ¼nÃ¼mÃ¼z uygulamalarÄ±nÄ±n vazgeÃ§ilmez bir parÃ§asÄ± olan e-posta iletiÅŸimi, kullanÄ±cÄ± kaydÄ±ndan bildirimlere, ÅŸifre sÄ±fÄ±rlamadan pazarlama kampanyalarÄ±na kadar geniÅŸ bir yelpazede kullanÄ±lÄ±yor. Spring Boot, spring-boot-starter-mail paketi ile bu sÃ¼reci oldukÃ§a basitleÅŸtiriyor. Ancak, sadece basit bir metin e-postasÄ± gÃ¶ndermenin Ã¶tesine geÃ§mek, HTML iÃ§erikler, ekler, ÅŸablonlar kullanmak ve asenkron gÃ¶nderim gibi konular, uygulamanÄ±zÄ±n profesyonelliÄŸini ve kullanÄ±cÄ± deneyimini doÄŸrudan etkiler.</p><p>Bu kapsamlÄ± rehberde, Spring Boot ile e-posta gÃ¶ndermenin temellerinden baÅŸlayarak, daha karmaÅŸÄ±k senaryolara ve en iyi uygulamalara kadar derinlemesine bir yolculuÄŸa Ã§Ä±kacaÄŸÄ±z. AmacÄ±mÄ±z, sadece e-posta gÃ¶ndermenizi saÄŸlamak deÄŸil, aynÄ± zamanda bu konuda ufkunuzu aÃ§arak daha saÄŸlam ve esnek Ã§Ã¶zÃ¼mler Ã¼retebilmenize yardÄ±mcÄ± olmak.</p><p><strong>Makale Ä°Ã§eriÄŸi:</strong></p><p><strong>Temel Kurulum ve BaÄŸÄ±mlÄ±lÄ±klar</strong></p><p><strong>application.properties ile YapÄ±landÄ±rma: SÄ±rlarÄ± ve Ä°ncelikleri</strong></p><ul><li>Gmail ile HÄ±zlÄ± BaÅŸlangÄ±Ã§ (Uygulama Åifresi OluÅŸturma)</li><li>DiÄŸer SMTP SaÄŸlayÄ±cÄ±larÄ± Ä°Ã§in Genel Ayarlar</li></ul><p><strong>JavaMailSender ArayÃ¼zÃ¼ ve Spring Boot Auto-Configuration Sihri</strong></p><p><strong>Ä°lk E-postamÄ±z: </strong><strong>SimpleMailMessage ile Basit Metin GÃ¶nderimi</strong></p><p><strong>UfuklarÄ± GeniÅŸletelim: </strong><strong>MimeMessage ile GeliÅŸmiÅŸ E-posta Ä°ÅŸlevleri</strong></p><ul><li>HTML Ä°Ã§erikli E-postalar GÃ¶nderme</li><li>Dosya Eki (Attachment) Ekleme</li><li>SatÄ±r Ä°Ã§i GÃ¶rseller (Inline Images) Kullanma</li></ul><p><strong>E-posta ÅablonlarÄ± ile Dinamik Ä°Ã§erikler: Thymeleaf Entegrasyonu</strong></p><p><strong>Asenkron E-posta GÃ¶nderimi: PerformansÄ± ArtÄ±rma (</strong><strong>@Async)</strong></p><p><strong>YapÄ±landÄ±rma ve GÃ¼venlik Ä°puÃ§larÄ±</strong></p><ul><li>Hassas Bilgilerin (Åifreler) GÃ¼venli YÃ¶netimi</li><li>Birden Fazla JavaMailSender YapÄ±landÄ±rmasÄ±</li></ul><p><strong>Test Stratejileri: E-postalarÄ± GerÃ§ekten GÃ¶ndermeden Test Etme</strong></p><p><strong>En Ä°yi Uygulamalar ve Ek Hususlar</strong></p><ul><li>Hata YÃ¶netimi ve Yeniden Deneme MekanizmalarÄ±</li><li>UluslararasÄ±laÅŸtÄ±rma (i18n)</li><li>Profesyonel E-posta Servisleri (SendGrid, Mailgun vb.) Ne Zaman DÃ¼ÅŸÃ¼nÃ¼lmeli?</li></ul><p><strong>SonuÃ§</strong></p><p>HazÄ±rsanÄ±z, Spring Boot ile e-posta gÃ¶ndermenin derinliklerine dalalÄ±m!</p><h3>1. Temel Kurulum ve BaÄŸÄ±mlÄ±lÄ±klar</h3><p>Her Spring Boot projesinde olduÄŸu gibi, iÅŸe pom.xml (Maven kullanÄ±yorsanÄ±z) veya build.gradle (Gradle kullanÄ±yorsanÄ±z) dosyamÄ±za gerekli baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekleyerek baÅŸlÄ±yoruz.</p><p><strong>Maven (</strong><strong>pom.xml):</strong></p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Bu â€œstarterâ€ paket, JavaMail APIâ€™sini ve Spring Frameworkâ€™Ã¼n e-posta gÃ¶nderimi iÃ§in sunduÄŸu soyutlama katmanlarÄ±nÄ± projenize dahil eder.</p><h3>2. application.properties ile YapÄ±landÄ±rma: SÄ±rlarÄ± ve Ä°ncelikleri</h3><p>Spring Boot, application.properties (veya application.yml) dosyasÄ±ndaki belirli anahtarlarÄ± okuyarak JavaMailSender&#39;Ä± otomatik olarak yapÄ±landÄ±rÄ±r.</p><p><strong>Gmail ile HÄ±zlÄ± BaÅŸlangÄ±Ã§:</strong></p><p>En yaygÄ±n kullanÄ±lan senaryolardan biri Gmail SMTP sunucusunu kullanmaktÄ±r.</p><ul><li><strong>AdÄ±m 2.1: Google HesabÄ±nÄ±zda Uygulama Åifresi OluÅŸturma (Ã‡OK Ã–NEMLÄ°!)</strong> Google, gÃ¼venlik nedeniyle standart hesap ÅŸifrenizin uygulamalar tarafÄ±ndan doÄŸrudan kullanÄ±lmasÄ±nÄ± kÄ±sÄ±tlar. Bu nedenle bir â€œUygulama Åifresiâ€ oluÅŸturmanÄ±z gerekir.</li></ul><ol><li><a href="https://myaccount.google.com/">Google HesabÄ±nÄ±za</a> gidin.</li><li>Sol menÃ¼den â€œGÃ¼venlikâ€ sekmesine tÄ±klayÄ±n.</li><li>â€œGoogleâ€™da oturum aÃ§maâ€ bÃ¶lÃ¼mÃ¼nde â€œ2 AdÄ±mlÄ± DoÄŸrulamaâ€nÄ±n <strong>etkin olduÄŸundan emin olun</strong>. DeÄŸilse, etkinleÅŸtirin.</li><li>2 AdÄ±mlÄ± DoÄŸrulama etkinse, aynÄ± bÃ¶lÃ¼mde â€œUygulama ÅŸifreleriâ€ seÃ§eneÄŸini gÃ¶receksiniz. (EÄŸer gÃ¶remiyorsanÄ±z, arama Ã§ubuÄŸuna â€œUygulama ÅŸifreleriâ€ yazÄ±n.)</li><li>â€œUygulama seÃ§inâ€ altÄ±nda â€œDiÄŸer (Ã–zel ad)â€ seÃ§eneÄŸini seÃ§in, uygulamanÄ±za bir isim verin (Ã¶rn: â€œSpringBootMailAppâ€) ve â€œOLUÅTURâ€ butonuna tÄ±klayÄ±n.</li><li>Google size 16 karakterlik bir uygulama ÅŸifresi verecektir. <strong>Bu ÅŸifreyi kopyalayÄ±n ve gÃ¼venli bir yere not edin.</strong> Bu pencereyi kapattÄ±ktan sonra tekrar gÃ¶remezsiniz.</li></ol><ul><li><strong>AdÄ±m 2.2: </strong><strong>application.properties DosyasÄ±nÄ± Ayarlama</strong> AÅŸaÄŸÄ±daki ayarlarÄ± src/main/resources/application.properties dosyanÄ±za ekleyin:</li></ul><pre>spring.mail.username=youremail@gmail.com # Gmail kullanÄ±cÄ± adÄ±nÄ±z (e-posta adresiniz) <br>spring.mail.password=BU_ALANA_KOPYALADIGINIZ_UYGULAMA_SIFRESINI_YAPISTIRIN <br># Gmail SMTP Sunucu AyarlarÄ± <br>spring.mail.host=smtp.gmail.com <br>spring.mail.port=587 # TLS iÃ§in Ã¶nerilen port <br># Ek JavaMail Ã–zellikleri <br>spring.mail.properties.mail.smtp.auth=true <br>spring.mail.properties.mail.smtp.starttls.enable=true <br># TLS&#39;yi etkinleÅŸtirir <br>spring.mail.properties.mail.smtp.starttls.required=true <br># TLS zorunlu <br>spring.mail.transport.protocol=smtp <br># KullanÄ±lacak protokol <br># Ä°steÄŸe BaÄŸlÄ±: Hata ayÄ±klama iÃ§in loglamayÄ± aÃ§ar (Ã¼retimde kapatÄ±n) <br>spring.mail.properties.mail.debug=true</pre><ul><li><strong>Ufuk AÃ§an Not:</strong> spring.mail.properties.* ile baÅŸlayan ayarlar, doÄŸrudan JavaMail API&#39;sine geÃ§irilen Ã¶zelliklerdir. Bu, Spring Boot&#39;un soyutlamasÄ±nÄ±n Ã¶tesinde, JavaMail&#39;in tÃ¼m gÃ¼cÃ¼nÃ¼ kullanabileceÄŸiniz anlamÄ±na gelir. Ã–rneÄŸin, baÄŸlantÄ± zaman aÅŸÄ±mÄ± (mail.smtp.connectiontimeout), yazma zaman aÅŸÄ±mÄ± (mail.smtp.writetimeout) gibi daha ince ayarlarÄ± buradan yapabilirsiniz.</li></ul><p><strong>DiÄŸer SMTP SaÄŸlayÄ±cÄ±larÄ± Ä°Ã§in Genel Ayarlar:</strong></p><p>EÄŸer Gmail dÄ±ÅŸÄ±nda bir SMTP sunucusu (Ã¶rneÄŸin, ÅŸirketinizin kendi sunucusu veya SendGrid, Mailgun gibi bir servis) kullanacaksanÄ±z, host, port, username, password ve properties ayarlarÄ±nÄ± saÄŸlayÄ±cÄ±nÄ±zÄ±n belgelerine gÃ¶re dÃ¼zenlemeniz yeterlidir.</p><h3>3. JavaMailSender ArayÃ¼zÃ¼ ve Spring Boot Auto-Configuration Sihri</h3><p>Spring Boot, yukarÄ±daki application.properties ayarlarÄ±nÄ± kullanarak otomatik olarak bir JavaMailSender bean&#39;i oluÅŸturur ve yÃ¶netir. Bu sayede, Ã§oÄŸu zaman sizin manuel bir JavaMailSender bean&#39;i tanÄ±mlamanÄ±za gerek kalmaz.</p><p>Ancak, kaynakta belirtilen @Configuration sÄ±nÄ±fÄ± ile manuel bean tanÄ±mÄ±:</p><pre>@Configuration<br>public class MailConfiguration {<br> @Bean<br> public JavaMailSender getJavaMailSender() {<br> JavaMailSenderImpl mailSender = new JavaMailSenderImpl();<br> mailSender.setHost(&quot;smtp.gmail.com&quot;);<br> // ... diÄŸer ayarlar<br> return mailSender;<br> }<br> }</pre><p>Bu yaklaÅŸÄ±m, eÄŸer application.properties dosyasÄ±nda zaten tÃ¼m ayarlarÄ± yaptÄ±ysanÄ±z <strong>genellikle gereksizdir</strong>. Spring Boot sizin iÃ§in bunu zaten yapar.</p><p><strong>Peki ne zaman manuel bean tanÄ±mÄ±na ihtiyaÃ§ duyulur?</strong></p><ul><li>Birden fazla, farklÄ± ayarlara sahip JavaMailSender bean&#39;ine ihtiyacÄ±nÄ±z varsa (Ã¶rn: biri Gmail, diÄŸeri baÅŸka bir SMTP iÃ§in).</li><li>JavaMailSenderImpl Ã¼zerinde application.properties ile ayarlanamayan Ã§ok Ã¶zel programatik yapÄ±landÄ±rmalar yapmak istiyorsanÄ±z.</li><li>Spring Bootâ€™un otomatik yapÄ±landÄ±rmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±p tam kontrol sahibi olmak istiyorsanÄ±z (spring.mail.host ayarÄ±nÄ± boÅŸ bÄ±rakmak otomatik yapÄ±landÄ±rmayÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir).</li></ul><p>Ã‡oÄŸu senaryoda, Spring Bootâ€™un otomatik yapÄ±landÄ±rmasÄ± yeterli ve tercih edilen yoldur.</p><h3>4. Ä°lk E-postamÄ±z: SimpleMailMessage ile Basit Metin GÃ¶nderimi</h3><p>Åimdi basit bir metin e-postasÄ± gÃ¶nderecek servisi oluÅŸturalÄ±m.</p><p><strong>MailSenderService.java:</strong></p><pre>package com.example.demo.mail; // Kendi paket yapÄ±nÄ±za gÃ¶re dÃ¼zenleyin<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.mail.SimpleMailMessage;<br>import org.springframework.mail.javamail.JavaMailSender;<br>import org.springframework.stereotype.Service;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // Spring Boot, application.properties&#39;teki ayarlara gÃ¶re<br> // JavaMailSender bean&#39;ini otomatik olarak enjekte edecektir.<br> // @Value(&quot;${spring.mail.username}&quot;) // GÃ¶nderici adresini properties&#39;ten almak iÃ§in<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> public void sendSimpleMail(String to, String subject, String body) {<br> SimpleMailMessage message = new SimpleMailMessage();<br> // message.setFrom(fromEmail); // GÃ¶nderici adresi (genellikle properties&#39;te ayarlanÄ±r ve otomatik kullanÄ±lÄ±r)<br> message.setTo(to);<br> message.setSubject(subject);<br> message.setText(body);<br> try {<br> mailSender.send(message);<br> System.out.println(&quot;Mail sent successfully to &quot; + to);<br> } catch (Exception e) {<br> System.err.println(&quot;Error while sending mail to &quot; + to + &quot;: &quot; + e.getMessage());<br> // Burada daha geliÅŸmiÅŸ hata yÃ¶netimi yapÄ±labilir (logging, retry vb.)<br> }<br> }<br>}</pre><pre><strong>Not:</strong> SimpleMailMessage sÄ±nÄ±fÄ±, adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± gibi sadece basit metin tabanlÄ± e-postalar iÃ§in uygundur. HTML, ek dosya veya satÄ±r iÃ§i gÃ¶rsel desteklemez.</pre><p><strong>E-postayÄ± Tetikleme (Ã–rnek bir Controller veya baÅŸka bir Servis):</strong></p><pre>package com.example.demo.controller; // Kendi paket yapÄ±nÄ±za gÃ¶re dÃ¼zenleyin<br>import com.example.demo.mail.MailSenderService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class MailController {<br> private final MailSenderService mailService;<br> @Autowired<br> public MailController(MailSenderService mailService) {<br> this.mailService = mailService;<br> }<br> @GetMapping(&quot;/send-test-email&quot;)<br> public String sendTestEmail(@RequestParam String to) {<br> mailService.sendSimpleMail(to, &quot;Spring Boot Test E-postasÄ±&quot;, &quot;Merhaba,\n\nBu Spring Boot uygulamasÄ±ndan gÃ¶nderilmiÅŸ bir test e-postasÄ±dÄ±r.&quot;);<br> return &quot;Test e-postasÄ± gÃ¶nderildi: &quot; + to;<br> }<br>}</pre><p>UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rÄ±p tarayÄ±cÄ±dan http://localhost:8080/send-test-email?to=alici_email@example.com adresine giderek test edebilirsiniz.</p><h3>5. UfuklarÄ± GeniÅŸletelim: MimeMessage ile GeliÅŸmiÅŸ E-posta Ä°ÅŸlevleri</h3><p>Daha zengin iÃ§erikli e-postalar iÃ§in JavaMailSender&#39;Ä±n createMimeMessage() metodunu ve MimeMessageHelper sÄ±nÄ±fÄ±nÄ± kullanÄ±rÄ±z.</p><p><strong>GeliÅŸmiÅŸ </strong><strong>MailSenderService.java:</strong></p><pre>// ... (Ã¶nceki importlar)<br>import org.springframework.mail.javamail.MimeMessageHelper;<br>import jakarta.mail.MessagingException; // javax.mail yerine jakarta.mail (Spring Boot 3+)<br>import jakarta.mail.internet.MimeMessage;<br>import org.springframework.core.io.FileSystemResource; // Dosya ekleri iÃ§in<br>import java.io.File;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // @Value(&quot;${spring.mail.username}&quot;)<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> // ... sendSimpleMail metodu ...<br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> // &#39;true&#39; parametresi multipart message oluÅŸturulacaÄŸÄ±nÄ± belirtir.<br> // Ä°kinci &#39;true&#39; ise UTF-8 encoding iÃ§in.<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(htmlBody, true); // &#39;true&#39; HTML iÃ§eriÄŸi olduÄŸunu belirtir.<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;HTML mail sent successfully to &quot; + to);<br> }<br> public void sendMailWithAttachment(String to, String subject, String body, String attachmentPath) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); // &#39;true&#39; for multipart message<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(body);<br> FileSystemResource file = new FileSystemResource(new File(attachmentPath));<br> if (file.exists()) {<br> helper.addAttachment(file.getFilename(), file); // Ä°kinci parametre dosya kaynaÄŸÄ±<br> System.out.println(&quot;Attachment added: &quot; + file.getFilename());<br> } else {<br> System.err.println(&quot;Attachment file not found: &quot; + attachmentPath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with attachment sent successfully to &quot; + to);<br> }<br> public void sendMailWithInlineImage(String to, String subject, String htmlBody, String imagePath, String imageContentId) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> // HTML iÃ§eriÄŸinde &lt;img src=&#39;cid:imageContentId&#39;&gt; ÅŸeklinde referans verilir.<br> helper.setText(htmlBody, true);<br> FileSystemResource res = new FileSystemResource(new File(imagePath));<br> if (res.exists()) {<br> // &#39;imageContentId&#39; HTML iÃ§indeki cid ile aynÄ± olmalÄ±<br> helper.addInline(imageContentId, res);<br> System.out.println(&quot;Inline image added: &quot; + imageContentId);<br> } else {<br> System.err.println(&quot;Inline image file not found: &quot; + imagePath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with inline image sent successfully to &quot; + to);<br> }<br>}</pre><ul><li><strong>Not (HTML):</strong> helper.setText(htmlBody, true); satÄ±rÄ±ndaki ikinci true parametresi, gÃ¶nderilen metnin HTML olarak yorumlanmasÄ±nÄ± saÄŸlar.</li><li><strong>Not (Ek):</strong> MimeMessageHelper(mimeMessage, true) constructor&#39;Ä±ndaki true parametresi, mesajÄ±n &quot;multipart&quot; olacaÄŸÄ±nÄ± belirtir, bu da ek dosya ve satÄ±r iÃ§i gÃ¶rseller iÃ§in gereklidir. addAttachment ile dosya adÄ± ve kaynaÄŸÄ±nÄ± belirtirsiniz.</li><li><strong>Not (SatÄ±r Ä°Ã§i GÃ¶rsel):</strong> addInline metodu kullanÄ±lÄ±r. HTML iÃ§inde &lt;img src=&#39;cid:myImageIdentifier&#39;&gt; ÅŸeklinde bir referans verilir ve addInline(&quot;myImageIdentifier&quot;, resource) Ã§aÄŸrÄ±sÄ±yla bu ID&#39;ye karÅŸÄ±lÄ±k gelen gÃ¶rsel eklenir. Bu, gÃ¶rselin e-postanÄ±n iÃ§ine gÃ¶mÃ¼lmesini saÄŸlar, kÄ±rÄ±k link sorununu azaltÄ±r. E-posta istemcisinin multipart/related iÃ§eriÄŸi desteklemesi gerekir.</li></ul><h3>6. E-posta ÅablonlarÄ± ile Dinamik Ä°Ã§erikler: Thymeleaf Entegrasyonu</h3><p>Sabit HTML stringâ€™leri yerine dinamik iÃ§erikler oluÅŸturmak iÃ§in Thymeleaf gibi bir ÅŸablon motoru kullanmak Ã§ok daha pratiktir.</p><ul><li><strong>AdÄ±m 6.1: Thymeleaf BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± Ekleme (</strong><strong>pom.xml)</strong></li></ul><pre>&lt;dependency&gt; <br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; <br>&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; <br>&lt;/dependency&gt;</pre><ul><li><strong>AdÄ±m 6.2: E-posta Åablonu OluÅŸturma (</strong><strong>src/main/resources/templates/email/my-template.html)</strong></li></ul><pre>&lt;!DOCTYPE html&gt; <br>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; <br>&lt;head&gt; <br>&lt;meta charset=&quot;UTF-8&quot;&gt; <br>&lt;title th:text=&quot;${subject}&quot;&gt;E-posta BaÅŸlÄ±ÄŸÄ±&lt;/title&gt; <br>&lt;style&gt; <br>body { font-family: Arial, sans-serif; } <br>.container { padding: 20px; border: 1px solid #ddd; } <br>&lt;/style&gt; <br>&lt;/head&gt; <br>&lt;body&gt; <br>&lt;div class=&quot;container&quot;&gt; <br>&lt;h1 th:text=&quot;${title}&quot;&gt;Merhaba!&lt;/h1&gt; <br>&lt;p&gt;Sevgili &lt;strong th:text=&quot;${name}&quot;&gt;KullanÄ±cÄ±&lt;/strong&gt;,&lt;/p&gt; <br>&lt;p th:text=&quot;${messageContent}&quot;&gt;Bu dinamik bir e-posta iÃ§eriÄŸidir.&lt;/p&gt; &lt;hr&gt; &lt;p&gt;TeÅŸekkÃ¼rler,&lt;br&gt;Spring Boot UygulamanÄ±z&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</pre><ul><li><strong>AdÄ±m 6.3: </strong><strong>MailSenderService&#39;i GÃ¼ncelleme</strong></li></ul><pre>// ... (Ã¶nceki importlar) <br>import org.thymeleaf.context.Context; <br>import org.thymeleaf.spring6.SpringTemplateEngine; <br>// Spring Boot 3 iÃ§in spring6 <br>@Service <br>public class MailSenderService { <br>private final JavaMailSender mailSender; <br>private final SpringTemplateEngine templateEngine; <br>Thymeleaf motorunu enjekte et <br>@Value(&quot;${spring.mail.username}&quot;) <br>private String fromEmail; <br>@Autowired <br>public MailSenderService(JavaMailSender mailSender, SpringTemplateEngine templateEngine) { <br> this.mailSender = mailSender; <br> this.templateEngine = templateEngine; <br>} <br>// ... diÄŸer metotlar ... <br>public void sendMailWithTemplate(String to, String subject, String templateName, Context context) throws MessagingException { <br> MimeMessage mimeMessage = mailSender.createMimeMessage(); <br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;); <br> // Thymeleaf context&#39;inden HTML iÃ§eriÄŸini iÅŸle <br> String htmlContent = templateEngine.process(&quot;email/&quot; + templateName, context); <br> // &quot;email/&quot; templates altÄ±ndaki klasÃ¶r <br> // helper.setFrom(fromEmail); <br> helper.setTo(to); <br> helper.setSubject(subject); <br> helper.setText(htmlContent, true); <br> mailSender.send(mimeMessage); <br> System.out.println(&quot;Templated mail sent successfully to &quot; + to); <br> } <br>}</pre><ul><li><strong>KullanÄ±mÄ±:</strong></li></ul><pre>// Bir controller veya baÅŸka bir serviste <br>// Context context = new Context(); <br>// context.setVariable(&quot;subject&quot;, &quot;Thymeleaf ile Merhaba!&quot;); <br>// context.setVariable(&quot;title&quot;, &quot;HoÅŸ Geldiniz!&quot;); <br>// context.setVariable(&quot;name&quot;, &quot;Ahmet YÄ±lmaz&quot;); <br>// context.setVariable(&quot;messageContent&quot;, &quot;Thymeleaf kullanarak dinamik bir e-posta gÃ¶nderdiniz.&quot;); <br>// mailService.sendMailWithTemplate(&quot;alici@example.com&quot;, &quot;Thymeleaf Test&quot;, &quot;my-template.html&quot;, context);</pre><ul><li><strong>Not:</strong> Context nesnesi, ÅŸablona geÃ§irilecek dinamik verileri iÃ§erir. templateEngine.process metodu, ÅŸablon adÄ±nÄ± ve context&#39;i alarak sonuÃ§ HTML&#39;i Ã¼retir. Bu yaklaÅŸÄ±m, e-posta iÃ§eriÄŸi ile sunumunu ayÄ±rarak bakÄ±mÄ± kolaylaÅŸtÄ±rÄ±r.</li></ul><h3>7. Asenkron E-posta GÃ¶nderimi: PerformansÄ± ArtÄ±rma (@Async)</h3><p>E-posta gÃ¶nderme iÅŸlemi, SMTP sunucusunun yanÄ±t verme sÃ¼resine baÄŸlÄ± olarak zaman alabilir. KullanÄ±cÄ± etkileÅŸimli bir iÅŸlem sÄ±rasÄ±nda (Ã¶rneÄŸin, kayÄ±t sonrasÄ± hoÅŸ geldin e-postasÄ±) senkron e-posta gÃ¶nderimi, kullanÄ±cÄ±ya yavaÅŸ bir deneyim sunabilir. @Async kullanarak e-posta gÃ¶nderimini arka planda Ã§alÄ±ÅŸacak ayrÄ± bir thread&#39;e devredebiliriz.</p><ul><li><strong>AdÄ±m 7.1: Asenkron DesteÄŸi EtkinleÅŸtirme</strong> Ana uygulama sÄ±nÄ±fÄ±nÄ±za veya bir @Configuration sÄ±nÄ±fÄ±na @EnableAsync ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.EnableAsync; <br>@SpringBootApplication <br>@EnableAsync // Asenkron metodlarÄ± etkinleÅŸtirir <br>public class DemoApplication { <br> public static void main(String[] args) { <br> SpringApplication.run(DemoApplication.class, args); <br> } <br>}</pre><ul><li><strong>AdÄ±m 7.2: Servis Metodunu </strong><strong>@Async ile Ä°ÅŸaretleme</strong> MailSenderService iÃ§indeki e-posta gÃ¶nderim metotlarÄ±nÄ±za @Async ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.Async; <br>// ... @Service <br>public class MailSenderService { <br>// ... @Async <br> // Bu metod asenkron Ã§alÄ±ÅŸacak <br> public void sendSimpleMail(String to, String subject, String body) { <br> // ... (iÃ§erik aynÄ±) } <br> @Async <br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException { <br> // ... (iÃ§erik aynÄ±) } <br> // DiÄŸer metotlar iÃ§in de @Async eklenebilir. <br>}</pre><ul><li><strong>Not:</strong> @Async metodlarÄ±n public olmasÄ± ve aynÄ± sÄ±nÄ±f iÃ§inden Ã§aÄŸrÄ±lmamasÄ± gerekir (proxy mekanizmasÄ± nedeniyle). EÄŸer aynÄ± sÄ±nÄ±f iÃ§inden Ã§aÄŸÄ±rmanÄ±z gerekiyorsa, kendinize enjekte ederek (self-injection) Ã§Ã¶zebilirsiniz veya e-posta gÃ¶nderimini ayrÄ± bir bean&#39;e taÅŸÄ±yabilirsiniz. AyrÄ±ca, @Async iÃ§in Ã¶zel bir TaskExecutor yapÄ±landÄ±rarak thread havuzu boyutunu vb. yÃ¶netebilirsiniz.</li></ul><pre> // TaskExecutor konfigÃ¼rasyonu (isteÄŸe baÄŸlÄ±) <br> import org.springframework.context.annotation.Bean; <br> import org.springframework.context.annotation.Configuration; <br> import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; <br> import java.util.concurrent.Executor; <br> <br> @Configuration <br> public class AsyncConfig { <br> @Bean(name = &quot;mailTaskExecutor&quot;) <br> public Executor mailTaskExecutor() { <br> ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); <br> executor.setCorePoolSize(5); <br>// AynÄ± anda Ã§alÄ±ÅŸacak min thread <br> executor.setMaxPoolSize(10); <br> Max thread <br> executor.setQueueCapacity(25); <br>// Kuyruk kapasitesi <br><br> executor.setThreadNamePrefix(&quot;MailAsync-&quot;); <br> executor.initialize(); <br> return executor; <br> } <br> } <br> @Async(&quot;mailTaskExecutor&quot;) <br> Belirli bir executor kullanmak iÃ§in</pre><h3>8. YapÄ±landÄ±rma ve GÃ¼venlik Ä°puÃ§larÄ±</h3><ul><li><strong>Hassas Bilgilerin GÃ¼venli YÃ¶netimi:</strong> spring.mail.password gibi hassas bilgileri doÄŸrudan application.properties dosyasÄ±na yazmak ve bunu Git gibi versiyon kontrol sistemlerine gÃ¶ndermek <strong>GÃœVENLÄ°K AÃ‡IÄIDIR.</strong></li><li><strong>Ã‡Ã¶zÃ¼m 1: Ortam DeÄŸiÅŸkenleri (Environment Variables):</strong> application.properties dosyasÄ±nda: spring.mail.password=${MAIL_APP_PASSWORD} UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±z ortamda MAIL_APP_PASSWORD adÄ±nda bir ortam deÄŸiÅŸkeni tanÄ±mlayÄ±n.</li><li><strong>Ã‡Ã¶zÃ¼m 2: Spring Cloud Config Server:</strong> Merkezi ve gÃ¼venli yapÄ±landÄ±rma yÃ¶netimi iÃ§in.</li><li><strong>Ã‡Ã¶zÃ¼m 3: HashiCorp Vault:</strong> SÄ±rlarÄ±n (secrets) gÃ¼venli depolanmasÄ± ve eriÅŸimi iÃ§in.</li><li><strong>Birden Fazla </strong><strong>JavaMailSender YapÄ±landÄ±rmasÄ±:</strong> FarklÄ± amaÃ§lar iÃ§in (Ã¶rn: iÅŸlem e-postalarÄ± iÃ§in bir SMTP, pazarlama iÃ§in baÅŸka bir SMTP) farklÄ± JavaMailSender bean&#39;leri tanÄ±mlayabilirsiniz. Bu durumda, her bir bean&#39;i @Primary ile varsayÄ±lan olarak iÅŸaretleyebilir veya @Qualifier ile belirli bir bean&#39;i enjekte edebilirsiniz.</li></ul><pre> @Configuration <br> public class MultipleMailConfig { <br> @Bean <br> @Primary <br> public JavaMailSender primaryMailSender() { <br> /* ... ayarlar ... */ <br> } <br> <br> @Bean <br> @Qualifier(&quot;marketingMailSender&quot;) <br> public JavaMailSender marketingMailSender() { <br> /* ... farklÄ± ayarlar ... */ <br> } <br> } <br> <br> <br>// KullanÄ±m <br> @Autowired <br> @Qualifier(&quot;marketingMailSender&quot;) <br> private JavaMailSender marketingSender;</pre><h3>9. Test Stratejileri: E-postalarÄ± GerÃ§ekten GÃ¶ndermeden Test Etme</h3><p>Entegrasyon testleri sÄ±rasÄ±nda sÃ¼rekli gerÃ§ek e-posta gÃ¶ndermek pratik deÄŸildir ve SMTP sunucunuzu gereksiz yere yorabilir.</p><ul><li><strong>Ã‡Ã¶zÃ¼m 1: Wiser (SubEthaSMTP Ã¼zerinden Spring Boot Test DesteÄŸi):</strong> Spring Boot, testler iÃ§in gÃ¶mÃ¼lÃ¼ bir SMTP sunucusu baÅŸlatmanÄ±za olanak tanÄ±r. spring-boot-starter-test ile birlikte gelir. application-test.properties dosyasÄ±na (genellikle src/test/resources altÄ±nda):</li></ul><pre>spring.mail.host=localhost spring.mail.port=2525 # Wiser iÃ§in varsayÄ±lan veya testte ayarlanan port spring.mail.username=testuser spring.mail.password=testpass spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.transport.protocol=smtp</pre><ul><li>Test sÄ±nÄ±fÄ±nÄ±zda:</li></ul><pre> import com.icegreen.greenmail.configuration.GreenMailConfiguration; <br> import com.icegreen.greenmail.junit5.GreenMailExtension; <br> import com.icegreen.greenmail.util.ServerSetupTest; <br> import jakarta.mail.internet.MimeMessage; <br> import org.junit.jupiter.api.Test; <br> import org.junit.jupiter.api.extension.RegisterExtension; <br> import org.springframework.beans.factory.annotation.Autowired; <br> import org.springframework.boot.test.context.SpringBootTest; <br> import static org.assertj.core.api.Assertions.assertThat; <br> <br> @SpringBootTest <br> public class MailServiceIntegrationTest { <br> <br> @RegisterExtension <br>// JUnit 5 iÃ§in <br> static GreenMailExtension greenMail = new GreenMailExtension(ServerSetupTest.SMTP) <br> .withConfiguration(GreenMailConfiguration.aConfig().withUser(&quot;testuser&quot;, &quot;testpass&quot;)) <br> .withPerMethodLifecycle(false); // TÃ¼m test metotlarÄ± iÃ§in tek bir GreenMail instance <br> <br> @Autowired <br> private MailSenderService mailService; <br> <br> @Test <br> void testSendSimpleMail() throws Exception { <br> String to = &quot;recipient@example.com&quot;; <br> String subject = &quot;Test Subject&quot;; <br> String body = &quot;Test Body&quot;; <br> <br> mailService.sendSimpleMail(to, subject, body); <br> <br> MimeMessage[] receivedMessages = greenMail.getReceivedMessages(); <br> assertThat(receivedMessages.length).isEqualTo(1); <br> MimeMessage receivedMessage = receivedMessages[0]; <br> assertThat(receivedMessage.getSubject()).isEqualTo(subject); <br> assertThat(receivedMessage.getAllRecipients()[0].toString()).isEqualTo(to); <br> <br>// Ä°Ã§eriÄŸi de kontrol edebilirsiniz. <br> } <br> }</pre><ul><li><em>GreenMail gibi kÃ¼tÃ¼phaneler (Wiser da SubEthaSMTPâ€™yi temel alÄ±r) gelen e-postalarÄ± yakalayÄ±p iÃ§eriÄŸini doÄŸrulamanÄ±zÄ± saÄŸlar.</em></li><li><strong>Ã‡Ã¶zÃ¼m 2: Mocking </strong><strong>JavaMailSender:</strong> Birim testlerinde JavaMailSender&#39;Ä± mocklayarak send() metodunun Ã§aÄŸrÄ±lÄ±p Ã§aÄŸrÄ±lmadÄ±ÄŸÄ±nÄ± ve doÄŸru parametrelerle Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nÄ± doÄŸrulayabilirsiniz.</li></ul><h3>10. En Ä°yi Uygulamalar ve Ek Hususlar</h3><ul><li><strong>Logging:</strong> E-posta gÃ¶nderim baÅŸarÄ±larÄ±nÄ± ve hatalarÄ±nÄ± detaylÄ± loglayÄ±n.</li><li><strong>Hata YÃ¶netimi ve Yeniden Deneme:</strong> GeÃ§ici SMTP hatalarÄ± (baÄŸlantÄ± sorunlarÄ± vb.) iÃ§in Spring Retry gibi mekanizmalarla yeniden deneme stratejileri uygulayabilirsiniz.</li><li><strong>UluslararasÄ±laÅŸtÄ±rma (i18n):</strong> E-posta iÃ§eriklerini ve baÅŸlÄ±klarÄ±nÄ± farklÄ± dillerde sunmak iÃ§in Springâ€™in i18n desteÄŸini (ResourceBundleMessageSource) Thymeleaf ile birlikte kullanÄ±n.</li><li><strong>Abonelikten Ã‡Ä±kma (Unsubscribe) Linkleri:</strong> Ã–zellikle pazarlama e-postalarÄ± iÃ§in yasal bir zorunluluktur ve kullanÄ±cÄ± deneyimi iÃ§in Ã¶nemlidir.</li><li><strong>Rate Limiting:</strong> SMTP sunucularÄ±nÄ±n genellikle gÃ¶nderim limitleri vardÄ±r. Toplu e-posta gÃ¶nderimlerinde bu limitlere dikkat edin.</li><li><strong>Profesyonel E-posta Servisleri (SendGrid, Amazon SES, Mailgun vb.):</strong> YÃ¼ksek hacimli e-posta gÃ¶nderimi, geliÅŸmiÅŸ analizler, teslim edilebilirlik (deliverability) takibi, IP itibarÄ± yÃ¶netimi gibi ihtiyaÃ§larÄ±nÄ±z varsa, bu tÃ¼r harici servisleri kullanmayÄ± dÃ¼ÅŸÃ¼nÃ¼n. Genellikle kendi APIâ€™leri ve Spring Boot entegrasyon kÃ¼tÃ¼phaneleri bulunur.</li></ul><h3>11. SonuÃ§</h3><p>Spring Boot ile e-posta gÃ¶ndermek, spring-boot-starter-mail sayesinde oldukÃ§a kolaylaÅŸmÄ±ÅŸtÄ±r. Ancak, bu rehberde gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, basit bir metin e-postasÄ±ndan Ã§ok daha fazlasÄ±nÄ± yapabiliriz. HTML iÃ§erikler, ekler, ÅŸablonlar, asenkron gÃ¶nderim ve doÄŸru test stratejileri ile uygulamalarÄ±nÄ±zda profesyonel ve etkili bir e-posta iletiÅŸim altyapÄ±sÄ± kurabilirsiniz.</p><p>UnutmayÄ±n, e-posta gÃ¶nderimi sadece teknik bir iÅŸlem deÄŸil, aynÄ± zamanda kullanÄ±cÄ± deneyiminin ve uygulamanÄ±zÄ±n imajÄ±nÄ±n Ã¶nemli bir parÃ§asÄ±dÄ±r. Bu nedenle, bu sÃ¼reÃ§lere Ã¶zen gÃ¶stermek ve en iyi uygulamalarÄ± takip etmek, projenizin baÅŸarÄ±sÄ±na katkÄ± saÄŸlayacaktÄ±r.</p><p>UmarÄ±m bu kapsamlÄ± rehber, Spring Boot ile e-posta gÃ¶nderimi konusunda ufkunuzu aÃ§mÄ±ÅŸ ve size deÄŸerli bilgiler sunmuÅŸtur. Yorumlarda sorularÄ±nÄ±zÄ± ve deneyimlerinizi paylaÅŸmaktan Ã§ekinmeyin!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d6715e02cefa" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Reaktif Programlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-reaktif-programlamaya-ad%C4%B1m-ad%C4%B1m-yeni-ba%C5%9Flayanlar-i%CC%87%C3%A7in-kapsaml%C4%B1-bir-rehber-ve-5815c96be738?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/5815c96be738</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 05:03:44 GMT</pubDate>
<atom:updated>2025-05-09T06:15:07.786Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vOd2FBimvVRwHFflS44SNg.png" /></figure><p>GÃ¼nÃ¼mÃ¼zÃ¼n yÃ¼ksek trafikli ve anlÄ±k veri akÄ±ÅŸÄ± gerektiren uygulamalarÄ±nda performans ve Ã¶lÃ§eklenebilirlik hayati Ã¶nem taÅŸÄ±yor. Ä°ÅŸte tam da bu noktada <strong>Reaktif Programlama</strong> devreye giriyor. Spring Bootâ€™un <strong>Spring WebFlux</strong> ile sunduÄŸu mÃ¼kemmel destek sayesinde, geliÅŸtiriciler olarak engellemeyen (non-blocking), olay gÃ¼dÃ¼mlÃ¼ (event-driven) uygulamalar geliÅŸtirebiliyoruz.</p><p>Bu yazÄ±da, Spring Boot kullanarak reaktif programlamanÄ±n temellerini adÄ±m adÄ±m keÅŸfedecek, pratik Ã¶rneklerle pekiÅŸtirecek ve bu dÃ¼nyaya ilk adÄ±mÄ±nÄ± atanlar iÃ§in Ã¶nemli ipuÃ§larÄ± ve â€œince triklerâ€ paylaÅŸacaÄŸÄ±m. Hadi, baÅŸlayalÄ±m!</p><h3>1. Reaktif Programlama Nedir? Neden Gerekli?</h3><p>En basit tanÄ±mÄ±yla reaktif programlama, <strong>asenkron veri akÄ±ÅŸlarÄ±</strong> ve <strong>olay gÃ¼dÃ¼mlÃ¼ mimari</strong> Ã¼zerine kurulu bir programlama paradigmasÄ±dÄ±r. Geleneksel (imperative) programlamada bir iÅŸlem bitmeden diÄŸerine geÃ§emezken (blocking), reaktif yaklaÅŸÄ±mda iÅŸlemler birbirini beklemez. Bu sayede, Ã¶zellikle I/O (Input/Output) iÅŸlemleri gibi zaman alÄ±cÄ± operasyonlarda kaynaklarÄ±mÄ±zÄ± Ã§ok daha verimli kullanÄ±rÄ±z.</p><p><strong>Peki, bu ne anlama geliyor?</strong></p><p>DÃ¼ÅŸÃ¼nÃ¼n ki bir restoranda tek bir garson var ve her sipariÅŸi alÄ±p, mutfaÄŸa iletip, yemek piÅŸtikten sonra servis edip, ancak ondan sonra yeni bir sipariÅŸ alabiliyor. Bu, geleneksel programlamadaki â€œblockingâ€ mantÄ±ÄŸÄ±na benzer. Reaktif programlamada ise garson sipariÅŸi alÄ±r almaz mutfaÄŸa iletir ve hemen bir sonraki mÃ¼ÅŸteriden sipariÅŸ almaya devam eder. Mutfak yemeÄŸi hazÄ±rladÄ±ÄŸÄ±nda garsona haber verir ve garson da servisi yapar. Bu sayede Ã§ok daha fazla mÃ¼ÅŸteriye aynÄ± anda hizmet verilebilir.</p><p><strong>Reaktif ProgramlamanÄ±n Anahtar KavramlarÄ±:</strong></p><ul><li><strong>Reactive Streams:</strong> Asenkron veri iÅŸlemeyi â€œbackpressureâ€ (geri basÄ±nÃ§) ile yÃ¶netmek iÃ§in bir ÅŸartnamedir.</li><li><strong>Backpressure</strong>, <em>yayÄ±ncÄ±nÄ±n (Publisher) tÃ¼keticiyi (Subscriber) veriyle boÄŸmasÄ±nÄ± engeller. TÃ¼ketici, ne kadar veri alabileceÄŸini yayÄ±ncÄ±ya bildirir. Bu, sistemin Ã§Ã¶kmesini Ã¶nleyen kritik bir mekanizmadÄ±r.</em></li><li><strong>Publisher (YayÄ±ncÄ±):</strong> Bir veri akÄ±ÅŸÄ± yayar. (Ã–rn: VeritabanÄ±ndan gelen kullanÄ±cÄ± listesi)</li><li><strong>Subscriber (Abone):</strong> Publisher tarafÄ±ndan yayÄ±lan akÄ±ÅŸÄ± tÃ¼ketir. (Ã–rn: KullanÄ±cÄ± listesini alÄ±p iÅŸleyen bir servis)</li><li><strong>Subscription (Abonelik):</strong> Publisher ve Subscriber arasÄ±ndaki etkileÅŸimi yÃ¶netir. Subscriberâ€™Ä±n ne kadar veri talep ettiÄŸini ve aboneliÄŸi iptal etme gibi iÅŸlemleri kontrol eder.</li><li><strong>Processor (Ä°ÅŸlemci):</strong> Hem Publisher hem de Subscriber Ã¶zelliklerini taÅŸÄ±r. Veriyi alÄ±p, iÅŸleyip, farklÄ± bir formatta tekrar yayÄ±nlayabilir.</li></ul><h3>2. Reaktif Spring Boot Projesi Kurulumu: Ä°lk AdÄ±mlar</h3><p>Spring Boot ile reaktif programlamaya baÅŸlamak iÃ§in projemize bazÄ± temel baÄŸÄ±mlÄ±lÄ±klarÄ± eklememiz gerekiyor.</p><p><strong>AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± </strong><strong>pom.xml DosyasÄ±na Ekleyelim</strong></p><p>EÄŸer bir Maven projesi kullanÄ±yorsanÄ±z, pom.xml dosyanÄ±za aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br> &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br> &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br> &lt;optional&gt;true&lt;/optional&gt;<br> &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><ul><li><em>spring-boot-starter-webflux baÄŸÄ±mlÄ±lÄ±ÄŸÄ±, Netty gibi gÃ¶mÃ¼lÃ¼ reaktif sunucularÄ± ve reaktif HTTP istemcisi olan </em><em>WebClient&#39;Ä± projenize dahil eder. Geleneksel Spring MVC&#39;deki </em><em>spring-boot-starter-web ile aynÄ± anda kullanÄ±lmamalÄ±dÄ±r, Ã§Ã¼nkÃ¼ farklÄ± iÅŸ parÃ§acÄ±ÄŸÄ± modellerine dayanÄ±rlar.</em></li></ul><h3>3. Reaktif Veri Tipleri: Mono ve Flux ile TanÄ±ÅŸma</h3><p>Spring WebFlux, Project Reactor kÃ¼tÃ¼phanesini temel alÄ±r ve iki ana reaktif veri tipi sunar: Mono ve Flux.</p><ul><li><strong>Mono&lt;T&gt;:</strong> <strong>0 ya da 1</strong> eleman iÃ§eren bir akÄ±ÅŸÄ± temsil eder. Genellikle tek bir nesne dÃ¶ndÃ¼receÄŸiniz (Ã¶rneÄŸin, ID ile bir kullanÄ±cÄ± getirme) veya bir iÅŸlemin tamamlandÄ±ÄŸÄ±nÄ± (void) belirten durumlarda kullanÄ±lÄ±r.</li><li><strong><em>Ã–rnek:</em> </strong>Mono&lt;User&gt; (bir kullanÄ±cÄ±), Mono&lt;Void&gt; (bir iÅŸlem tamamlandÄ±).</li><li><strong>Flux&lt;T&gt;:</strong> <strong>0&#39;dan N&#39;e kadar</strong> (yani birden fazla) eleman iÃ§eren bir akÄ±ÅŸÄ± temsil eder. Veri akÄ±ÅŸlarÄ±, listeler veya sonsuz akÄ±ÅŸlar iÃ§in idealdir.</li><li><strong><em>Ã–rnek:</em> </strong>Flux&lt;Product&gt; (tÃ¼m Ã¼rÃ¼nler), Flux&lt;String&gt; (bir olay akÄ±ÅŸÄ±).</li></ul><p><strong>Mono ve </strong><strong>Flux Ã–rneÄŸi:</strong></p><pre>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>public class ReactiveExample {<br> public static void main(String[] args) {<br> // Tek bir deÄŸer iÃ§eren Mono<br> Mono&lt;String&gt; monoExample = Mono.just(&quot;Merhaba Reaktif DÃ¼nya!&quot;)<br> .log(); // AkÄ±ÅŸtaki olaylarÄ± gÃ¶rmek iÃ§in log() ekleyebiliriz.<br> // Mono&#39;ya abone olunduÄŸunda veri iÅŸlenir.<br> monoExample.subscribe(<br> data -&gt; System.out.println(&quot;Mono&#39;dan gelen: &quot; + data), // onNext: Veri geldiÄŸinde<br> error -&gt; System.err.println(&quot;Mono&#39;da hata: &quot; + error), // onError: Hata oluÅŸtuÄŸunda<br> () -&gt; System.out.println(&quot;Mono tamamlandÄ±!&quot;) // onComplete: AkÄ±ÅŸ bittiÄŸinde<br> );<br> System.out.println(&quot;---&quot;); // Ã‡Ä±ktÄ±larÄ± ayÄ±rmak iÃ§in<br> // Birden fazla deÄŸer iÃ§eren Flux<br> Flux&lt;String&gt; fluxExample = Flux.just(&quot;Elma&quot;, &quot;Armut&quot;, &quot;Ã‡ilek&quot;, &quot;Muz&quot;)<br> .map(String::toUpperCase) // Her elemanÄ± bÃ¼yÃ¼k harfe Ã§evir<br> .log(); // AkÄ±ÅŸtaki olaylarÄ± gÃ¶rmek iÃ§in<br> // Flux&#39;a abone olunduÄŸunda veri akÄ±ÅŸÄ± baÅŸlar.<br> fluxExample.subscribe(<br> data -&gt; System.out.println(&quot;Flux&#39;tan gelen: &quot; + data),<br> error -&gt; System.err.println(&quot;Flux&#39;ta hata: &quot; + error),<br> () -&gt; System.out.println(&quot;Flux tamamlandÄ±!&quot;)<br> );<br> }<br>}</pre><ul><li><em>Mono ve </em><em>Flux &quot;tembel&quot; (lazy) yapÄ±dadÄ±r. Yani, onlara </em><em>subscribe() metoduyla abone olunana kadar hiÃ§bir iÅŸlem yapmazlar. </em><em>subscribe() Ã§aÄŸrÄ±sÄ±, veri akÄ±ÅŸÄ±nÄ± tetikler. Bu, reaktif programlamaya yeni baÅŸlayanlarÄ±n sÄ±kÃ§a gÃ¶zden kaÃ§Ä±rdÄ±ÄŸÄ± bir noktadÄ±r. EÄŸer </em><em>subscribe() yapmazsanÄ±z, </em><em>map, </em><em>filter gibi operatÃ¶rleriniz Ã§alÄ±ÅŸmayacaktÄ±r!</em></li><li><em>.log() operatÃ¶rÃ¼, akÄ±ÅŸÄ±n iÃ§indeki olaylarÄ± (istek, yayÄ±nlama, tamamlama, iptal vb.) konsola yazdÄ±rmak iÃ§in geliÅŸtirme aÅŸamasÄ±nda Ã§ok faydalÄ±dÄ±r.</em></li></ul><h3>4. Reaktif Bir REST API Ä°nÅŸa Edelim: CRUD Ã–rneÄŸi</h3><p>Åimdi Spring WebFlux ve Reaktif MongoDB kullanarak basit bir ÃœrÃ¼n (Product) yÃ¶netimi iÃ§in CRUD (Create, Read, Update, Delete) APIâ€™si oluÅŸturalÄ±m.</p><p><strong>AdÄ±m 1: Entity SÄ±nÄ±fÄ±nÄ± TanÄ±mlayalÄ±m (</strong><strong>Product.java)</strong></p><p>MongoDBâ€™deki products koleksiyonumuza karÅŸÄ±lÄ±k gelecek bir model sÄ±nÄ±fÄ± oluÅŸturalÄ±m.</p><pre>import lombok.Data; // Getter, Setter, toString vb. iÃ§in<br>import lombok.AllArgsConstructor;<br>import lombok.NoArgsConstructor;<br>import org.springframework.data.annotation.Id;<br>import org.springframework.data.mongodb.core.mapping.Document;<br>@Data // Lombok: Getter, Setter, equals, hashCode, toString metodlarÄ±nÄ± otomatik oluÅŸturur.<br>@NoArgsConstructor // Lombok: ArgÃ¼mansÄ±z constructor oluÅŸturur.<br>@AllArgsConstructor // Lombok: TÃ¼m argÃ¼manlarÄ± iÃ§eren constructor oluÅŸturur.<br>@Document(collection = &quot;products&quot;) // Bu sÄ±nÄ±fÄ±n MongoDB&#39;de &#39;products&#39; adlÄ± bir koleksiyona karÅŸÄ±lÄ±k geldiÄŸini belirtir.<br>public class Product {<br> @Id // Bu alanÄ±n MongoDB&#39;deki _id alanÄ± olduÄŸunu belirtir.<br> private String id;<br> private String name;<br> private double price;<br> // Reaktif programlamada entity&#39;ler genellikle deÄŸiÅŸmez (immutable) olarak tasarlanÄ±r,<br> // ancak bu Ã¶rnekte basitlik iÃ§in Lombok @Data kullandÄ±k.<br>}</pre><p><strong>AdÄ±m 2: Reaktif Repository OluÅŸturalÄ±m (</strong><strong>ProductRepository.java)</strong></p><p>Spring Data, ReactiveMongoRepository arayÃ¼zÃ¼ ile MongoDB iÃ§in engellemeyen operasyonlarÄ± destekler.</p><pre>import org.springframework.data.mongodb.repository.ReactiveMongoRepository;<br>import reactor.core.publisher.Flux; <br>import org.springframework.stereotype.Repository;<br>@Repository // Bu arayÃ¼zÃ¼n bir Spring bileÅŸeni (repository) olduÄŸunu belirtir.<br>public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {<br> // ReactiveMongoRepository bize temel CRUD operasyonlarÄ±nÄ± (findAll, findById, save, deleteById vb.)<br> // Mono ve Flux dÃ¶necek ÅŸekilde hazÄ±r olarak sunar.<br> // Ä°htiyaÃ§ duyarsak Ã¶zel sorgu metotlarÄ± da tanÄ±mlayabiliriz.<br> // Spring Data, metot isminden sorguyu otomatik tÃ¼retir.<br> Flux&lt;Product&gt; findByName(String name); // Ä°sme gÃ¶re Ã¼rÃ¼nleri reaktif olarak getirir.<br>}</pre><ul><li><em>ReactiveMongoRepository&lt;Product, String&gt; ifadesindeki </em><em>Product entity tipini, </em><em>String ise </em><em>@Id ile iÅŸaretlediÄŸimiz alanÄ±n tipini (yani </em><em>id alanÄ±nÄ±n tipi) temsil eder.</em></li></ul><p><strong>AdÄ±m 3: Reaktif Servis KatmanÄ±nÄ± OluÅŸturalÄ±m (</strong><strong>ProductService.java)</strong></p><p>Ä°ÅŸ mantÄ±ÄŸÄ±mÄ±zÄ± yÃ¶neteceÄŸimiz servis sÄ±nÄ±fÄ±nÄ± oluÅŸturalÄ±m.</p><pre>import org.springframework.stereotype.Service;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired; // Alternatif olarak constructor injection<br>@Service // Bu sÄ±nÄ±fÄ±n bir Spring bileÅŸeni (servis) olduÄŸunu belirtir.<br>public class ProductService {<br> private final ProductRepository productRepository;<br> // BaÄŸÄ±mlÄ±lÄ±klarÄ± constructor Ã¼zerinden enjekte etmek best practice&#39;dir.<br> @Autowired // Spring 4.3 ve sonrasÄ± iÃ§in constructor injection&#39;da @Autowired zorunlu deÄŸil,<br> // eÄŸer sÄ±nÄ±fta tek bir constructor varsa.<br> public ProductService(ProductRepository productRepository) {<br> this.productRepository = productRepository;<br> }<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productRepository.findAll();<br> }<br> public Mono&lt;Product&gt; getProductById(String id) {<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;ÃœrÃ¼n bulunamadÄ±: &quot; + id))); // ÃœrÃ¼n yoksa Ã¶zel hata fÄ±rlat<br> }<br> public Mono&lt;Product&gt; createProduct(Product product) {<br> // Gelen Ã¼rÃ¼nÃ¼n ID&#39;si varsa (gÃ¼ncelleme gibi), bunu engellemek veya farklÄ± yÃ¶netmek isteyebilirsiniz.<br> // Bu Ã¶rnekte basitÃ§e save() Ã§aÄŸÄ±rÄ±yoruz. MongoDB yeni bir ID atayacaktÄ±r eÄŸer null ise.<br> return productRepository.save(product);<br> }<br> public Mono&lt;Product&gt; updateProduct(String id, Product product) {<br> return productRepository.findById(id)<br> .flatMap(existingProduct -&gt; { // flatMap, Mono&lt;Mono&lt;Product&gt;&gt; yerine Mono&lt;Product&gt; dÃ¶nmek iÃ§in kullanÄ±lÄ±r.<br> existingProduct.setName(product.getName());<br> existingProduct.setPrice(product.getPrice());<br> return productRepository.save(existingProduct);<br> })<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;GÃ¼ncellenecek Ã¼rÃ¼n bulunamadÄ±: &quot; + id)));<br> }<br> public Mono&lt;Void&gt; deleteProduct(String id) {<br> // Ã–nce var olup olmadÄ±ÄŸÄ±nÄ± kontrol edip sonra silmek daha gÃ¼venli olabilir.<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Silinecek Ã¼rÃ¼n bulunamadÄ±: &quot; + id)))<br> .flatMap(productRepository::delete); // product -&gt; productRepository.delete(product) ile aynÄ±.<br> // deleteById de kullanÄ±labilir: productRepository.deleteById(id)<br> }<br>}<br>// Basit bir custom exception sÄ±nÄ±fÄ±<br>class ProductNotFoundException extends RuntimeException {<br> public ProductNotFoundException(String message) {<br> super(message);<br> }<br>}</pre><ul><li><em>switchIfEmpty() operatÃ¶rÃ¼, bir </em><em>Mono veya </em><em>Flux boÅŸ geldiÄŸinde (yani hiÃ§ eleman yayÄ±nlamadÄ±ÄŸÄ±nda) alternatif bir </em><em>Mono veya </em><em>Flux saÄŸlamak ya. da bir hata fÄ±rlatmak iÃ§in kullanÄ±lÄ±r. </em><em>getProductById Ã¶rneÄŸinde, Ã¼rÃ¼n bulunamazsa </em><em>ProductNotFoundException fÄ±rlatÄ±yoruz.</em></li><li><em>flatMap() operatÃ¶rÃ¼, bir </em><em>Mono veya </em><em>Flux iÃ§indeki elemanÄ± alÄ±p, bu elemanla baÅŸka bir asenkron iÅŸlem (baÅŸka bir </em><em>Mono veya </em><em>Flux dÃ¶ndÃ¼ren) yapmak istediÄŸinizde kullanÄ±lÄ±r. Sonucu &quot;dÃ¼zleÅŸtirir&quot;. EÄŸer </em><em>map() kullansaydÄ±k </em><em>Mono&lt;Mono&lt;Product&gt;&gt; gibi bir sonuÃ§ alÄ±rdÄ±k, </em><em>flatMap ise bunu </em><em>Mono&lt;Product&gt;&#39;a Ã§evirir.</em></li></ul><p><strong>AdÄ±m 4: Reaktif REST Controller OluÅŸturalÄ±m (</strong><strong>ProductController.java)</strong></p><p>API endpointâ€™lerimizi dÄ±ÅŸ dÃ¼nyaya aÃ§acaÄŸÄ±mÄ±z controller sÄ±nÄ±fÄ±nÄ± yazalÄ±m.</p><pre>import org.springframework.web.bind.annotation.*;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.http.HttpStatus;<br>import org.springframework.http.ResponseEntity; // ResponseEntity ile daha detaylÄ± yanÄ±tlar<br>@RestController // Bu sÄ±nÄ±fÄ±n bir RESTful controller olduÄŸunu belirtir.<br> // Gelen istekleri iÅŸler ve HTTP yanÄ±tlarÄ± dÃ¶ner.<br>@RequestMapping(&quot;/api/v1/products&quot;) // Bu controller&#39;daki tÃ¼m endpoint&#39;ler &quot;/api/v1/products&quot; altÄ±nda olacak.<br>public class ProductController {<br> private final ProductService productService;<br> @Autowired<br> public ProductController(ProductService productService) {<br> this.productService = productService;<br> }<br> @GetMapping<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productService.getAllProducts();<br> }<br> @GetMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {<br> return productService.getProductById(id)<br> .map(ResponseEntity::ok) // Product -&gt; ResponseEntity.ok(product)<br> .defaultIfEmpty(ResponseEntity.notFound().build()); // Mono boÅŸsa 404 Not Found<br> }<br> @PostMapping<br> @ResponseStatus(HttpStatus.CREATED) // BaÅŸarÄ±lÄ± POST isteÄŸi iÃ§in 201 Created durumu dÃ¶ner.<br> public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {<br> // @RequestBody: Gelen JSON verisini Product nesnesine mapler.<br> return productService.createProduct(product);<br> }<br> @PutMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(@PathVariable String id, @RequestBody Product product) {<br> return productService.updateProduct(id, product)<br> .map(ResponseEntity::ok)<br> .defaultIfEmpty(ResponseEntity.notFound().build());<br> }<br> @DeleteMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteProduct(@PathVariable String id) {<br> return productService.deleteProduct(id)<br> .map(ResponseEntity.noContent()::build) // BaÅŸarÄ±lÄ± silme sonrasÄ± 204 No Content<br> .onErrorResume(ProductNotFoundException.class, e -&gt; Mono.just(ResponseEntity.notFound().build())); // ÃœrÃ¼n yoksa 404<br> }<br> // Hata yÃ¶netimi iÃ§in merkezi bir @ExceptionHandler da eklenebilir.<br> @ExceptionHandler(ProductNotFoundException.class)<br> public ResponseEntity&lt;String&gt; handleProductNotFound(ProductNotFoundException ex) {<br> return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());<br> }<br>}</pre><ul><li><em>Controller metotlarÄ±mÄ±z artÄ±k </em><em>Mono&lt;Product&gt;, </em><em>Flux&lt;Product&gt; veya </em><em>Mono&lt;ResponseEntity&lt;T&gt;&gt; gibi reaktif tipler dÃ¶nÃ¼yor. Spring WebFlux, bu reaktif tiplere abone olup, sonuÃ§lar geldikÃ§e HTTP yanÄ±tÄ±nÄ± asenkron olarak yazar.</em></li><li><em>@ResponseStatus(HttpStatus.CREATED) gibi anotasyonlarla veya </em><em>ResponseEntity kullanarak HTTP durum kodlarÄ±nÄ± daha detaylÄ± yÃ¶netebilirsiniz. </em><em>defaultIfEmpty ve </em><em>onErrorResume gibi operatÃ¶rler, controller seviyesinde de hata durumlarÄ±nÄ± ve boÅŸ sonuÃ§larÄ± yÃ¶netmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.</em></li></ul><h3>5. Reaktif APIâ€™mizi Test Edelim</h3><p>APIâ€™nizi test etmek iÃ§in Postman, Insomnia gibi araÃ§larÄ± veya cURL komut satÄ±rÄ± aracÄ±nÄ± kullanabilirsiniz. Spring Boot uygulamanÄ±z varsayÄ±lan olarak 8080 portunda Ã§alÄ±ÅŸacaktÄ±r.</p><p><strong>Yeni Bir ÃœrÃ¼n OluÅŸturma (POST):</strong></p><pre>curl -X POST http://localhost:8080/api/v1/products \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;AkÄ±llÄ± Saat&quot;,&quot;price&quot;:2500.75}&#39;</pre><p><strong>TÃ¼m ÃœrÃ¼nleri Getirme (GET):</strong></p><pre>curl -X GET http://localhost:8080/api/v1/products</pre><p><em>Bu komut, bir JSON dizisi olarak Ã¼rÃ¼nleri listeler. EÄŸer </em><em>text/event-stream olarak isterseniz, sunucu tarafÄ±nda bunu desteklemeniz gerekir ve istemci de buna gÃ¶re istek yapmalÄ±dÄ±r.</em></p><p><strong>ID ile ÃœrÃ¼n Getirme (GET):</strong> Ã–nce bir Ã¼rÃ¼n oluÅŸturup IDâ€™sini alÄ±n, sonra o ID ile sorgulayÄ±n.</p><pre># ID&#39;yi bir Ã¶nceki POST isteÄŸinin yanÄ±tÄ±ndan veya GET All Products&#39;tan alÄ±n<br>curl -X GET http://localhost:8080/api/v1/products/{id}</pre><p><strong>ÃœrÃ¼n GÃ¼ncelleme (PUT):</strong></p><pre>curl -X PUT http://localhost:8080/api/v1/products/{id} \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Yeni AkÄ±llÄ± Saat Model X&quot;,&quot;price&quot;:2750.00}&#39;</pre><p><strong>ÃœrÃ¼n Silme (DELETE):</strong></p><pre>curl -X DELETE http://localhost:8080/api/v1/products/{id}</pre><ul><li><em>Spring WebFlux ile </em><em>WebClient kullanarak reaktif API&#39;lerinizi programatik olarak test edebilirsiniz. Bu, Ã¶zellikle entegrasyon testleri yazarken Ã§ok kullanÄ±ÅŸlÄ±dÄ±r.</em></li></ul><pre>// Ã–rnek WebClient kullanÄ±mÄ± (test sÄ±nÄ±fÄ± iÃ§inde)<br>// @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br>// class ProductControllerIntegrationTests {<br>//<br>// @Autowired<br>// private WebTestClient webTestClient;<br>//<br>// @Test<br>// void testGetAllProducts() {<br>// webTestClient.get().uri(&quot;/api/v1/products&quot;)<br>// .exchange() // Ä°steÄŸi gÃ¶nder ve yanÄ±tÄ± al<br>// .expectStatus().isOk() // HTTP durumunun 200 OK olmasÄ±nÄ± bekle<br>// .expectHeader().contentType(MediaType.APPLICATION_JSON) // Ä°Ã§erik tipinin JSON olmasÄ±nÄ± bekle<br>// .expectBodyList(Product.class).hasSize(expectedSize); // Beklenen sayÄ±da Ã¼rÃ¼n olmasÄ±nÄ± kontrol et<br>// }<br>// }</pre><h3>6. Reaktif ProgramlamanÄ±n FaydalarÄ± (KÄ±saca)</h3><ul><li><strong>Engellemeyen I/O (Non-blocking I/O):</strong> Daha az kaynakla daha fazla isteÄŸi iÅŸleyebilir. Her istek iÃ§in ayrÄ± bir thread oluÅŸturmak yerine, az sayÄ±da thread ile (event loop) Ã§ok sayÄ±da isteÄŸi yÃ¶netir.</li><li><strong>Daha Ä°yi Ã–lÃ§eklenebilirlik:</strong> Ã–zellikle mikroservis mimarilerinde ve gerÃ§ek zamanlÄ± uygulamalarda yatay Ã¶lÃ§eklenmeyi kolaylaÅŸtÄ±rÄ±r.</li><li><strong>Verimli Kaynak KullanÄ±mÄ±:</strong> Threadâ€™lerin bloke olmasÄ±nÄ± azaltarak CPU ve bellek kullanÄ±mÄ±nÄ± optimize eder.</li><li><strong>AkÄ±ÅŸ (Streaming) Yetenekleri:</strong> BÃ¼yÃ¼k veri kÃ¼melerini veya sonsuz veri akÄ±ÅŸlarÄ±nÄ± (Ã¶rneÄŸin, sensÃ¶r verileri, sosyal medya akÄ±ÅŸlarÄ±) verimli bir ÅŸekilde iÅŸleyebilir.</li></ul><h3>7. Reaktif Programlama Ne Zaman KullanÄ±lmalÄ±? (AltÄ±n Kural!)</h3><p>âœ… <strong>GerÃ§ek zamanlÄ± uygulamalar</strong> iÃ§in idealdir: Sohbet uygulamalarÄ±, canlÄ± borsa verileri, IoT (Nesnelerin Ä°nterneti) uygulamalarÄ±, bildirim servisleri.</p><p>âœ… <strong>YÃ¼ksek trafikli (high-throughput)</strong> ve Ã¶lÃ§eklenebilirlik gerektiren servisler iÃ§in Ã§ok faydalÄ±dÄ±r. Ã–zellikle I/O baÄŸÄ±mlÄ± (veritabanÄ±, harici API Ã§aÄŸrÄ±larÄ±) iÅŸlemleri yoÄŸun olan servisler.</p><p>âœ… <strong>Veri akÄ±ÅŸlarÄ±nÄ±n (data streams)</strong> iÅŸlenmesi gereken durumlar.</p><p>âŒ <strong>DÃ¼ÅŸÃ¼k eÅŸzamanlÄ±lÄ±k (concurrency)</strong> ihtiyacÄ± olan, basit CRUD (Create, Read, Update, Delete) tabanlÄ± geleneksel uygulamalar iÃ§in <strong>gereksiz karmaÅŸÄ±klÄ±k</strong> getirebilir. EÄŸer uygulamanÄ±zÄ±n darboÄŸazÄ± I/O deÄŸilse veya trafik Ã§ok dÃ¼ÅŸÃ¼kse, reaktif programlamanÄ±n faydalarÄ±nÄ± gÃ¶remeyebilirsiniz.</p><ul><li><em>Reaktif programlama bir â€œgÃ¼mÃ¼ÅŸ kurÅŸunâ€ deÄŸildir. Her probleme Ã§Ã¶zÃ¼m sunmaz. Projenizin ihtiyaÃ§larÄ±nÄ± iyi analiz edip, reaktif mimarinin getireceÄŸi faydalarÄ±n, Ã¶ÄŸrenme eÄŸrisi ve potansiyel karmaÅŸÄ±klÄ±ÄŸa deÄŸip deÄŸmeyeceÄŸine karar vermelisiniz.</em></li></ul><h3>Yeni BaÅŸlayanlar Ä°Ã§in Ekstra Ä°puÃ§larÄ± ve Dikkat Edilmesi Gerekenler</h3><ol><li><strong>FarklÄ± DÃ¼ÅŸÃ¼nme BiÃ§imi:</strong> Reaktif programlama, geleneksel imperative programlamadan farklÄ± bir dÃ¼ÅŸÃ¼nme biÃ§imi gerektirir. AkÄ±ÅŸlarÄ± ve olaylarÄ± dÃ¼ÅŸÃ¼nmeye alÄ±ÅŸmak zaman alabilir.</li><li><strong>subscribe() Hayati Ã–nem TaÅŸÄ±r:</strong> UnutmayÄ±n, Mono ve Flux tembeldir. subscribe() Ã§aÄŸrÄ±lmadÄ±kÃ§a hiÃ§bir ÅŸey olmaz.</li><li><strong>Hata YÃ¶netimi:</strong> Reaktif akÄ±ÅŸlarda hata yÃ¶netimi farklÄ±dÄ±r. onErrorMap, onErrorResume, onErrorReturn gibi operatÃ¶rlerle hatalarÄ± yakalayÄ±p yÃ¶netebilirsiniz. Merkezi hata yÃ¶netimi iÃ§in @ControllerAdvice ve ExceptionHandler kullanabilirsiniz.</li><li><strong>Debugging (Hata AyÄ±klama):</strong> Reaktif akÄ±ÅŸlarÄ± debug etmek, geleneksel kodlara gÃ¶re biraz daha zorlayÄ±cÄ± olabilir. .log(), doOnNext(), doOnError() gibi operatÃ¶rler ve Reactor&#39;un BlockHound gibi araÃ§larÄ± yardÄ±mcÄ± olabilir. IDE&#39;nizin reaktif debug yeteneklerini de keÅŸfedin.</li><li><strong>Thread YÃ¶netimi:</strong> Spring WebFlux, varsayÄ±lan olarak Nettyâ€™nin event loopâ€™larÄ±nÄ± kullanÄ±r. Uzun sÃ¼ren CPU-yoÄŸun iÅŸlemleriniz varsa, bunlarÄ± Schedulers.boundedElastic() gibi farklÄ± bir thread havuzunda Ã§alÄ±ÅŸtÄ±rmayÄ± dÃ¼ÅŸÃ¼nmelisiniz ki event loop&#39;larÄ± bloke etmeyin.</li><li><strong>Engellemeyen KÃ¼tÃ¼phaneler:</strong> Reaktif bir sistemde, tÃ¼m Ã§aÄŸrÄ±larÄ±n (veritabanÄ±, harici servisler vb.) engellemeyen (non-blocking) olmasÄ± Ã¶nemlidir. EÄŸer reaktif bir akÄ±ÅŸ iÃ§inde engelleme yapan bir kÃ¼tÃ¼phane Ã§aÄŸrÄ±sÄ± yaparsanÄ±z, reaktifliÄŸin tÃ¼m faydalarÄ±nÄ± kaybedebilirsiniz. Spring Data Reactive Repositories (MongoDB, R2DBC vs.) ve WebClient bu yÃ¼zden Ã¶nemlidir.</li></ol><h3>SonuÃ§</h3><p>Bu yazÄ±da, Spring Boot ve WebFlux ile reaktif programlamaya kapsamlÄ± bir giriÅŸ yaptÄ±k. Temel kavramlarÄ±, Mono ve Flux&#39;Ä±, reaktif bir REST API&#39;nin nasÄ±l oluÅŸturulacaÄŸÄ±nÄ± ve test edileceÄŸini adÄ±m adÄ±m inceledik. AyrÄ±ca, yeni baÅŸlayanlar iÃ§in Ã¶nemli ipuÃ§larÄ± ve dikkat edilmesi gereken noktalarÄ± paylaÅŸtÄ±m.</p><p>Reaktif programlama, modern uygulama geliÅŸtirmenin gÃ¼Ã§lÃ¼ bir aracÄ±dÄ±r, ancak doÄŸru yerde ve doÄŸru ÅŸekilde kullanÄ±ldÄ±ÄŸÄ±nda en iyi sonuÃ§larÄ± verir. EÄŸer uygulamanÄ±z asenkron ve engellemeyen bir yapÄ±ya gerÃ§ekten ihtiyaÃ§ duyuyorsa, Spring WebFlux sizin iÃ§in harika bir seÃ§enektir.</p><p>UmarÄ±m bu yazÄ±, reaktif programlama yolculuÄŸunuzda size iyi bir baÅŸlangÄ±Ã§ noktasÄ± sunmuÅŸtur. Yorumlarda sorularÄ±nÄ±zÄ± ve deneyimlerinizi paylaÅŸmaktan Ã§ekinmeyin! Mutlu kodlamalar!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5815c96be738" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Apache Kafka Entegrasyonu: AdÄ±m AdÄ±m Rehber ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-apache-kafka-entegrasyonu-ad%C4%B1m-ad%C4%B1m-rehber-8f2d4416f987?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/8f2d4416f987</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:21:57 GMT</pubDate>
<atom:updated>2025-05-07T22:21:57.509Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*4TWM0sbXF0b8oxc2EPkomg.png" /></figure><p>Apache Kafka, yÃ¼ksek hacimli veri akÄ±ÅŸlarÄ±nÄ± iÅŸlemek iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ bir daÄŸÄ±tÄ±k mesajlaÅŸma sistemidir. Spring Boot ise mikroservis mimarilerinde ve modern uygulamalarda hÄ±zlÄ± geliÅŸtirme iÃ§in ideal bir frameworkâ€™tÃ¼r. Bu yazÄ±da Spring Boot uygulamasÄ± ile Apache Kafkaâ€™yÄ± nasÄ±l entegre edeceÄŸimizi adÄ±m adÄ±m Ã¶ÄŸreneceÄŸiz.</p><h3>ğŸ”§ 1. Gerekli AraÃ§lar ve Kurulumlar</h3><h3>KullandÄ±ÄŸÄ±mÄ±z Teknolojiler:</h3><ul><li><strong>Java 17+</strong></li><li><strong>Spring Boot 3.x</strong></li><li><strong>Apache Kafka (2.8+)</strong></li><li><strong>Spring Tool Suite (STS) veya IntelliJ IDEA</strong></li><li><strong>Maven (Dependency Management)</strong></li><li><strong>Postman (API Testi)</strong></li></ul><h3>Kafka Kurulumu:</h3><ol><li>Apache Kafkaâ€™yÄ± <a href="https://kafka.apache.org/downloads">resmi sitesinden</a> indirin.</li><li>config/server.properties dosyasÄ±nÄ± aÃ§Ä±n ve gerekirse listeners ve port ayarlarÄ±nÄ± dÃ¼zenleyin (varsayÄ±lan port: 9092).</li><li>Kafkaâ€™yÄ± baÅŸlatÄ±n:</li></ol><pre># Zookeeper&#39;Ä± baÅŸlat bin/zookeeper-server-start.sh config/zookeeper.properties <br># Kafka broker&#39;Ä± baÅŸlat bin/kafka-server-start.sh config/server.properties</pre><h3>ğŸ“¦ 2. Spring Boot Projesi OluÅŸturma</h3><p>STS veya IntelliJ Ã¼zerinden yeni bir Spring Boot projesi oluÅŸturun. Gerekli baÄŸÄ±mlÄ±lÄ±klar:</p><pre>&lt;!-- Spring for Apache Kafka --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Web (REST API iÃ§in) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Boot DevTools (GeliÅŸtirme KolaylÄ±ÄŸÄ±) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>ğŸ” 3. Ana SÄ±nÄ±f: Kafka Entegrasyonunu Aktif Hale Getirme</h3><p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za @EnableKafka ekleyerek Kafka desteÄŸi aktif edilir:</p><pre>@SpringBootApplication<br>@EnableKafka<br>public class SpringBootKafkaApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(SpringBootKafkaApplication.class, args);<br> }<br>}</pre><h3>ğŸ—„ï¸ 4. MesajlarÄ± Saklamak Ä°Ã§in Repository OluÅŸturma</h3><p>Basit bir MessageRepository, alÄ±nan Kafka mesajlarÄ±nÄ± geÃ§ici olarak saklamak iÃ§in kullanÄ±lÄ±r.</p><pre>@Component<br>public class MessageRepository {<br> private List&lt;String&gt; messages = new ArrayList&lt;&gt;();<br>public void addMessage(String message) {<br> messages.add(message);<br> }<br> public String getAllMessages() {<br> return messages.toString();<br> }<br>}</pre><blockquote><em>ğŸ’¡ Bu repository, sadece demo amaÃ§lÄ±dÄ±r. GerÃ§ek senaryolarda Redis, MongoDB gibi veri tabanlarÄ± kullanÄ±labilir.</em></blockquote><h3>ğŸšš 5. Mesaj Ãœretici (Producer): Kafkaâ€™ya Veri GÃ¶nderimi</h3><p>MessageProducer, Kafka topicâ€™ine mesaj gÃ¶ndermek iÃ§in kullanÄ±lÄ±r:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageProducer {<br><br> private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br><br> @Value(&quot;${myapp.kafka.topic}&quot;)<br> private String topic;<br><br> public void sendMessage(String message) {<br> log.info(&quot;MESAJ ÃœRETÄ°CÄ°DEN GÃ–NDERÄ°LÄ°YOR -&gt; {}&quot;, message);<br> kafkaTemplate.send(topic, message);<br> }<br>}</pre><h3>KafkaTemplate Nedir?</h3><ul><li>Kafka ile etkileÅŸim kurmak iÃ§in kullanÄ±lan Springâ€™in yÃ¼ksek seviye APIâ€™sidir.</li><li>KafkaTemplate sayesinde mesaj gÃ¶nderimi (send) kolaylaÅŸtÄ±rÄ±lÄ±r.</li></ul><h3>ğŸ“¥ 6. Mesaj TÃ¼ketici (Consumer): Kafkaâ€™dan Veri Alma</h3><p>@KafkaListener, belirtilen topicâ€™teki mesajlarÄ± dinler ve iÅŸler:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageConsumer {<br><br> private final MessageRepository messageRepo;<br><br> @KafkaListener(topics = &quot;${myapp.kafka.topic}&quot;, groupId = &quot;kafka-group&quot;)<br> public void consume(String message) {<br> log.info(&quot;MESAJ TÃœKETÄ°CÄ°YE ULAÅTI -&gt; {}&quot;, message);<br> messageRepo.addMessage(message);<br> }<br>}</pre><h3>Anahtar Ã–zellikler:</h3><ul><li><strong>topics</strong>: Dinlenen Kafka topicâ€™i.</li><li><strong>groupId</strong>: TÃ¼ketici grubunu tanÄ±mlar. AynÄ± gruptaki tÃ¼keticiler mesajlarÄ± paylaÅŸÄ±r.</li></ul><h3>ğŸŒ 7. REST API ile EtkileÅŸim: KafkaRestController</h3><p>REST istemcileri iÃ§in basit bir arayÃ¼z saÄŸlar:</p><pre>@Slf4j<br>@RestController<br>@RequestMapping(&quot;/api/kafka&quot;)<br>@RequiredArgsConstructor<br>public class KafkaRestController {<br><br> private final MessageProducer producer;<br> private final MessageRepository messageRepo;<br><br> // Kafka topic&#39;ine mesaj gÃ¶nder<br> @GetMapping(&quot;/send&quot;)<br> public ResponseEntity&lt;String&gt; sendMsg(@RequestParam(&quot;msg&quot;) String message) {<br> log.info(&quot;REST API ÃœZERÄ°NDEN MESAJ ALINDI -&gt; {}&quot;, message);<br> producer.sendMessage(message);<br> return ResponseEntity.ok(&quot;&#39;&quot; + message + &quot;&#39; mesajÄ± baÅŸarÄ±yla gÃ¶nderildi!&quot;);<br> }<br><br> // AlÄ±nan tÃ¼m mesajlarÄ± listele<br> @GetMapping(&quot;/messages&quot;)<br> public ResponseEntity&lt;String&gt; getAllMessages() {<br> return ResponseEntity.ok(messageRepo.getAllMessages());<br> }<br>}</pre><h3>API KullanÄ±mÄ±:</h3><p>GET /send?msg=... Kafka topic&#39;ine mesaj gÃ¶nder</p><p>GET /getAllTÃ¼m alÄ±nan mesajlarÄ± listele</p><h3>âš™ï¸ 8. Uygulama YapÄ±landÄ±rmasÄ±: application.yml</h3><pre>server:<br> port: 9090<br>spring:<br> kafka:<br> producer:<br> bootstrap-servers: localhost:9092<br> key-serializer: org.apache.kafka.common.serialization.StringSerializer<br> value-serializer: org.apache.kafka.common.serialization.StringSerializer<br> consumer:<br> bootstrap-servers: localhost:9092<br> key-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br> value-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br>myapp:<br> kafka:<br> topic: myKafkaTest</pre><h3>YapÄ±landÄ±rma AÃ§Ä±klamalarÄ±:</h3><ul><li><strong>bootstrap-servers</strong>: Kafka brokerâ€™Ä±n adresi.</li><li><strong>key-serializer/deserializer</strong>: AnahtarlarÄ±n nasÄ±l serileÅŸtirileceÄŸi.</li><li><strong>value-serializer/deserializer</strong>: Mesaj iÃ§eriÄŸinin serileÅŸtirme biÃ§imi.</li><li><strong>topic</strong>: Dinlenen veya yazÄ±lan Kafka topicâ€™i.</li></ul><h3>ğŸ§  9. Kafka Entegrasyonu Ä°Ã§in Ä°puÃ§larÄ± ve En Ä°yi Uygulamalar</h3><h3>1. Hata YÃ¶netimi ve Retry MekanizmalarÄ±</h3><ul><li>@Retryable anotasyonu ile otomatik tekrar deneme yapÄ±labilir.</li><li>Kafka Consumer iÃ§inde Acknowledgment ile manuel commit yapÄ±labilir.</li></ul><pre>@KafkaListener(topics = &quot;myTopic&quot;)<br>public void listen(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack) {<br> try {<br> // Ä°ÅŸlemler<br> ack.acknowledge(); // BaÅŸarÄ±lÄ±ysa commit<br> } catch (Exception e) {<br> // Hata yÃ¶netimi<br> }<br>}</pre><h3>2. Dead Letter Queue (DLQ)</h3><ul><li>BaÅŸarÄ±sÄ±z mesajlarÄ± baÅŸka bir topicâ€™e yÃ¶nlendirmek iÃ§in DLQ kullanÄ±labilir.</li></ul><h3>3. Serialization</h3><ul><li>JSON formatÄ±nda mesaj gÃ¶ndermek iÃ§in JsonSerializer kullanÄ±labilir.</li><li>@KafkaListener metotlarÄ±nda ConsumerRecord ile header bilgileri de alÄ±nabilir.</li></ul><h3>4. Partitions ve Offset YÃ¶netimi</h3><ul><li>Topic partition sayÄ±sÄ± artÄ±rÄ±larak paralel tÃ¼ketim saÄŸlanabilir.</li><li>auto.offset.reset ayarÄ± ile tÃ¼ketici baÅŸlangÄ±Ã§ta hangi offsetâ€™ten baÅŸlayacak belirlenir (Ã¶rnek: earliest, latest).</li></ul><h3>ğŸ§ª 10. Test SÃ¼reci</h3><h3>1. Kafka Topic OluÅŸturma</h3><pre>bin/kafka-topics.sh --create --topic myKafkaTest --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1</pre><h3>2. Kafka Consumer CLI ile Mesaj Dinleme</h3><pre>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic myKafkaTest --from-beginning</pre><h3>3. API ile Mesaj GÃ¶nderme</h3><pre>curl http://localhost:9090/send?msg=MerhabaKafka</pre><h3>4. AlÄ±nan MesajlarÄ± GÃ¶rÃ¼ntÃ¼leme</h3><pre>curl http://localhost:9090/getAll</pre><h3>ğŸ“Œ 11. GÃ¼venlik ve Performans Ä°puÃ§larÄ±</h3><h3>1. SSL/TLS ile GÃ¼venli BaÄŸlantÄ±</h3><ul><li>Kafka baÄŸlantÄ±sÄ± iÃ§in SSL ayarlarÄ± yapÄ±labilir.</li><li>ssl.truststore.location ve ssl.keystore.location gibi parametreler application.ymlâ€™de tanÄ±mlanÄ±r.</li></ul><h3>2. Mesaj SÄ±kÄ±ÅŸtÄ±rmasÄ±</h3><ul><li>compression.type ile mesajlar sÄ±kÄ±ÅŸtÄ±rÄ±labilir (gzip, snappy, lz4).</li></ul><h3>3. Mesaj DoÄŸrulama</h3><ul><li>@Validated ve @KafkaListener ile gelen mesajlar doÄŸrulanabilir.</li></ul><h3>ğŸ§­ 12. SonuÃ§</h3><p>Spring Boot ile Apache Kafka entegrasyonu, mikroservislerde asenkron mesajlaÅŸma, olay tabanlÄ± mimariler, log toplama ve gerÃ§ek zamanlÄ± veri iÅŸleme gibi birÃ§ok senaryoda gÃ¼Ã§lÃ¼ Ã§Ã¶zÃ¼mler sunar. Bu yazÄ±da, temel yapÄ±landÄ±rmalarla birlikte Kafka topicâ€™ine mesaj gÃ¶nderme ve alma iÅŸlemlerini basitÃ§e adÄ±m adÄ±m Ã¶ÄŸrendik.</p><h3>âœ… Ã–ÄŸrendiklerimiz:</h3><ul><li>Kafka ile Spring Boot entegrasyonu</li><li>Producer ve Consumer sÄ±nÄ±flarÄ±</li><li>REST API ile Kafka etkileÅŸimi</li><li>YapÄ±landÄ±rma ve hata yÃ¶netimi</li><li>GÃ¼venlik ve performans optimizasyonlarÄ±</li></ul><p>Bu temel yapÄ±yÄ± alarak Kafka ile daha karmaÅŸÄ±k senaryolar (Ã¶rneÄŸin event sourcing, stream processing) da geliÅŸtirebilirsiniz.</p><h3>ğŸ“˜ Ekstra Kaynaklar</h3><ul><li><a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/">Spring Kafka Documentation</a></li><li><a href="https://kafka.apache.org/documentation/">Apache Kafka Official Docs</a></li><li><a href="https://kafka.apache.org/documentation/streams/">Kafka Streams ile GerÃ§ek ZamanlÄ± Veri Ä°ÅŸleme</a></li><li><a href="https://www.baeldung.com/spring-kafka">Kafka ile Mikroservis Mimari TasarÄ±mÄ±â€Šâ€”â€ŠBaeldung</a></li></ul><p>EÄŸer bu yazÄ± hoÅŸunuza gittiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± ya da Ã¶nerilerinizi yorumlarda bekliyorum. ğŸ˜Š</p><p>#springboot #kafka #messaging #microservices #java #backend</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8f2d4416f987" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Javaâ€™da SerileÅŸtirme (Serialization) ve En Ä°yi Uygulamalar ]]>
</title>
<link>https://pehlivanmert.medium.com/javada-serile%C5%9Ftirme-serialization-ve-en-i%CC%87yi-uygulamalar-4fd05ec48a4a?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4fd05ec48a4a</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:05:31 GMT</pubDate>
<atom:updated>2025-05-09T06:13:07.941Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/629/1*pwMbKl8czO8lGyLut1HDZQ.png" /></figure><p>Javaâ€™da serileÅŸtirme (<strong>serialization</strong>), bir nesnenin durumunun (state) bayt dizisine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recidir. Bu iÅŸlem sayesinde nesneler kalÄ±cÄ± olarak saklanabilir (Ã¶rneÄŸin dosya ya da veritabanÄ±nda), aÄŸ Ã¼zerinden aktarÄ±labilir veya geÃ§ici olarak Ã¶nbellekte tutulabilir. SerileÅŸtirme sÃ¼recinin tersi olan <strong>deserileÅŸtirme (deserialization)</strong> ise bu bayt dizisinin tekrar orijinal nesneye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesini saÄŸlar.</p><p>Bu yazÄ±da Javaâ€™daki serileÅŸtirme mekanizmasÄ±nÄ± ele alacak, ne zaman kullanÄ±lmasÄ± gerektiÄŸini ve en iyi uygulama yÃ¶ntemlerini adÄ±m adÄ±m inceleyeceÄŸiz.</p><h3>ğŸ“Œ SerileÅŸtirme Nedir?</h3><p>SerileÅŸtirme, bir nesnenin iÃ§eriÄŸini (durumunu) bayt dizisine Ã§evirerek farklÄ± ortamlarda taÅŸÄ±nabilir hale getiren bir tekniktir. Ã–zetle:</p><ul><li>Nesneler kalÄ±cÄ± olarak saklanabilir.</li><li>AÄŸ Ã¼zerinden gÃ¶nderilip alÄ±nabilir.</li><li>HÄ±zlÄ±ca geri yÃ¼klenebilir (deserialize edilebilir).</li></ul><p>Bir sÄ±nÄ±fÄ±n serileÅŸtirilebilmesi iÃ§in java.io.Serializable arayÃ¼zÃ¼nÃ¼ uygulamasÄ± gerekir. Bu, sadece bir iÅŸaretleme arayÃ¼zÃ¼dÃ¼r (marker interface), herhangi bir metot iÃ§ermez.</p><pre>public class Employee implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private String name;<br> private int age;</pre><pre> // constructor, getters and setters<br>}</pre><blockquote><em>âš ï¸ </em><em>Serializable uygulamak, sÄ±nÄ±fÄ±nÄ±zÄ±n otomatik olarak gÃ¼venli ya da optimize edilmiÅŸ bir serileÅŸtirme sÃ¼recinden geÃ§eceÄŸi anlamÄ±na gelmez. Dikkatli kullanÄ±m ÅŸarttÄ±r.</em></blockquote><h3>âœ… SerileÅŸtirme Ne Zaman KullanÄ±lÄ±r?</h3><h3>1. KalÄ±cÄ±lÄ±k (Persistence):</h3><p>Nesneleri dosyalarda veya veritabanlarÄ±nda saklamak iÃ§in kullanÄ±lÄ±r.</p><h3>2. Ä°letiÅŸim (Communication):</h3><p>AÄŸ Ã¼zerinden nesnelerin gÃ¶nderilmesi gerektiÄŸinde (Ã¶rneÄŸin RMIâ€Šâ€”â€ŠRemote Method Invocation) serileÅŸtirme devreye girer.</p><h3>3. Ã–nbellekleme (Caching):</h3><p>GeÃ§ici olarak nesnelerin bellekte saklanmasÄ± ve daha sonra hÄ±zlÄ±ca eriÅŸilmesi iÃ§in kullanÄ±lÄ±r.</p><h3>ğŸ§  Java SerileÅŸtirme Ä°Ã§in En Ä°yi Uygulamalar</h3><h3>1. GerektiÄŸi Zaman KullanÄ±n</h3><p>Her sÄ±nÄ±fÄ±n serileÅŸtirilebilir olmasÄ± gerekmez. Sadece gerÃ§ekten ihtiyaÃ§ duyduÄŸunuz sÄ±nÄ±flara Serializable uygulayÄ±n. Gereksiz serileÅŸtirme, gÃ¼venlik aÃ§Ä±klarÄ±na ve performans kayÄ±plarÄ±na yol aÃ§abilir.</p><pre>public class Employee implements Serializable { ... }</pre><h3>2. SaklanmasÄ± Gereken AlanlarÄ± transient ile Gizleyin</h3><p>BazÄ± alanlar serileÅŸtirilmemelidir. Ã–rneÄŸin ÅŸifre, API anahtarÄ± gibi hassas bilgileri transient anahtar kelimesiyle iÅŸaretleyin.</p><pre>public class User implements Serializable {<br> private String username;<br> private transient String password; // Åifre serileÅŸtirilmez<br>}</pre><h3>3. serialVersionUID TanÄ±mlayÄ±n</h3><p>Her serileÅŸtirilebilir sÄ±nÄ±f iÃ§in private static final long serialVersionUID = 1L; tanÄ±mlanmalÄ±dÄ±r. Bu, sÄ±nÄ±fÄ±n sÃ¼rÃ¼m numarasÄ±nÄ± temsil eder ve farklÄ± sÃ¼rÃ¼mler arasÄ±nda uyumluluÄŸu saÄŸlar.</p><blockquote><em>EÄŸer </em><em>serialVersionUID tanÄ±mlanmazsa, JVM otomatik olarak Ã¼retir ama bu, kÃ¼Ã§Ã¼k deÄŸiÅŸikliklerde bile </em><em>InvalidClassException hatasÄ±na neden olabilir.</em></blockquote><h3>4. Ã–zel SerileÅŸtirme MantÄ±ÄŸÄ± Ekleyin (Ä°steÄŸe BaÄŸlÄ±)</h3><p>EÄŸer varsayÄ±lan serileÅŸtirme yeterli deÄŸilse, writeObject() ve readObject() metodlarÄ±nÄ± override ederek Ã¶zel mantÄ±k ekleyebilirsiniz.</p><pre>private void writeObject(ObjectOutputStream oos) throws IOException {<br> oos.defaultWriteObject();<br> // Ã–zel serileÅŸtirme iÅŸlemleri burada yapÄ±labilir<br>}</pre><pre>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<br> ois.defaultReadObject();<br> // Ã–zel deserileÅŸtirme iÅŸlemleri burada yapÄ±labilir<br>}</pre><h3>5. Hassas Verilerin SerileÅŸtirilmesinden KaÃ§Ä±nÄ±n</h3><p>Åifre, kimlik bilgileri, kredi kartÄ± bilgileri gibi veriler asla serileÅŸtirilmemelidir. Bunu Ã¶nlemek iÃ§in yukarÄ±da bahsedilen transient kullanÄ±mÄ± oldukÃ§a Ã¶nemlidir.</p><h3>6. SerileÅŸtirme Proxyâ€™leri KullanÄ±n (GeliÅŸmiÅŸ Seviye)</h3><p>Daha fazla kontrol ve gÃ¼venlik istiyorsanÄ±z, serileÅŸtirme proxy desenini kullanabilirsiniz. Bu yÃ¶ntem, sÄ±nÄ±fÄ±n doÄŸrudan serileÅŸtirilmesini engeller ve Ã¶zel bir yapÄ±yla koruma saÄŸlar.</p><pre>private Object writeReplace() {<br> return new SerializationProxy(this);<br>}</pre><pre>private static class SerializationProxy implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private final String username;</pre><pre> SerializationProxy(User user) {<br> this.username = user.username;<br> }</pre><pre> private Object readResolve() {<br> return new User(username);<br> }<br>}</pre><p>Bu yaklaÅŸÄ±m, nesne oluÅŸturma sÃ¼recini kontrol altÄ±na alÄ±r ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ± azaltÄ±r.</p><h3>7. Alternatif SerileÅŸtirme KÃ¼tÃ¼phaneleri KullanÄ±n</h3><p>Javaâ€™nÄ±n yerel serileÅŸtirme mekanizmasÄ±, her zaman en verimli Ã§Ã¶zÃ¼m olmayabilir. Ã–zellikle bÃ¼yÃ¼k sistemlerde, yÃ¼ksek performans gerektiren senaryolarda ÅŸu alternatifler dÃ¼ÅŸÃ¼nÃ¼lebilir:</p><ul><li><strong>Google Protocol Buffers (protobuf)</strong></li><li><strong>Apache Avro</strong></li><li><strong>Jackson (JSON formatÄ±nda serileÅŸtirme)</strong></li><li><strong>Kryo (hÄ±zlÄ±, kompakt serileÅŸtirme)</strong></li><li><strong>MessagePack</strong></li></ul><p>Bu kÃ¼tÃ¼phaneler genellikle daha az yer kaplar, daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r ve platformlar arasÄ± uyumluluk saÄŸlar.</p><h3>ğŸ§ª Basit Bir SerileÅŸtirme &amp; DeserileÅŸtirme Ã–rneÄŸi</h3><h3>1. Nesneyi SerileÅŸtirme</h3><pre>Employee emp = new Employee(&quot;John Doe&quot;, 30);</pre><pre>try (FileOutputStream fileOut = new FileOutputStream(&quot;employee.ser&quot;);<br> ObjectOutputStream out = new ObjectOutputStream(fileOut)) {<br> out.writeObject(emp);<br>} catch (IOException e) {<br> e.printStackTrace();<br>}</pre><h3>2. Nesneyi DeserileÅŸtirme</h3><pre>Employee emp = null;</pre><pre>try (FileInputStream fileIn = new FileInputStream(&quot;employee.ser&quot;);<br> ObjectInputStream in = new ObjectInputStream(fileIn)) {<br> emp = (Employee) in.readObject();<br>} catch (IOException | ClassNotFoundException e) {<br> e.printStackTrace();<br>}</pre><pre>System.out.println(&quot;Name: &quot; + emp.getName() + &quot;, Age: &quot; + emp.getAge());</pre><h3>ğŸ¯ SonuÃ§ Olarak</h3><p>Javaâ€™nÄ±n serileÅŸtirme mekanizmasÄ± gÃ¼Ã§lÃ¼dÃ¼r ama doÄŸru ve dikkatli kullanÄ±lmasÄ± gereken bir Ã¶zelliktir. YukarÄ±daki en iyi uygulamalara uyarak:</p><ul><li>PerformansÄ± artÄ±rabilir,</li><li>GÃ¼venliÄŸi gÃ¼Ã§lendirebilir,</li><li>SÃ¼rÃ¼m uyumsuzluklarÄ±ndan kaÃ§Ä±nabilir,</li><li>Uygun yerlerde alternatif Ã§Ã¶zÃ¼mler tercih ederek sisteminizi optimize edebilirsiniz.</li></ul><p>UnutmayÄ±n: Her nesne serileÅŸtirilmeye mÃ¼sait deÄŸildir. Dikkatli planlama yapmak, hem kod kalitenizi hem de sisteminizin gÃ¼venliÄŸini artÄ±racaktÄ±r.</p><h3>ğŸ“˜ Ekstra Kaynaklar</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html">Oracle Java Documentationâ€Šâ€”â€ŠSerialization</a></li><li><a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Effective Java by Joshua Blochâ€Šâ€”â€ŠItem 74â€“78 on Serialization</a></li><li><a href="https://www.baeldung.com/java-serialization">Baeldungâ€Šâ€”â€ŠJava Serialization Guide</a></li></ul><p>EÄŸer bu yazÄ± faydalÄ± geldiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± veya deneyimlerinizi yorumlarda paylaÅŸmaktan Ã§ekinmeyin. ğŸ˜Š</p><p>#java #serialization #deserialization #bestpractices #softwaredevelopment #backend #mediumtÃ¼rkÃ§e</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fd05ec48a4a" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot + Redis: UygulamanÄ±zÄ±n PerformansÄ±nÄ± ArtÄ±rmak Ä°Ã§in BaÅŸlangÄ±Ã§ DÃ¼zeyinden Ä°leriâ€¦ ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-redis-uygulaman%C4%B1z%C4%B1n-performans%C4%B1n%C4%B1-art%C4%B1rmak-i%CC%87%C3%A7in-ba%C5%9Flang%C4%B1%C3%A7-d%C3%BCzeyinden-i%CC%87leri-76b70fd9f3a4?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/76b70fd9f3a4</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 06 May 2025 20:48:18 GMT</pubDate>
<atom:updated>2025-05-09T06:14:02.224Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZOpeAqUVyZM8UkjvOXmTXg.png" /></figure><h3>ğŸš€ Spring Boot + Redis: UygulamanÄ±zÄ±n PerformansÄ±nÄ± ArtÄ±rmak Ä°Ã§in BaÅŸlangÄ±Ã§ DÃ¼zeyinden Ä°leri Seviyeye Rehber</h3><p>YazÄ±lÄ±m dÃ¼nyasÄ±nda hÄ±z, her ÅŸey demektir. KullanÄ±cÄ±larÄ±n beklemesini istemiyorsanÄ±z, uygulamanÄ±zÄ±n hÄ±zlÄ± yanÄ±t vermesi gerekir. Ä°ÅŸte bu noktada <strong>Redis</strong>, Spring Boot uygulamalarÄ±nÄ±zda ciddi performans artÄ±ÅŸlarÄ± saÄŸlayabileceÄŸiniz gÃ¼Ã§lÃ¼ bir yardÄ±mcÄ±dÄ±r.</p><p>Bu yazÄ±da:</p><ul><li>Redis nedir?</li><li>Neden cache kullanmalÄ±yÄ±z?</li><li>Spring Boot ile Redis nasÄ±l entegre edilir?</li><li>REST API Ã¼zerinden Redis iÅŸlemleri nasÄ±l yapÄ±lÄ±r?</li><li>@Cacheable, @CacheEvict, @CachePut gibi Spring Cache anotasyonlarÄ±nÄ± nasÄ±l kullanÄ±lÄ±r?</li><li>Mikroservis mimarilerinde daÄŸÄ±tÄ±k caching nasÄ±l yapÄ±lÄ±r?</li></ul><p>gibi konulara deÄŸineceÄŸiz. HazÄ±r mÄ±sÄ±nÄ±z? BaÅŸlayalÄ±m!</p><h3>ğŸ’¡ Cache Nedir? Neden Ã–nemlidir?</h3><p><strong>Cache (Ã¶nbellek)</strong>, sÄ±klÄ±kla eriÅŸilen verilerin geÃ§ici olarak saklandÄ±ÄŸÄ± bir mekanizmadÄ±r. Veriler genellikle <strong>anahtar-deÄŸer (key-value)</strong> formatÄ±nda tutulur.</p><h3>âœ… Cacheâ€™in AvantajlarÄ±:</h3><ul><li>VeritabanÄ±na yapÄ±lan sorgu sayÄ±sÄ±nÄ± azaltÄ±r.</li><li>Uygulama yanÄ±t sÃ¼resini kÄ±saltÄ±r.</li><li>Sistem kaynaklarÄ±nÄ± daha verimli kullanmanÄ±zÄ± saÄŸlar.</li><li>Ã–zellikle yÃ¼ksek trafikli uygulamalarda performans kazancÄ± saÄŸlar.</li></ul><p>VeritabanÄ± Ã§aÄŸrÄ±larÄ± zaman alÄ±cÄ± ve pahalÄ± iÅŸlemlerdir. Ä°ÅŸte bu yÃ¼zden, sÄ±k kullanÄ±lan verileri Ã¶nbellekte tutmak, uygulamanÄ±zÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.</p><h3>ğŸ§  Redis Nedir?</h3><p><strong>Redis</strong>, aÃ§Ä±k kaynaklÄ±, bellek tabanlÄ± (in-memory) bir veri deposudur. Hem cache olarak hem de veri saklama ve mesajlaÅŸma amaÃ§lÄ± kullanÄ±labilir.</p><h3>ğŸ”¥ Redisâ€™in Ã–zellikleri:</h3><ul><li>HÄ±zlÄ± okuma/yazma iÅŸlemi Ã§Ã¼nkÃ¼ tÃ¼m veriler RAMâ€™de tutulur.</li><li>Basit ve gÃ¼Ã§lÃ¼ komut seti.</li><li>Stringâ€™lerden Hashâ€™lara kadar Ã§eÅŸitli veri yapÄ±larÄ±nÄ± destekler.</li><li>DaÄŸÄ±tÄ±k sistemlerde kolayca entegre edilebilir.</li></ul><h3>ğŸ› ï¸ Spring Boot ile Redis Entegrasyonu</h3><p>Spring Boot, Redis ile Ã§alÄ±ÅŸmayÄ± oldukÃ§a kolaylaÅŸtÄ±rÄ±r. spring-boot-starter-data-redis sayesinde Redis baÄŸlantÄ±sÄ± kurmak, veri iÅŸlemek ve yÃ¶netmek Ã§ok basittir.</p><h3>1. Gerekli BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h3><p>Maven kullanÄ±yorsanÄ±z pom.xml dosyanÄ±za aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p><pre>&lt;!-- Spring Boot Redis Starter --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Jedis Client --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br> &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Spring Cache Abstraction --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>2. Redis Sunucusunu YapÄ±landÄ±rÄ±n</h3><p>application.properties dosyanÄ±za Redis baÄŸlantÄ± bilgilerini ekleyin:</p><pre>spring.redis.host=localhost<br>spring.redis.port=6379<br>spring.redis.password=</pre><p>EÄŸer Redis farklÄ± bir sunucuda Ã§alÄ±ÅŸÄ±yor ise buraya IP adresini ve portu yazabilirsiniz.</p><h3>3. Cachingâ€™i Aktif Hale Getirin</h3><p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za @EnableCaching anotasyonunu ekleyin:</p><pre>@SpringBootApplication<br>@EnableCaching<br>public class RedisApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(RedisApplication.class, args);<br> }<br>}</pre><h3>ğŸ“¦ Ã–rnek Proje: Ãœlke Bilgilerini Redis Ãœzerinde YÃ¶netmek</h3><p>Ufak bir Ã¶rnek projesiyle Redis Ã¼zerinde CRUD iÅŸlemleri yapacaÄŸÄ±z. AmacÄ±mÄ±z Ã¼lke verilerini Redisâ€™te hash olarak saklamak.</p><h3>1. Model SÄ±nÄ±fÄ±: Country.java</h3><pre>public class Country implements Serializable {<br> private Integer sno;<br> private String name;<br> private String countryCode;</pre><pre> // Getters and Setters<br>}</pre><p>Serializable olmasÄ±, Redisâ€™e nesne olarak saklanabilmesi iÃ§in gereklidir.</p><h3>2. Redis YapÄ±landÄ±rma SÄ±nÄ±fÄ±: RedisConfig.java</h3><pre>@Configuration<br>public class RedisConfig {</pre><pre> @Bean<br> public JedisConnectionFactory jedisConnectionFactory() {<br> return new JedisConnectionFactory();<br> }</pre><pre> @Bean<br> public RedisTemplate&lt;String, Object&gt; redisTemplate() {<br> RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();<br> template.setConnectionFactory(jedisConnectionFactory());<br> template.setKeySerializer(new StringRedisSerializer());<br> template.setValueSerializer(new GenericJackson2JsonRedisSerializer());<br> return template;<br> }<br>}</pre><p>JSON formatÄ±nda veri saklamak iÃ§in Jackson serializer kullandÄ±k.</p><h3>ğŸ§  Spring Cache Abstraction: @Cacheable, @CachePut, @CacheEvict</h3><p>Spring, cache iÅŸlemlerini kolaylaÅŸtÄ±rmak iÃ§in bir soyutlama katmanÄ± sunar. En yaygÄ±n kullanÄ±lan anotasyonlar ÅŸunlardÄ±r:</p><h3>ğŸŸ¢ @Cacheable</h3><p>Bir metodun sonucunu cacheâ€™e koyar. AynÄ± parametreyle tekrar Ã§aÄŸrÄ±lÄ±rsa DBâ€™ye gitmeden cacheâ€™den dÃ¶ner.</p><pre>@Cacheable(value = &quot;countries&quot;, key = &quot;#sno&quot;)<br>public Country getCountryById(Integer sno) {<br> return countryRepository.findById(sno).orElse(null);<br>}</pre><h3>ğŸŸ¡ @CachePut</h3><p>Cacheâ€™i gÃ¼ncellemek iÃ§in kullanÄ±lÄ±r. Metod Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ve sonuÃ§ cacheâ€™e yazÄ±lÄ±r.</p><pre>@CachePut(value = &quot;countries&quot;, key = &quot;#country.sno&quot;)<br>public Country updateCountry(Country country) {<br> return countryRepository.save(country);<br>}</pre><h3>ğŸ”´ @CacheEvict</h3><p>Cacheâ€™teki belirli bir veriyi veya tamamÄ±nÄ± silmek iÃ§in kullanÄ±lÄ±r.</p><pre>@CacheEvict(value = &quot;countries&quot;, key = &quot;#sno&quot;)<br>public void deleteCountry(Integer sno) {<br> countryRepository.deleteById(sno);<br>}</pre><h3>TÃ¼mÃ¼nÃ¼ Silme:</h3><pre>@CacheEvict(value = &quot;countries&quot;, allEntries = true)<br>public void clearAllCountries() {<br> countryRepository.deleteAll();<br>}</pre><h3>ğŸ§ª Test Etme: Postman veya curl ile</h3><p>AÅŸaÄŸÄ±daki iÅŸlemleri test etmek iÃ§in Postman veya benzeri bir araÃ§ kullanabilirsiniz:</p><p>POST /api/countryâ€Šâ€”â€ŠYeni Ã¼lke bilgisi ekler.<br>GET /api/countriesâ€Šâ€”â€ŠTÃ¼m Ã¼lke kayÄ±tlarÄ±nÄ± listeler.<br>GET /api/country/1â€Šâ€”â€ŠIDâ€™si 1 olan Ã¼lkeyi getirir.<br>PUT /api/countryâ€Šâ€”â€ŠÃœlke bilgisini gÃ¼nceller.<br>DELETE /api/country/1â€Šâ€”â€ŠIDâ€™si 1 olan Ã¼lkeyi siler.</p><p>Redis tarafÄ±nda verileri doÄŸrulamak iÃ§in redis-cli kullanabilirsiniz:</p><pre>KEYS *<br>HGETALL countries::1</pre><h3>âš™ï¸ Redis ile Daha Ä°leri Gitmek: DaÄŸÄ±tÄ±k Caching</h3><p>Modern mikroservis mimarilerinde, birden fazla servis aynÄ± verilere eriÅŸmek zorunda kalabilir. Her servisin kendi lokal cacheâ€™ini yÃ¶netmesi yerine, ortak bir <strong>daÄŸÄ±tÄ±k cache sunucusu</strong> kullanmak daha mantÄ±klÄ±dÄ±r.</p><h3>ğŸŒ DaÄŸÄ±tÄ±k Caching Nedir?</h3><p>Birden fazla mikroservisin aynÄ± merkezi cache sunucusuna (Ã¶rneÄŸin Redis) eriÅŸmesiyle oluÅŸan yapÄ±ya denir. BÃ¶ylece:</p><ul><li>TÃ¼m servisler aynÄ± veriye ulaÅŸabilir.</li><li>Veri tutarlÄ±lÄ±ÄŸÄ± saÄŸlanÄ±r.</li><li>Performans artar, gecikmeler azalÄ±r.</li></ul><h3>ğŸ¯ Redis Entegrasyonunun AvantajlarÄ±</h3><p><strong>YÃ¼ksek Performans:</strong> Redis bellek tabanlÄ± (in-memory) Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in veri eriÅŸimi Ã§ok hÄ±zlÄ±dÄ±r.</p><p><strong>Kolay Entegrasyon: </strong>Spring Boot ile kolayca entegre edilebilir; otomatik yapÄ±landÄ±rma desteÄŸi sunar.</p><p><strong>Ã‡eÅŸitli Veri YapÄ±larÄ±nÄ± Destekler:</strong> String, Hash, List, Set gibi birÃ§ok veri yapÄ±sÄ±nÄ± destekler.</p><p><strong>Caching AmaÃ§lÄ± KullanÄ±m:</strong> SÄ±k eriÅŸilen verilerin hÄ±zlÄ± bir ÅŸekilde alÄ±nmasÄ± iÃ§in ideal bir Ã§Ã¶zÃ¼m saÄŸlar.</p><p><strong>Ã–lÃ§eklenebilirlik:</strong> DaÄŸÄ±tÄ±k sistemlerde kolayca kullanÄ±labilir ve yÃ¼ksek Ã¶lÃ§eklenebilirlik sunar.</p><h3>ğŸ§­ SonuÃ§</h3><p>Redis, Spring Boot uygulamalarÄ±nÄ±zÄ±n performansÄ±nÄ± artÄ±rmak iÃ§in harika bir Ã§Ã¶zÃ¼mdÃ¼r. Hem basit cache senaryolarÄ± hem de karmaÅŸÄ±k daÄŸÄ±tÄ±k sistemlerde kullanÄ±lmaya uygundur.</p><p>Bu yazÄ±da adÄ±m adÄ±m Redis ile Spring Boot entegrasyonunu gerÃ§ekleÅŸtirdik, REST API Ã¼zerinden veri iÅŸlemlerini yaptÄ±k ve Springâ€™in cache mekanizmalarÄ±nÄ± (@Cacheable, @CacheEvict, @CachePut) detaylÄ±ca inceledik.</p><p>Ä°sterseniz Redis ile session yÃ¶netimi, rate limiting, pub/sub mesajlaÅŸma gibi geliÅŸmiÅŸ konularÄ± da araÅŸtÄ±rabilirsiniz.</p><p>ğŸ¯ <strong>Bonus Tip:</strong><br>Redis CLI ile alÄ±ÅŸtÄ±rmalar yaparak komut satÄ±rÄ±ndan da Redisâ€™i tanÄ±maya baÅŸlayabilirsiniz. Komutlar basit ama Ã§ok gÃ¼Ã§lÃ¼dÃ¼r.</p><p>ğŸ” <strong>Kaynaklar:</strong></p><ul><li><a href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis Documentation</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html">Spring Cache Abstraction</a></li><li><a href="https://redis.io/documentation">Redis Official Documentation</a></li><li><a href="https://www.baeldung.com/spring-data-redis-tutorial">Spring Boot + Redis Guideâ€Šâ€”â€ŠBaeldung</a></li></ul><p>EÄŸer bu yazÄ± hoÅŸunuza gittiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± ya da Ã¶nerilerinizi yorumlarda bekliyorum. ğŸ˜Š</p><p>#springboot #redis #caching #microservices #java #backend #mediumtÃ¼rkÃ§e #cacheable #cacheevict #cacheput</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=76b70fd9f3a4" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot UygulamanÄ±zda GÃ¶revleri Profesyonelce Zamanlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-uygulaman%C4%B1zda-g%C3%B6revleri-profesyonelce-zamanlama-b4f36acb4713?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/b4f36acb4713</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 06 May 2025 20:35:11 GMT</pubDate>
<atom:updated>2025-05-09T06:14:24.874Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/592/1*sUY-l0YENGLN7ogVR3VGmw.png" /></figure><p>YazÄ±lÄ±m dÃ¼nyasÄ±nda otomasyon, iÅŸlerin dÃ¼zgÃ¼n iÅŸlemesini saÄŸlamak iÃ§in kritik Ã¶neme sahiptir. GÃ¼nlÃ¼k raporlarÄ±n gÃ¶nderilmesi, geÃ§ici dosyalarÄ±n temizlenmesi ya da verilerin gÃ¼ncellenmesi gibi gÃ¶revler, Ã§oÄŸu uygulama iÃ§in hayati Ã¶neme sahip sÃ¼reÃ§lerdir.</p><p>EÄŸer <strong>Spring Boot</strong> kullanÄ±yorsanÄ±z, bu tÃ¼r gÃ¶revleri yÃ¶netmek iÃ§in gÃ¼Ã§lÃ¼ ve esnek bir araÃ§ setine sahipsiniz demektir. Bu yazÄ±da, Spring Bootâ€™ta gÃ¶rev zamanlamayÄ± (task scheduling) detaylÄ±ca inceleyecek, yaygÄ±n kullanÄ±m senaryolarÄ±nÄ± Ã¶rneklerle gÃ¶sterecek ve bulut tabanlÄ± alternatif Ã§Ã¶zÃ¼mlerle karÅŸÄ±laÅŸtÄ±rma yapacaÄŸÄ±z.</p><h3>ğŸ” Spring Scheduling Nedir?</h3><p>Spring Scheduling, Spring Frameworkâ€™Ã¼n iÃ§inde yer alan bir modÃ¼ldÃ¼r ve gÃ¶revlerin belirli aralÄ±klarla veya belli zamanlarda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlar. Hem basit hem de karmaÅŸÄ±k senaryolara uygun ÅŸekilde kullanÄ±labilen bu modÃ¼l, anotasyonlar ve API Ã¼zerinden programlanabilir.</p><p>Ã–rneÄŸin:</p><ul><li>Belirli saniye/saat/dakika aralÄ±klarÄ±yla Ã§alÄ±ÅŸan metodlar</li><li>Cron ifadeleri ile geliÅŸmiÅŸ zamanlamalar</li><li>Sabit gecikmelerle tekrar eden iÅŸlemler</li></ul><p>gibi birÃ§ok senaryoyu destekler.</p><h3>ğŸ› ï¸ Spring Boot Projenize Scheduling Eklemek</h3><p>Spring Boot ile ilk gÃ¶rev zamanlamasÄ±nÄ± kurmak oldukÃ§a kolaydÄ±r. Gerekli adÄ±mlar ÅŸu ÅŸekildedir:</p><h3>1. BaÄŸÄ±mlÄ±lÄ±k Ekleme</h3><p>Maven kullanÄ±yorsanÄ±z pom.xml dosyanÄ±za aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekleyin:</p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><blockquote><em>ğŸ’¡ Web starter zaten projede varsa eklemenize gerek yoktur.</em></blockquote><h3>2. Schedulingâ€™i Aktif Hale Getirme</h3><p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za @EnableScheduling anotasyonunu ekleyin:</p><pre>@SpringBootApplication<br>@EnableScheduling<br>public class MyApplication {</pre><pre> public static void main(String[] args) {<br> SpringApplication.run(MyApplication.class, args);<br> }<br>}</pre><p>Bu adÄ±m sayesinde Spring Boot, projedeki zamanlanmÄ±ÅŸ gÃ¶revleri tanÄ±r ve planlayÄ±cÄ±yÄ± baÅŸlatÄ±r.</p><h3>â±ï¸ Ä°lk ZamanlanmÄ±ÅŸ GÃ¶revinizi OluÅŸturun</h3><p>Basit bir Ã¶rnek olarak her 5 saniyede bir konsola mesaj yazan bir gÃ¶rev tanÄ±mlayalÄ±m:</p><pre>@Component<br>public class MyScheduledTasks {</pre><pre> @Scheduled(fixedRate = 5000)<br> public void logMessage() {<br> System.out.println(&quot;Bu mesaj 5 saniyede bir yazÄ±lÄ±r!&quot;);<br> }<br>}</pre><ul><li>@Component: Springâ€™in bu sÄ±nÄ±fÄ± bir bean olarak tanÄ±masÄ± iÃ§in gereklidir.</li><li>@Scheduled(fixedRate = 5000): Metodun 5000 milisaniyede (5 saniye) bir Ã§alÄ±ÅŸacaÄŸÄ±nÄ± belirtir.</li></ul><h3>ğŸ“Œ YaygÄ±n KullanÄ±m SenaryolarÄ±</h3><h3>ğŸ“§ E-posta Bildirimleri GÃ¶nderme</h3><p>Bir e-ticaret uygulamasÄ±nda, gÃ¼nlÃ¼k sipariÅŸ Ã¶zetlerini yÃ¶neticiye gÃ¶ndermek istiyorsanÄ±z:</p><pre>@Scheduled(cron = &quot;0 0 0 * * *&quot;)<br>public void sendDailyOrderSummary() {<br> List&lt;Order&gt; yesterdayOrders = orderRepository.findYesterdayOrders();<br> emailService.sendOrderSummary(yesterdayOrders);<br>}</pre><blockquote><em>cron = &quot;0 0 0 * * *&quot; ifadesi her gÃ¼n gece yarÄ±sÄ± Ã§alÄ±ÅŸtÄ±r anlamÄ±na gelir. Cron ifadeleri hakkÄ±nda daha fazla bilgi iÃ§in </em><a href="https://crontab.guru/"><em>crontab.guru</em></a><em> adresini ziyaret edebilirsiniz.</em></blockquote><h3>ğŸ—ƒï¸ Veri Yedekleme</h3><p>Veri gÃ¼venliÄŸiniz iÃ§in gece yarÄ±sÄ± bir veritabanÄ± yedeÄŸi almak istiyorsanÄ±z:</p><pre>@Scheduled(cron = &quot;0 0 2 * * *&quot;) // Her gÃ¼n saat 02:00&#39;de Ã§alÄ±ÅŸÄ±r<br>public void performDatabaseBackup() {<br> backupService.createBackup();<br>}</pre><h3>ğŸ§¹ Cache Temizleme</h3><p>Cache performansÄ±nÄ± artÄ±rmak iÃ§in dÃ¼zenli olarak eski verileri temizleyebilirsiniz:</p><pre>@Scheduled(fixedRate = 3600000) // Her saat baÅŸÄ±<br>public void evictCache() {<br> cacheManager.getCache(&quot;myCache&quot;).clear();<br>}</pre><h3>ğŸšš Arka Plan Ä°ÅŸleri (Task Queue)</h3><p>GÃ¶rev kuyruklarÄ±nÄ± periyodik olarak kontrol etmek iÃ§in:</p><pre>@Scheduled(fixedDelay = 10000)<br>public void processTasks() {<br> while (taskQueue.hasTasks()) {<br> Task task = taskQueue.dequeue();<br> taskProcessor.process(task);<br> }<br>}</pre><h3>ğŸ©º Sistem SaÄŸlÄ±ÄŸÄ± KontrolÃ¼</h3><p>UygulamanÄ±zdaki sistem saÄŸlÄ±ÄŸÄ±nÄ± dÃ¼zenli olarak denetlemek iÃ§in:</p><pre>@Scheduled(fixedRate = 60000)<br>public void checkSystemHealth() {<br> if (!healthCheckService.isHealthy()) {<br> alertService.sendAlert(&quot;Sistemde bir hata tespit edildi!&quot;);<br> }<br>}</pre><h3>â˜ï¸ Spring Scheduling vs Bulut Ã‡Ã¶zÃ¼mleri</h3><blockquote><em>ğŸ“Œ EÄŸer mikroservis tabanlÄ±, yÃ¼ksek Ã¶lÃ§eklenebilirlik gerektiren bir mimariniz varsa, AWS Lambda veya Azure Functions gibi bulut Ã§Ã¶zÃ¼mleri daha mantÄ±klÄ± olabilir.</em></blockquote><h3>ğŸ§  Ä°leri Seviye KullanÄ±m: DaÄŸÄ±tÄ±k Ortamda GÃ¶rev Zamanlama</h3><p>Diyelim ki mikroservis tabanlÄ± bir yapÄ± kuruyorsunuz ve birden fazla servis Ã¶rneÄŸinde gÃ¶revleri koordine etmeniz gerekiyor. Ä°ÅŸte bu noktada Spring Bootâ€™u AWS hizmetleriyle birleÅŸtirerek gÃ¼Ã§lÃ¼ bir Ã§Ã¶zÃ¼m oluÅŸturabilirsiniz.</p><h3>ğŸ¯ Problem TanÄ±mÄ±</h3><ul><li>Birden fazla servis Ã¶rneÄŸinde gÃ¶revlerin eÅŸ zamanlÄ± Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±</li><li>Hata toleransÄ± (bir servis Ã§akarsa diÄŸerinin devralmasÄ±)</li><li>Merkezi izleme ve yÃ¶netim</li></ul><h3>âœ… Ã‡Ã¶zÃ¼m</h3><h4>1. GÃ¶rev TanÄ±mÄ±â€Šâ€”â€ŠSpring @Scheduled + @Component</h4><p>Her serviste gÃ¶revler standart Spring anotasyonlarÄ±yla tanÄ±mlanÄ±r:</p><pre>@Scheduled(cron = &quot;0 */5 * * * *&quot;)<br>public void myDistributedTask() {<br> if (lockService.acquireLock(&quot;myDistributedTask&quot;)) { <br> try {<br> // GerÃ§ek gÃ¶rev iÅŸlemleri<br> } finally {<br> lockService.releaseLock(&quot;myDistributedTask&quot;); <br> }<br> }<br>}</pre><h4>2. DaÄŸÄ±tÄ±k Kilitlemeâ€Šâ€”â€ŠDynamoDB</h4><p>Amazon DynamoDBâ€™nin atomic counter Ã¶zelliÄŸini kullanarak daÄŸÄ±tÄ±k kilit mekanizmasÄ± uygulanabilir. BÃ¶ylece aynÄ± anda sadece bir instance gÃ¶revi Ã§alÄ±ÅŸtÄ±rÄ±r.</p><h4>3. GÃ¶rev KuyruÄŸuâ€Šâ€”â€ŠAmazon SQS</h4><p>GÃ¶revler doÄŸrudan deÄŸil, bir kuyruÄŸa gÃ¶nderilir. Bu sayede gÃ¶rev zamanlama ile yÃ¼rÃ¼tme ayrÄ±lmÄ±ÅŸ olur:</p><pre>@Scheduled(cron = &quot;0 */5 * * * *&quot;)<br>public void scheduleMyTask() {<br> taskQueue.enqueue(&quot;myDistributedTask&quot;, taskData); <br>}</pre><h4>4. Worker Processâ€Šâ€”â€ŠMikroservis Ã–rneklerinde Ã‡alÄ±ÅŸtÄ±rÄ±cÄ±</h4><p>Her mikroservis Ã¶rneÄŸi, SQS kuyruÄŸundan gÃ¶rev alÄ±p iÅŸler:</p><pre>@Component<br>public class TaskWorker {</pre><pre> @Autowired<br> private TaskProcessor taskProcessor;</pre><pre> @Scheduled(fixedDelay = 5000)<br> public void processTasks() {<br> Message message = taskQueue.receiveMessage(); <br> if (message != null) {<br> String taskType = message.getAttribute(&quot;taskType&quot;);<br> String taskData = message.getBody(); <br> taskProcessor.process(taskType, taskData);<br> taskQueue.deleteMessage(message); <br> }<br> }<br>}</pre><h4>5. Ä°zlemeâ€Šâ€”â€ŠAmazon CloudWatch</h4><p>SQS kuyruÄŸu uzunluÄŸu, gÃ¶rev sÃ¼resi ve hatalar merkezi olarak CloudWatch ile izlenebilir.</p><h3>âœ… Bu YaklaÅŸÄ±mÄ±n AvantajlarÄ±</h3><ul><li><strong>Yatay Ã–lÃ§eklenebilirlik:</strong> Servis Ã¶rnekleri artÄ±rÄ±ldÄ±kÃ§a sistem aksamadan Ã§alÄ±ÅŸmaya devam eder.</li><li><strong>YÃ¼ksek KullanÄ±labilirlik:</strong> Bir servis dÃ¼ÅŸerse diÄŸeri gÃ¶revi devralÄ±r.</li><li><strong>Kolay YÃ¶netim:</strong> GÃ¶revler merkezi olarak takip edilir ve yÃ¶netilir.</li></ul><h3>ğŸ§­ SonuÃ§</h3><p>Spring Bootâ€™un @Scheduled anotasyonu ve @EnableScheduling desteÄŸi, uygulamanÄ±zdaki gÃ¶revleri zamanlamak iÃ§in gÃ¼Ã§lÃ¼ ve esnek bir yÃ¶ntem sunar. Basit senaryolardan ileri dÃ¼zey daÄŸÄ±tÄ±k yapÄ±lara kadar geniÅŸ bir yelpazede kullanÄ±labilir.</p><p>Ancak, Ã¶zellikle mikroservis tabanlÄ±, yÃ¼ksek Ã¶lÃ§eklenebilirlik gerektiren sistemlerde AWS Lambda, Azure Functions gibi bulut tabanlÄ± Ã§Ã¶zÃ¼mler tercih edilebilir.</p><p>Ä°leri seviye bir mimaride Spring Boot + AWS entegrasyonu ile saÄŸlam, Ã¶lÃ§eklenebilir ve izlenebilir bir gÃ¶rev zamanlama sistemi kurmak mÃ¼mkÃ¼ndÃ¼r. Bu yaklaÅŸÄ±mlarÄ± projelerinize adapte ederek hem performans hem de bakÄ±m kolaylÄ±ÄŸÄ± saÄŸlayabilirsiniz.</p><p>ğŸ¯ <strong>Bonus Tip:</strong><br>Cron ifadeleri karmaÅŸÄ±k olabilir. Test etmeden Ã¶nce mutlaka <a href="https://crontab.guru/">crontab.guru</a> gibi araÃ§larla doÄŸrulayÄ±n!</p><p>ğŸ” <strong>Daha FazlasÄ± Ä°Ã§in:</strong></p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html">Spring Documentationâ€Šâ€”â€ŠScheduling Tasks</a></li><li><a href="https://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html">AWS Lambda with Scheduled Events</a></li><li><a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer">Azure Timer Triggered Functions</a></li></ul><p>EÄŸer bu yazÄ± hoÅŸunuza gittiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± ya da Ã¶nerilerinizi yorumlarda bekliyorum. ğŸ˜Š</p><p>#springboot #scheduling #microservices #aws #java #backend</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b4f36acb4713" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
</channel>
</rss>