<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html" version="2.0" class="hidden">
<link type="text/css" id="dark-mode" rel="stylesheet" href=""/>
<style type="text/css" id="dark-mode-Ñustom-style"/>
<style type="text/css" id="dark-mode-theme-changer-style"/>
<channel>
<title>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</title>
<description>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</description>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
<image>
<url>https://cdn-images-1.medium.com/fit/c/150/150/0*B8-_pQzPr4S4bxYR</url>
<title>Stories by Mert Pehlivan on Medium</title>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
</image>
<generator>Medium</generator>
<lastBuildDate>Fri, 11 Jul 2025 11:16:14 GMT</lastBuildDate>
<atom:link href="https://medium.com/@pehlivanmert/feed" rel="self" type="application/rss+xml"/>
<webMaster>
<![CDATA[ yourfriends@medium.com ]]>
</webMaster>
<atom:link href="http://medium.superfeedr.com" rel="hub"/>
<item>
<title>
<![CDATA[ Evrenin Kalbine Yolculuk Åimdi BaÅŸlÄ±yor! ]]>
</title>
<link>https://pehlivanmert.medium.com/evrenin-kalbine-yolculuk-%C5%9Fimdi-ba%C5%9Fl%C4%B1yor-f2e72e00b43b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/f2e72e00b43b</guid>
<category>
<![CDATA[ astronomy ]]>
</category>
<category>
<![CDATA[ technology ]]>
</category>
<category>
<![CDATA[ cosmos ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 11 Jul 2025 11:14:05 GMT</pubDate>
<atom:updated>2025-07-11T11:14:05.015Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M7tL7VAJP2FrlB9xCOS1WQ.jpeg" /></figure><p>Ã‡ocukluÄŸumdan beri, iÃ§imde hiÃ§ susturamadÄ±ÄŸÄ±m, <em>The Big Bang Theory</em>â€™deki Sheldon Cooperâ€™Ä± aratmayan bir ses var. Her ÅŸeye â€œNeden?â€ diye soran, evrenin en temelinden en karmaÅŸÄ±ÄŸÄ±na her detayÄ± merak eden bir ses. O ses, Ã¶zellikle geceleri gÃ¶kyÃ¼zÃ¼yle baÅŸ baÅŸa kaldÄ±ÄŸÄ±mda daha da yÃ¼kselir. O pÄ±rÄ±l pÄ±rÄ±l noktalarÄ±n her biri, aklÄ±mÄ±n sÄ±nÄ±rlarÄ±nÄ± zorlayan mesafelerin ve olasÄ±lÄ±klarÄ±n birer temsilcisi gibi gelir. Zihnimde hep aynÄ± temel sorular yankÄ±lanÄ±r: â€œBiz kimiz? Bu akÄ±l almaz bÃ¼yÃ¼klÃ¼kteki kozmik okyanusta bir anlamÄ±mÄ±z var mÄ±?â€</p><p>Ä°ÅŸte bu sorularÄ±n tam ortasÄ±nda, insanlÄ±k tarihine yeni bir sayfa ekleniyor ve ben bu anÄ±n bir ÅŸahidi olmaktan dolayÄ± iliklerime kadar heyecanlÄ±yÄ±m. Vera C. Rubin GÃ¶zlemevi faaliyete geÃ§ti. Bu, sadece cam ve metalden oluÅŸmuÅŸ bir teleskop deÄŸil; insanlÄ±ÄŸÄ±n bitmek bilmeyen merakÄ±nÄ±n, azminin ve bilme arzusunun Åiliâ€™nin And DaÄŸlarÄ±â€™na dikilmiÅŸ devasa bir anÄ±tÄ±.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*k3xTQSn7jJa-4-MY5VOHcw.jpeg" /></figure><p>Ve beklenen an geldi. 23 Haziran 2025&#39;te gelen ilk test gÃ¶rÃ¼ntÃ¼leriâ€¦ â€œVay beâ€ demekten baÅŸka bir kelime bulamadÄ±m. Uzak bir nebulanÄ±n ipliksi gaz bulutlarÄ±ndan, iki galaksinin birbirinin iÃ§ine girdiÄŸi o ÅŸiddetli kozmik dansa kadar her ÅŸey, daha Ã¶nce hiÃ§ gÃ¶rmediÄŸimiz bir netlikteydi. Bu gÃ¶rÃ¼ntÃ¼ler, sadece bilim camiasÄ±nda deÄŸil, benim gibi dÃ¼nyanÄ±n dÃ¶rt bir yanÄ±ndaki sayÄ±sÄ±z meraklÄ± ruhta da evrensel bir coÅŸku yarattÄ±. Bu, 10 yÄ±llÄ±k bÃ¼yÃ¼k filmin sadece fragmanÄ±ydÄ± ama ÅŸimdiden milyonlarca galaksiyi, binlerce asteroidi ve kendi galaksimizdeki sayÄ±sÄ±z yÄ±ldÄ±zÄ± bizlere sundu. Bu, basit bir teknik baÅŸarÄ±dan Ã§ok Ã¶te; hepimizi birbirimize baÄŸlayan o ortak merakÄ±n, bilginin peÅŸindeki kolektif yolculuÄŸun somut bir baÅŸlangÄ±cÄ±.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DmJrhxP3XpQfRxPo-M1ARg.jpeg" /></figure><h4>Evrenin Perdesini Aralamak, Rubin Neyi DeÄŸiÅŸtirecek?</h4><p>Bu ilk etkileyici anlar, aslÄ±nda Ã§ok daha bÃ¼yÃ¼k bir hikayenin sadece ilk cÃ¼mlesi. Rubinâ€™in asÄ±l devrimi, bize statik fotoÄŸraflar sunmasÄ± deÄŸil; evrenin yaÅŸayan, nefes alan, dinamik hikayesini anlatacak olmasÄ±. Bize evrenin sandÄ±ÄŸÄ±mÄ±zdan Ã§ok daha aktif ve canlÄ± olduÄŸunu gÃ¶sterecek on yÄ±llÄ±k bir maraton baÅŸlÄ±yor.</p><p><strong>GerÃ§eÄŸin Dokusunu Anlamaya Ã‡alÄ±ÅŸacaÄŸÄ±z:</strong> En bÃ¼yÃ¼k hedef, evrenin yaklaÅŸÄ±k %95&#39;ini oluÅŸturan ama hakkÄ±nda neredeyse hiÃ§bir ÅŸey bilmediÄŸimiz o gizemli karanlÄ±k madde ve karanlÄ±k enerji. Isaac Asimovâ€™un <em>VakÄ±f</em> serisinde, bir galaktik imparatorluÄŸun geleceÄŸini matematiksel olarak Ã¶ngÃ¶ren â€œPsikotarihâ€ bilimini okuduÄŸumda hayran kalmÄ±ÅŸtÄ±m. Åimdi Rubin, sanki gerÃ§ek bir VakÄ±f projesinin ilk adÄ±mlarÄ±nÄ± atÄ±yor. Evrenin gÃ¶rÃ¼nmez gÃ¼Ã§lerini haritalayarak, kozmosun nihai kaderini anlamaya Ã§alÄ±ÅŸacak. Bu, sadece bir katalog oluÅŸturmak deÄŸil; gerÃ§eÄŸin temel dokusunu, belki de henÃ¼z bilmediÄŸimiz fizik yasalarÄ±nÄ± anlama yolunda felsefi bir sÄ±Ã§rama.</p><p><strong>Kozmik KomÅŸularÄ±mÄ±zÄ± TanÄ±yacaÄŸÄ±z:</strong> GÃ¶zlemevi, kendi GÃ¼neÅŸ Sistemiâ€™mizin de detaylÄ± bir envanterini Ã§Ä±karacak. TÄ±pkÄ± <em>Star Wars</em>â€™ta gemilerin gÃ¼venli rotalar iÃ§in detaylÄ± yÄ±ldÄ±z haritalarÄ±na ihtiyaÃ§ duymasÄ± gibi, biz de kendi mahallemizdeki tehlikeli asteroitleri ve buzlu cisimleri tanÄ±mak zorundayÄ±z. Bu, gezegenimizin gÃ¼venliÄŸi iÃ§in bir erken uyarÄ± sistemi kurmak anlamÄ±na geliyor ve gÃ¶kbilimin soyut merakÄ±nÄ±n Ã¶tesinde, insanlÄ±k iÃ§in ne kadar somut faydalar saÄŸlayabileceÄŸinin en gÃ¼zel kanÄ±tÄ±.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F7gGltfcBUtQ%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D7gGltfcBUtQ&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F7gGltfcBUtQ%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/c179c2fc59b9191d03c343ea80b4ec7d/href">https://medium.com/media/c179c2fc59b9191d03c343ea80b4ec7d/href</a></iframe><p><strong>Evrenin CanlÄ± YayÄ±nÄ±:</strong> Evren sÃ¼rekli deÄŸiÅŸiyor. YÄ±ldÄ±zlar patlÄ±yor (sÃ¼pernovalar), devasa enerji patlamalarÄ± yaÅŸanÄ±yor. Rubinâ€™in en sevdiÄŸim yanlarÄ±ndan biri de bu anlÄ±k olaylarÄ± inanÄ±lmaz bir hÄ±zla tespit edecek olmasÄ±. Her gece deÄŸiÅŸen veya yeni beliren nesneler iÃ§in yaklaÅŸÄ±k 10 milyon uyarÄ± yayÄ±nlayacak. Bu, dÃ¼nyanÄ±n dÃ¶rt bir yanÄ±ndaki diÄŸer teleskoplarÄ±n o noktaya dÃ¶nÃ¼p olayÄ± detaylÄ± incelemesi iÃ§in bir â€œkozmik alarmâ€ sistemi demek. Bu sayede, yÄ±ldÄ±zlarÄ±n nasÄ±l Ã¶ldÃ¼ÄŸÃ¼nÃ¼, aÄŸÄ±r elementlerin evrene nasÄ±l yayÄ±ldÄ±ÄŸÄ±nÄ± ve fiziÄŸin en uÃ§ koÅŸullarÄ±nÄ± canlÄ± canlÄ± izleyebileceÄŸiz.</p><p><strong>Kendi Kozmik KÃ¶kenimiz:</strong> Ve tabii ki evimiz, Samanyoluâ€¦ Milyarlarca yÄ±ldÄ±zÄ± tek tek gÃ¶zlemleyerek galaksimizin nasÄ±l oluÅŸtuÄŸunu, hangi kadim galaksileri yutarak bÃ¼yÃ¼dÃ¼ÄŸÃ¼nÃ¼ ve bugÃ¼nkÃ¼ yapÄ±sÄ±na nasÄ±l ulaÅŸtÄ±ÄŸÄ±nÄ± bir arkeolog gibi katman katman ortaya Ã§Ä±karacak. Asimovâ€™un Robot serilerinden galaksi tarihine uzanan o bÃ¼yÃ¼k anlatÄ±larÄ± gibi, biz de kendi kozmik soy aÄŸacÄ±mÄ±zÄ±, nereden geldiÄŸimizin hikayesini anlama fÄ±rsatÄ± bulacaÄŸÄ±z.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eXtV-V8of2Si33X4n3Fa9A.jpeg" /></figure><h4>ZamanÄ±n Ã–tesinde Bir Film, Evrenin CanlÄ± Portresi</h4><p>Rubinâ€™in Ã§alÄ±ÅŸma prensibi, benim gibi teknolojiyle iÃ§ iÃ§e olan birini ayrÄ±ca heyecanlandÄ±rÄ±yor. Projenin kalbinde, 3.2 gigapiksel Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼yle dÃ¼nyanÄ±n en bÃ¼yÃ¼k dijital kamerasÄ± olan LSST KamerasÄ± var. Tek bir gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ tam Ã§Ã¶zÃ¼nÃ¼rlÃ¼kte gÃ¶rebilmek iÃ§in 400 tane 4K televizyon ekranÄ±nÄ± bir araya getirmeniz gerekiyor! Bu canavar, her 40 saniyede bir gÃ¶kyÃ¼zÃ¼nÃ¼n devasa bir bÃ¶lÃ¼mÃ¼nÃ¼ Ã§ekerek, her Ã¼Ã§ gecede bir aynÄ± noktayÄ± tekrar ziyaret edecek. On yÄ±l boyunca bunu yaptÄ±ÄŸÄ±nda, elimizde evrenin daha Ã¶nce hiÃ§ Ã§ekilmemiÅŸ, zaman atlamalÄ± bir filmi olacak.</p><p>Bunu, gÃ¶kyÃ¼zÃ¼ne bakan bir â€œaraÃ§ kamerasÄ±â€ gibi dÃ¼ÅŸÃ¼nÃ¼n. EÄŸer bir yÄ±ldÄ±z aniden patlarsa veya tuhaf bir nesne belirip kaybolursa, kaydÄ± geri sarÄ±p o olaya neyin sebep olduÄŸunu, Ã¶ncesinde neler yaÅŸandÄ±ÄŸÄ±nÄ± gÃ¶rebileceÄŸiz. Bu, gÃ¶kbilimi adeta bir tÃ¼r â€œkozmik adli bilimeâ€ dÃ¶nÃ¼ÅŸtÃ¼rÃ¼yor.</p><p>Tabii bu gÃ¶revin getirdiÄŸi veri yÃ¼kÃ¼ de akÄ±l almaz boyutlarda. Her gece 20 terabayt, on yÄ±lÄ±n sonunda ise iÅŸlenmiÅŸ haliyle 500 petabaytlÄ±k bir veri arÅŸiviâ€¦ Bu, insanlÄ±k tarihi boyunca yazÄ±lmÄ±ÅŸ tÃ¼m metinlerin toplamÄ±ndan katbekat fazla. Bu veri selini yÃ¶netmek, iÅŸlemek ve anlamlandÄ±rmak iÃ§in geliÅŸtirilen algoritmalar, yapay zeka Ã§Ã¶zÃ¼mleri ve hesaplama altyapÄ±larÄ±, sadece astronomiyi deÄŸil, veri biliminin geleceÄŸini de ÅŸekillendiriyor.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9z7DiT5mMSHkGbpcYyfSZg.jpeg" /></figure><h4>GÃ¶rmediÄŸimiz Ne Varsa, Bilinmeyene AtÄ±lan AdÄ±m</h4><p>Belki de tÃ¼m bunlarÄ±n en heyecan verici yanÄ±, ne bulmayÄ± umduÄŸumuz deÄŸil, ne bulacaÄŸÄ±mÄ±zÄ± hayal bile edemediÄŸimiz ÅŸeyler. Bilim tarihi, en bÃ¼yÃ¼k devrimlerin beklenmedik keÅŸiflerle yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶sterir. Benim her ÅŸeye olan bitmez tÃ¼kenmez merakÄ±m da buradan geliyor. DoÄŸada bir aÄŸacÄ±n dallanmasÄ±ndan bir nehrin yataÄŸÄ±na, teknolojide bir otomasyon sisteminden kadim bilgilerin iÃ§erdiÄŸi desenlere kadar her yerde bir dÃ¼zen, bir mantÄ±k ararÄ±m. Rubin, iÅŸte bu arayÄ±ÅŸÄ± evrensel boyuta taÅŸÄ±yor. â€˜Oumuamua gibi yÄ±ldÄ±zlararasÄ± sistemimizden geÃ§en o gizemli ziyaretÃ§ileri hatÄ±rlayÄ±n. Rubin, bu tÃ¼rden yÃ¼zlerce, belki de binlerce nesne bulabilir. Belki de bazÄ±larÄ±, evren hakkÄ±ndaki en temel varsayÄ±mlarÄ±mÄ±zÄ± sorgulamamÄ±za neden olacak.</p><p>Bu proje, sadece teknik sorularÄ± deÄŸil, en derin felsefi sorularÄ±mÄ±zÄ± da besliyor. Nereden geldik? Nereye gidiyoruz? Bu sonsuzlukta yalnÄ±z mÄ±yÄ±z? Rubin bu sorulara kesin cevaplar vermeyebilir, ama bize Ã¶yle veriler sunacak ki, bu sorulara vereceÄŸimiz cevaplar hiÃ§ olmadÄ±ÄŸÄ± kadar temellendirilmiÅŸ olacak.</p><h4>Bu Yolculuk Hepimizin</h4><p>Bu projenin en takdir ettiÄŸim yÃ¶nlerinden biri de ÅŸeffaflÄ±ÄŸÄ±. Elde edilen tÃ¼m bu devasa veri hazinesi, dÃ¼nyanÄ±n dÃ¶rt bir yanÄ±ndaki bilim insanlarÄ±na ve hatta meraklÄ± amatÃ¶rlere aÃ§Ä±k olacak. Bu, sanki <em>Star Wars</em>â€™taki Jedi ArÅŸivleriâ€™nin kapÄ±larÄ±nÄ± tÃ¼m galaksiye aÃ§mak gibi bir ÅŸey. KeÅŸif, artÄ±k kÃ¼Ã§Ã¼k bir elit zÃ¼mrenin tekelinde olmayacak. Bu, keÅŸfin demokratikleÅŸmesi demek. Kim bilir, belki de bir sonraki bÃ¼yÃ¼k keÅŸif, hiÃ§ beklenmedik bir Ã¼lkeden, genÃ§ bir Ã¶ÄŸrencinin bu verileri incelerken fark edeceÄŸi bir anomali sayesinde gelir.</p><p><a href="https://rubinobservatory.org/gallery/collections/first-look-gallery/cprq3ebjj15brf1ueomd1brb5q">The Cosmic Treasure Chest (Video-EN)</a></p><p>Bir bilim insanÄ±nÄ±n dediÄŸi gibi, â€œBu veri seti, muhtemelen ben Ã¶ldÃ¼kten sonra bile hala geÃ§erli olacak.â€ Bu cÃ¼mle, projenin bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ Ã¶zetliyor. Bizler, gelecek nesillerin Ã¼zerinde sayÄ±sÄ±z keÅŸif inÅŸa edeceÄŸi bir kozmik kÃ¼tÃ¼phanenin, bir evren atlasÄ±nÄ±n yaratÄ±lÄ±ÅŸÄ±na tanÄ±klÄ±k ediyoruz.</p><p>Bu yÃ¼zden gÃ¶zlerimi gÃ¶kyÃ¼zÃ¼ne diktim. Ã‡Ã¼nkÃ¼ artÄ±k oraya baktÄ±ÄŸÄ±mda sadece parlayan noktalar deÄŸil, kapÄ±larÄ± ardÄ±na kadar aÃ§Ä±lan bir olasÄ±lÄ±klar evreni gÃ¶rÃ¼yorum. <strong>Ve bu yolculukta hep birlikteyiz. Bu, benim iÃ§in en bÃ¼yÃ¼k heyecan kaynaÄŸÄ±.</strong></p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f2e72e00b43b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Kariyer YolculuÄŸunda Zaman ve YÃ¶n AlgÄ±sÄ±: TÃ¼rkiye, Avrupa ve Amerika KÄ±yaslamasÄ± ]]>
</title>
<link>https://pehlivanmert.medium.com/kariyer-yolculu%C4%9Funda-zaman-ve-y%C3%B6n-alg%C4%B1s%C4%B1-t%C3%BCrkiye-avrupa-ve-amerika-k%C4%B1yaslamas%C4%B1-9a80d2966556?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/9a80d2966556</guid>
<category>
<![CDATA[ careers ]]>
</category>
<category>
<![CDATA[ development ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 24 Jun 2025 11:50:48 GMT</pubDate>
<atom:updated>2025-06-25T06:25:49.737Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bS7237XkM9wBG19exPV0Xg.jpeg" /><figcaption>Photo by Javier Allegue Barros on Unsplash</figcaption></figure><p>Kariyer, bireylerin yaÅŸam boyu sÃ¼ren bir yolculuÄŸu olarak kabul edilir; ancak bu yolculuÄŸun hÄ±zÄ± ve yÃ¶nÃ¼, iÃ§inde bulunulan kÃ¼ltÃ¼rel ve ekonomik koÅŸullara gÃ¶re bÃ¼yÃ¼k farklÄ±lÄ±klar gÃ¶sterir. TÃ¼rkiyeâ€™de gÃ¶zlemlenen â€œhemen Ã¼niversiteye git, hemen iÅŸ bul ya da hemen master yap, hemen iÅŸ bulâ€ gibi bir â€œkoÅŸturmacaâ€ hali, birÃ§ok genÃ§ profesyonelin deneyimlediÄŸi yaygÄ±n bir baskÄ±dÄ±r. Bu durum, Ã¶zellikle 30&#39;lu yaÅŸlara gelindiÄŸinde kariyerde â€œgeÃ§ kalmÄ±ÅŸlÄ±kâ€ hissi yaratabilir, sektÃ¶r deÄŸiÅŸimleri garip karÅŸÄ±lanabilir ve alaylÄ± (otodidakt) kiÅŸilere yetersiz gÃ¶zÃ¼yle bakÄ±labilir. Oysa Avrupa ve Amerikaâ€™da durumun daha farklÄ± olduÄŸu, insanlarÄ±n bu kadar acele etmediÄŸi ve kariyer yollarÄ±nÄ±n daha esnek olduÄŸu gÃ¶zlemlenmektedir. Bu rapor, sÃ¶z konusu kÃ¼ltÃ¼rel farklÄ±lÄ±klarÄ±, kariyer algÄ±sÄ±ndaki zihniyet yapÄ±larÄ±nÄ± derinlemesine inceleyerek, genÃ§lere ve 30&#39;lu yaÅŸlardaki profesyonellere ilham ve cesaret vermeyi amaÃ§lamaktadÄ±r.</p><h3>TÃ¼rkiyeâ€™deki Kariyer KoÅŸturmacasÄ±: Neden Bu Kadar Acele Ediyoruz?</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uzW9SPfwtrlE3PDcXzY1ag.png" /></figure><p>TÃ¼rkiyeâ€™deki kariyer yolculuÄŸunun hÄ±zlÄ± ve baskÄ±cÄ± doÄŸasÄ±, kÃ¶klÃ¼ sosyo-ekonomik ve kÃ¼ltÃ¼rel faktÃ¶rlerden beslenmektedir. Bu durum, bireyler Ã¼zerinde erken yaÅŸta baÅŸarÄ±ya ulaÅŸma ve geleneksel kariyer yollarÄ±ndan sapmama yÃ¶nÃ¼nde yoÄŸun bir baskÄ± oluÅŸturur.</p><p>Ãœlkedeki genÃ§ iÅŸsizliÄŸi oranlarÄ±, bu koÅŸturmacanÄ±n temel nedenlerinden biridir. TÃ¼rkiyeâ€™de 15â€“24 yaÅŸ arasÄ± genÃ§ iÅŸsizlik oranÄ±, 2019&#39;da %25,4 iken, 2020&#39;de %25,3 olarak kaydedilmiÅŸtir. Bu oran, dÃ¼nya ortalamasÄ±nÄ±n yaklaÅŸÄ±k iki katÄ±dÄ±r ve uzun sÃ¼reli, yapÄ±sal nedenlere dayanmaktadÄ±r. Ã–zellikle yÃ¼ksekÃ¶ÄŸretim mezunlarÄ± arasÄ±nda iÅŸsizlik oranÄ± daha da yÃ¼ksektir; 2020 yÄ±lÄ±nda bu oran %35,8&#39;e ulaÅŸmÄ±ÅŸtÄ±r. Bu veriler, eÄŸitim sisteminin Ã§Ä±ktÄ±sÄ± ile iÅŸgÃ¼cÃ¼ piyasasÄ±nÄ±n talepleri arasÄ±nda Ã¶nemli bir uyumsuzluk olduÄŸunu gÃ¶stermektedir.</p><p>Bu uyumsuzluk ve yÃ¼ksek iÅŸsizlik, bireyleri bir an Ã¶nce herhangi bir iÅŸe girme konusunda savunmacÄ± bir strateji benimsemeye iter. Ä°ÅŸgÃ¼cÃ¼ piyasasÄ± doygunlaÅŸtÄ±ÄŸÄ±nda ve fÄ±rsatlar kÄ±sÄ±tlÄ± olduÄŸunda, erken istihdam gÃ¼vencesi hayati bir Ã¶nem kazanÄ±r. Bu durum, kariyer keÅŸfi iÃ§in zaman ayÄ±rmanÄ±n veya geÃ§ yaÅŸta sektÃ¶r deÄŸiÅŸtirmenin lÃ¼ks, hatta bir risk olarak algÄ±lanmasÄ±na yol aÃ§ar ve â€œgeÃ§ kalmÄ±ÅŸlÄ±kâ€ hissine katkÄ±da bulunur.</p><p>TÃ¼rkiyeâ€™deki kÃ¼ltÃ¼rel yapÄ± da bu durumu pekiÅŸtirmektedir. DoÄŸu kÃ¼ltÃ¼rlerinde yaygÄ±n olan â€œkadercilikâ€ anlayÄ±ÅŸÄ± , bireylerin kariyer planlamasÄ±na ve risk alma eÄŸilimlerine etki edebilir. â€œHer ÅŸey olacaÄŸÄ±na varÄ±râ€ gibi bir dÃ¼ÅŸÃ¼nce, proaktif kariyer deÄŸiÅŸimlerini veya geleneksel olmayan Ã¶ÄŸrenme yollarÄ±nÄ±, Ã¶nceden belirlenmiÅŸ bir akÄ±ÅŸa karÅŸÄ± gelmek olarak yorumlanmasÄ±na neden olabilir. Bu, Ã¶zellikle toplumsal onay ve grup istikrarÄ±nÄ±n Ã¶n planda olduÄŸu kolektivist deÄŸerlerle birleÅŸtiÄŸinde , kariyer deÄŸiÅŸikliklerinin â€œgarip karÅŸÄ±lanmasÄ±â€ veya alaylÄ± kiÅŸilerin â€œyetersiz gÃ¶zÃ¼yle bakÄ±lmasÄ±â€ gibi algÄ±larÄ± gÃ¼Ã§lendirebilir. Toplumun ve ailenin beklentileri, bireyin geleneksel â€œgÃ¼venliâ€ yolu (Ã¼niversite, istikrarlÄ± bir iÅŸ) takip etmesini teÅŸvik eder.</p><p>30&#39;lu yaÅŸlarda hissedilen â€œgeÃ§ kalmÄ±ÅŸlÄ±k sendromuâ€ da bu baÄŸlamda ortaya Ã§Ä±kar. Toplumsal baskÄ±, baÅŸarÄ±sÄ±zlÄ±k korkusu ve belirli yaÅŸlara kadar belirli kariyer ve kiÅŸisel hedeflere (evlilik, Ã§ocuk sahibi olma gibi) ulaÅŸma beklentisi, bu yaÅŸ grubundaki bireylerde yoÄŸun bir kaygÄ±ya neden olabilir. Ãœlkenin ekonomik performansÄ±na yÃ¶nelik olumsuz algÄ±lar da bu kariyer kaygÄ±sÄ±nÄ± artÄ±rarak, bireyleri daha da hÄ±zlÄ± hareket etmeye itebilir.</p><p>AÅŸaÄŸÄ±daki tablo, TÃ¼rkiyeâ€™deki genÃ§ iÅŸsizliÄŸi ve NEET oranlarÄ±nÄ±n (Ne EÄŸitimde Ne Ä°stihdamda Olan GenÃ§ler) bu baskÄ±nÄ±n somut gÃ¶stergelerini sunmaktadÄ±r:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PYMWLdeUuokbqcivcXMDsw.png" /></figure><p>Bu veriler, TÃ¼rkiyeâ€™de kariyer baÅŸlangÄ±cÄ±ndaki hÄ±z beklentisinin ve erken kariyer baskÄ±sÄ±nÄ±n, yÃ¼ksek genÃ§ iÅŸsizliÄŸi ve eÄŸitim-istihdam uyumsuzluÄŸu gibi yapÄ±sal sorunlardan kaynaklandÄ±ÄŸÄ±nÄ± aÃ§Ä±kÃ§a ortaya koymaktadÄ±r.</p><h3>Avrupa ve Amerikaâ€™da Kariyer Yolu: Esneklik ve Uzun Vadeli BakÄ±ÅŸ</h3><p>Avrupa ve Amerikaâ€™daki kariyer kÃ¼ltÃ¼rÃ¼, TÃ¼rkiyeâ€™deki â€œkoÅŸturmacaâ€ algÄ±sÄ±nÄ±n aksine, genellikle daha esnek ve uzun vadeli bir perspektif sunmaktadÄ±r. Bu bÃ¶lgelerde, kariyer yollarÄ± daha az katÄ± Ã§izgilere sahiptir ve bireylerin yaÅŸam boyu Ã¶ÄŸrenme, kariyer molalarÄ± veya orta yaÅŸta sektÃ¶r deÄŸiÅŸiklikleri yapmalarÄ± daha fazla kabul gÃ¶rmektedir.</p><p>Bu esnekliÄŸin arkasÄ±nda yatan Ã¶nemli bir faktÃ¶r, demografik deÄŸiÅŸimlerdir. Avrupaâ€™da 55â€“64 yaÅŸ arasÄ± AvrupalÄ±larÄ±n istihdam oranÄ± 2010&#39;dan 2023&#39;e kadar yaklaÅŸÄ±k 20 puan artarak %45&#39;ten %64,5&#39;e yÃ¼kselmiÅŸtir. AB iÅŸgÃ¼cÃ¼nde 55 yaÅŸ ve Ã¼zeri kiÅŸilerin payÄ± 2004&#39;te %12 iken 2019&#39;da %20&#39;ye Ã§Ä±kmÄ±ÅŸtÄ±r. Bu durum, yaÅŸlanan iÅŸgÃ¼cÃ¼nÃ¼n ekonomiler iÃ§in giderek daha Ã¶nemli hale geldiÄŸini ve deneyimli profesyonellerin iÅŸgÃ¼cÃ¼nde kalmasÄ±nÄ±n bir zorunluluk haline geldiÄŸini gÃ¶stermektedir. Bu demografik gerÃ§eklik, yaÅŸa baÄŸlÄ± kariyer kÄ±sÄ±tlamalarÄ±nÄ±n azalmasÄ±na ve daha kapsayÄ±cÄ± istihdam politikalarÄ±nÄ±n benimsenmesine yol aÃ§maktadÄ±r.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HYEzC8y0n2UsU-dgDBCzsA.png" /></figure><p>BatÄ± toplumlarÄ±nda kariyer tercihlerini ÅŸekillendiren bir diÄŸer Ã¶nemli etken, iÅŸ-yaÅŸam dengesine verilen artan deÄŸerdir. YapÄ±lan araÅŸtÄ±rmalar, iÅŸ-yaÅŸam dengesinin birÃ§ok AvrupalÄ± iÃ§in maaÅŸtan daha Ã¶nemli bir motivasyon kaynaÄŸÄ± haline geldiÄŸini gÃ¶stermektedir. AvrupalÄ±larÄ±n %51&#39;i iÅŸ-yaÅŸam dengelerinden Ã§ok memnun olduÄŸunu belirtirken, AmerikalÄ±larÄ±n %33&#39;Ã¼ tatile Ã§Ä±ktÄ±ÄŸÄ±nda suÃ§luluk hissettiÄŸini, AvrupalÄ±larÄ±n ise sadece %18&#39;i bu duyguyu paylaÅŸtÄ±ÄŸÄ±nÄ± ifade etmektedir. Bu, bireylerin kariyerlerini sadece finansal kazanÃ§ veya erken istikrar arayÄ±ÅŸÄ±yla deÄŸil, aynÄ± zamanda kiÅŸisel tatmin, esneklik ve yaÅŸam tarzÄ± uyumu doÄŸrultusunda ÅŸekillendirme eÄŸiliminde olduÄŸunu ortaya koymaktadÄ±r.</p><p>Kariyer molalarÄ± ve orta kariyer deÄŸiÅŸiklikleri de bu kÃ¼ltÃ¼rlerde daha fazla kabul gÃ¶rmektedir. AraÅŸtÄ±rmalar, iÅŸ deÄŸiÅŸtiren orta kariyerli ve daha yaÅŸlÄ± Ã§alÄ±ÅŸanlarÄ±n iÅŸlerinin tÃ¼m boyutlarÄ±ndan Ã¶nemli Ã¶lÃ§Ã¼de daha memnun olduklarÄ±nÄ± gÃ¶stermektedir. Ancak, bu algÄ±nÄ±n tamamen sorunsuz olduÄŸu sÃ¶ylenemez. UluslararasÄ± bir ankete gÃ¶re, insanlarÄ±n %42&#39;sinden azÄ± kariyer molasÄ± vermeyi gÃ¶ze alabildiÄŸini hissederken, yaklaÅŸÄ±k %80&#39;i bÃ¶yle bir molanÄ±n kariyer ilerlemeleri Ã¼zerindeki etkisinden endiÅŸe duymaktadÄ±r. Ä°ÅŸverenler arasÄ±nda da 45 yaÅŸ Ã¼stÃ¼ adaylara karÅŸÄ± bir â€œstereotipâ€ ve â€œyaÅŸ ayrÄ±mcÄ±lÄ±ÄŸÄ±â€ hala mevcuttur; genellikle 30â€“44 yaÅŸ arasÄ± adaylar tercih edilmektedir. Ancak bu durumun bir paradoksu bulunmaktadÄ±r: iÅŸverenlerin %89&#39;u, iÅŸe aldÄ±klarÄ± orta yaÅŸ ve Ã¼zeri Ã§alÄ±ÅŸanlarÄ±n genÃ§ Ã§alÄ±ÅŸanlar kadar iyi veya daha iyi performans gÃ¶sterdiÄŸini belirtmiÅŸtir. Bu, yaÅŸa baÄŸlÄ± Ã¶nyargÄ±larÄ±n, gerÃ§ek performansla Ã§eliÅŸtiÄŸini ve deneyimli profesyoneller iÃ§in fÄ±rsatlarÄ±n aslÄ±nda mevcut olduÄŸunu ortaya koymaktadÄ±r.</p><p>Bu durum, BatÄ± kariyer kÃ¼ltÃ¼rÃ¼ndeki esnekliÄŸin mÃ¼kemmel bir idealden ziyade, demografik zorunluluklar ve deÄŸiÅŸen deÄŸerler Ä±ÅŸÄ±ÄŸÄ±nda sÃ¼rekli geliÅŸen bir gerÃ§eklik olduÄŸunu gÃ¶stermektedir. Bireycilik, kiÅŸisel Ã¶zerklik ve kendini gerÃ§ekleÅŸtirme vurgusu , kariyer yollarÄ±nÄ±n daha az doÄŸrusal ve daha fazla kiÅŸisel tercihlere dayalÄ± olmasÄ±na olanak tanÄ±maktadÄ±r.</p><h3>30&#39;lu YaÅŸlar: GeÃ§ KalmÄ±ÅŸlÄ±k DeÄŸil, Yeni BaÅŸlangÄ±Ã§larÄ±n EÅŸiÄŸi</h3><p>TÃ¼rkiyeâ€™de 30&#39;lu yaÅŸlarda kariyer deÄŸiÅŸikliÄŸi yapmanÄ±n â€œgeÃ§ kalmÄ±ÅŸlÄ±kâ€ olarak algÄ±lanmasÄ± yaygÄ±n olsa da, bu yaÅŸlar aslÄ±nda kariyerde yeniden yapÄ±lanma ve bÃ¼yÃ¼me iÃ§in gÃ¼Ã§lÃ¼ bir dÃ¶nemdir. 30&#39;lu yaÅŸlardaki bireyler, kariyer deÄŸiÅŸikliÄŸine paha biÃ§ilmez avantajlar getirirler: Ã¶nceki deneyimler (alakasÄ± olmadÄ±ÄŸÄ± dÃ¼ÅŸÃ¼nÃ¼len alanlardan bile olsa), olgunluk, daha net bir amaÃ§ duygusu ve genellikle daha geniÅŸ bir profesyonel aÄŸ.</p><p>Kariyer deÄŸiÅŸtiren orta yaÅŸ ve Ã¼zeri Ã§alÄ±ÅŸanlarÄ±n, yeni iÅŸlerinden Ã§ok daha memnun olduklarÄ± gÃ¶zlemlenmektedir. Bu durum, 30&#39;lu yaÅŸlarda alÄ±nan bilinÃ§li kararlarÄ±n, daha Ã¶nceki genÃ§lik dÃ¶nemlerinde yapÄ±lan ve belki de tam olarak tatmin etmeyen seÃ§imlere kÄ±yasla, daha fazla kiÅŸisel tatmin ve baÅŸarÄ± getirebileceÄŸini gÃ¶stermektedir.</p><p>Teknoloji sektÃ¶rÃ¼ne bakÄ±ldÄ±ÄŸÄ±nda, kodlama bootcampâ€™lerine katÄ±lanlarÄ±n %70&#39;inden fazlasÄ±nÄ±n 2023 yÄ±lÄ±nda 25 ila 40 yaÅŸlarÄ± arasÄ±nda olduÄŸu ve kariyer deÄŸiÅŸtirmek veya becerilerini geliÅŸtirmek amacÄ±yla katÄ±ldÄ±klarÄ± belirtilmiÅŸtir. Bu, 30&#39;lu yaÅŸlarÄ±n, yeni beceriler edinmek ve kariyerde Ã¶nemli bir dÃ¶nÃ¼ÅŸÃ¼m yapmak iÃ§in ideal bir dÃ¶nem olduÄŸunu gÃ¶steren somut bir kanÄ±ttÄ±r.</p><p>Tarih, 30&#39;lu yaÅŸlardan sonra kariyerinde bÃ¼yÃ¼k atÄ±lÄ±mlar yapmÄ±ÅŸ veya tamamen yeni bir alana geÃ§erek zirveye ulaÅŸmÄ±ÅŸ ilham verici isimlerle doludur:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RsxyhchTIEkj4OPvPAY_Ng.png" /></figure><p>Bu Ã¶rnekler, yaÅŸÄ±n kariyer baÅŸarÄ±sÄ± iÃ§in bir engel olmadÄ±ÄŸÄ±nÄ±, aksine birikmiÅŸ deneyim ve olgunluÄŸun yeni baÅŸlangÄ±Ã§lar iÃ§in gÃ¼Ã§lÃ¼ bir zemin oluÅŸturabileceÄŸini kanÄ±tlamaktadÄ±r. â€œKendini keÅŸfetmek, baÅŸarÄ±ya giden en bÃ¼yÃ¼k adÄ±mdÄ±r. Hayallerin peÅŸinden gitmek, kendine yapabileceÄŸin en bÃ¼yÃ¼k iyiliktirâ€ sÃ¶zleri, bu dÃ¶nemdeki bireylerin kendi potansiyellerini fark etmeleri ve cesur adÄ±mlar atmalarÄ± iÃ§in gÃ¼Ã§lÃ¼ bir motivasyon kaynaÄŸÄ±dÄ±r. Kariyer deÄŸiÅŸikliÄŸi, bireyin mevcut iÅŸindeki mutsuzluÄŸundan kaynaklanabileceÄŸi gibi, baÅŸka bir alanda daha baÅŸarÄ±lÄ± olabileceÄŸine dair inanÃ§la da tetiklenebilir. Ã–nemli olan, bu deÄŸiÅŸimin nedenlerini netleÅŸtirmek ve kendi becerilerini, ilgi alanlarÄ±nÄ± doÄŸru bir ÅŸekilde analiz etmektir.</p><h3>YazÄ±lÄ±m SektÃ¶rÃ¼nde â€œAlaylÄ±â€ Olmak: Diploma mÄ±, Yetenek mi?</h3><p>YazÄ±lÄ±m sektÃ¶rÃ¼, dÃ¼nya genelinde dinamik yapÄ±sÄ±yla Ã¶ne Ã§Ä±kan ve geleneksel kariyer yollarÄ±nÄ± sorgulatan bir alandÄ±r. TÃ¼rkiyeâ€™de â€œalaylÄ±â€ (kendi kendini yetiÅŸtirmiÅŸ) yazÄ±lÄ±mcÄ±lar ile Ã¼niversite mezunlarÄ± arasÄ±ndaki algÄ± farklÄ±lÄ±klarÄ±, bu sektÃ¶rÃ¼n Ã¶nemli bir tartÄ±ÅŸma konusudur.</p><p>TÃ¼rkiyeâ€™de, Ã¼niversite diplomasÄ±na verilen geleneksel Ã¶nem, alaylÄ± yazÄ±lÄ±mcÄ±lara karÅŸÄ± zaman zaman bir ÅŸÃ¼phecilik veya â€œyetersizlikâ€ algÄ±sÄ± yaratabilmektedir. BazÄ± gÃ¶rÃ¼ÅŸler, yazÄ±lÄ±mÄ±n basit bir iÅŸ olmadÄ±ÄŸÄ±nÄ± ve herkese iÅŸ verilmemesi gerektiÄŸini savunarak, sektÃ¶re bir tÃ¼r â€œkapÄ± bekÃ§iliÄŸiâ€ yapÄ±lmasÄ± gerektiÄŸini ima edebilir. Ancak sektÃ¶r uzmanlarÄ±, alaylÄ± yazÄ±lÄ±mcÄ±larÄ±n baÅŸarÄ±lÄ± olabileceÄŸini kabul etmekle birlikte, Ã¼niversite mezunlarÄ±nÄ±n belirli avantajlara sahip olduÄŸunu da belirtmektedir. Deneyimli bir yazÄ±lÄ±mcÄ±, 20 yÄ±llÄ±k tecrÃ¼besiyle, bilgisayar mÃ¼hendisliÄŸi diplomasÄ±nÄ±n â€œÃ§okâ€ avantajÄ± olduÄŸunu, ancak baÅŸarÄ±nÄ±n asÄ±l kriterlerinin â€œiÅŸini sevmek, saÄŸlam temel bilgiye sahip olmak, bol pratik tecrÃ¼be edinmek ve sÃ¼rekli Ã¶ÄŸrenmeye aÃ§Ä±k olmakâ€ olduÄŸunu vurgulamaktadÄ±r. AlaylÄ± bireylerin de bilgisayar bilimlerinin temellerini Ã¶ÄŸrenmeleri halinde kapÄ±larÄ±n aÃ§Ä±lacaÄŸÄ±nÄ± belirtiyor. Temel bilgisayar bilimleri bilgisi (algoritmalar, veri tabanlarÄ±, aÄŸlar, iÅŸletim sistemleri gibi) saÄŸlam, kaliteli ve hatasÄ±z sistemler geliÅŸtirmek iÃ§in kritik Ã¶neme sahiptir.</p><p>Avrupa ve Amerikaâ€™daki teknoloji pazarlarÄ± ise kendi kendini yetiÅŸtirmiÅŸ geliÅŸtiricilere karÅŸÄ± giderek daha aÃ§Ä±k hale gelmektedir. Almanyaâ€™da, 2025 yÄ±lÄ± itibarÄ±yla Ã¼Ã§ yÄ±llÄ±k deneyime sahip BT profesyonelleri, Ã¼niversite diplomasÄ± olmadan da iÅŸ bulma yeterliliÄŸine sahip olabilmektedir; bu, alaylÄ± geliÅŸtiriciler iÃ§in bÃ¼yÃ¼k bir fÄ±rsat olarak nitelendirilmektedir. Bu durum, BatÄ±â€™daki iÅŸgÃ¼cÃ¼ piyasasÄ±nÄ±n beceri odaklÄ± bir modele doÄŸru kaydÄ±ÄŸÄ±nÄ± gÃ¶stermektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iZXjoXN1WPig2sZxOu33hg.png" /></figure><p>Kodlama bootcampâ€™leri, bu deÄŸiÅŸimin Ã¶nemli bir gÃ¶stergesidir. 2023 yÄ±lÄ±nda ABDâ€™de 34.000&#39;den fazla bootcamp mezunu iÅŸgÃ¼cÃ¼ piyasasÄ±na girmiÅŸ ve bunlar, Ã¼niversite diplomasÄ± olmayan yeni teknoloji iÅŸe alÄ±mlarÄ±nÄ±n yaklaÅŸÄ±k %18&#39;ini oluÅŸturmuÅŸtur. Bootcamp mezunlarÄ±nÄ±n %70&#39;inden fazlasÄ± altÄ± ay iÃ§inde iÅŸ bulmuÅŸtur. Global ortalama iÅŸe yerleÅŸtirme oranlarÄ± %71â€“79 arasÄ±nda deÄŸiÅŸmekte olup, bu oranlar bilgisayar bilimleri lisans derecesi mezunlarÄ±nÄ±n %68&#39;lik ortalama yerleÅŸtirme oranÄ±nÄ± geride bÄ±rakmaktadÄ±r. Avrupaâ€™da da 2023&#39;te 28.000&#39;den fazla bootcamp mezunu bulunmakta ve Almanya ile BirleÅŸik KrallÄ±k bu alanda lider konumdadÄ±r.</p><p>Ancak bu durumun bazÄ± nÃ¼anslarÄ± da bulunmaktadÄ±r. Avrupaâ€™da, Ã¶zellikle ABD dÄ±ÅŸÄ±ndaki bÃ¶lgelerde, beceriler genellikle resmi niteliklere veya sertifikalara daha sÄ±kÄ± bir ÅŸekilde baÄŸlÄ±dÄ±r ve kendi kendine Ã¶ÄŸrenmeye kÄ±yasla uzun vadeli, resmi eÄŸitim ve Ã§Ä±raklÄ±k programlarÄ±na daha fazla vurgu yapÄ±labilir. Bu, alaylÄ± geliÅŸtiricilerin Avrupaâ€™da iÅŸ bulma sÃ¼reÃ§lerinde hala bazÄ± endiÅŸeler taÅŸÄ±yabileceÄŸini gÃ¶stermektedir.</p><p>SonuÃ§ olarak, yazÄ±lÄ±m sektÃ¶rÃ¼nde baÅŸarÄ±nÄ±n anahtarÄ±, Ã¶ÄŸrenme yolundan baÄŸÄ±msÄ±z olarak, temel bilgisayar bilimleri bilgisine hakim olmak ve pratik, projeye dayalÄ± beceriler geliÅŸtirmektir. Kendi kendini Ã¶ÄŸrenme yeteneÄŸi, hem teknik hem de sosyal becerilerin gÃ¼Ã§lÃ¼ bir gÃ¶stergesi olarak kabul edilmektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1015/1*NHLCMVf01kHvOFFGkBXIWQ.png" /></figure><p>Bu karÅŸÄ±laÅŸtÄ±rma, TÃ¼rkiyeâ€™deki yazÄ±lÄ±m sektÃ¶rÃ¼nÃ¼n alaylÄ± yetenekleri kabul etme konusunda bir ikilem yaÅŸadÄ±ÄŸÄ±nÄ±, BatÄ± pazarlarÄ±nÄ±n ise beceri ve pratik deneyime daha fazla Ã¶ncelik verdiÄŸini ortaya koymaktadÄ±r.</p><h3>Kafa YapÄ±larÄ± ve KÃ¼ltÃ¼rel Farklar: Bireysellikten Kolektivizme Kariyer AlgÄ±sÄ±</h3><p>Kariyer algÄ±sÄ±ndaki farklÄ±lÄ±klar, TÃ¼rkiye ile Avrupa ve Amerika arasÄ±ndaki temel kÃ¼ltÃ¼rel zihniyet farklÄ±lÄ±klarÄ±ndan kaynaklanmaktadÄ±r. Bu farklÄ±lÄ±klar, Hofstedeâ€™nin kÃ¼ltÃ¼rel boyutlarÄ± gibi teorilerle daha iyi anlaÅŸÄ±labilir; Ã¶zellikle bireysellik-kolektivizm ve belirsizlikten kaÃ§Ä±nma boyutlarÄ±, kariyer seÃ§imlerini, risk alma eÄŸilimlerini ve baÅŸarÄ± algÄ±sÄ±nÄ± derinden etkiler.</p><p>TÃ¼rkiye gibi kolektivist kÃ¼ltÃ¼rlerde , bireyler kendilerini sosyal iliÅŸkilerin bir parÃ§asÄ± olarak gÃ¶rÃ¼r ve eylemleri ile dÃ¼ÅŸÃ¼nceleri, grup hedefleri ve Ã¶nemli diÄŸerlerinin beklentileri tarafÄ±ndan bÃ¼yÃ¼k Ã¶lÃ§Ã¼de etkilenir. Bu baÄŸlamda, kariyer seÃ§imleri genellikle aile ve toplumsal beklentilerle uyumlu olmalÄ±, istikrar ve erken baÅŸarÄ±ya odaklanmalÄ±dÄ±r. Geleneksel yollardan sapmak (Ã¶rneÄŸin, 30&#39;lu yaÅŸlarda kariyer deÄŸiÅŸtirmek veya alaylÄ± olmak), belirsizliÄŸi artÄ±rÄ±r ve kolektifin (ailenin) itibarÄ± veya finansal gÃ¼venliÄŸi iÃ§in bir risk olarak algÄ±lanabilir. DoÄŸu kÃ¼ltÃ¼rlerinde yaygÄ±n olan â€œkadercilikâ€ anlayÄ±ÅŸÄ± , proaktif, kendi kendine yÃ¶nelen kariyer planlamasÄ±nÄ± daha az teÅŸvik edebilir, Ã§Ã¼nkÃ¼ her ÅŸeyin â€œolacaÄŸÄ±na varacaÄŸÄ±â€ inancÄ±, bireyi belirlenmiÅŸ, â€œgÃ¼venliâ€ rotalara daha fazla baÄŸÄ±mlÄ± kÄ±labilir. Bu durum, kariyer deÄŸiÅŸikliklerinin â€œgarip karÅŸÄ±lanmasÄ±naâ€ ve alaylÄ± kiÅŸilere karÅŸÄ± ÅŸÃ¼pheciliÄŸe yol aÃ§an toplumsal normlarÄ± gÃ¼Ã§lendirebilir.</p><p>Ã–te yandan, Kuzey Amerika ve Avrupa gibi bireyselci kÃ¼ltÃ¼rlerde , kiÅŸisel hedeflere ve Ã¶zerkliÄŸe Ã¶ncelik verilir. Bireylerin kendi kendine yeterliliÄŸi ve baÄŸÄ±msÄ±zlÄ±ÄŸÄ± vurgulanÄ±r. Bu kÃ¼ltÃ¼rel yÃ¶nelim, iÅŸ-yaÅŸam dengesine ve yaÅŸam tarzÄ± uyumuna verilen artan deÄŸerle uyumludur. Bireyler, kariyer seÃ§imlerini sadece dÄ±ÅŸsal baskÄ±larla deÄŸil, aynÄ± zamanda kiÅŸisel tatmin ve deÄŸerleriyle uyumlu olup olmadÄ±ÄŸÄ±na gÃ¶re yapma Ã¶zgÃ¼rlÃ¼ÄŸÃ¼ne sahiptir. Bu bireyselci yaklaÅŸÄ±m, farklÄ± kariyer yollarÄ±nÄ±n, molalarÄ±n ve deÄŸiÅŸikliklerin daha kolay kabul edildiÄŸi bir ortam yaratÄ±r, Ã§Ã¼nkÃ¼ bunlar kiÅŸisel iradenin ve kendini keÅŸfetmenin bir ifadesi olarak gÃ¶rÃ¼lÃ¼r. BaÅŸarÄ± tanÄ±mÄ± daha geniÅŸler ve sadece finansal veya statÃ¼ odaklÄ± olmaktan Ã§Ä±karak, kiÅŸisel refahÄ± ve deÄŸerlerle uyumu da iÃ§erir.</p><p>Bu kÃ¼ltÃ¼rel farklÄ±lÄ±klar, kariyer yolculuÄŸunun algÄ±lanÄ±ÅŸÄ±nÄ± temelden etkiler. TÃ¼rkiyeâ€™deki â€œkoÅŸturmaca,â€ bÃ¼yÃ¼k Ã¶lÃ§Ã¼de yÃ¼ksek genÃ§ iÅŸsizliÄŸi ve ekonomik istikrarsÄ±zlÄ±k gibi dÄ±ÅŸsal faktÃ¶rlere karÅŸÄ± bir savunma mekanizmasÄ± olarak ortaya Ã§Ä±karken, aynÄ± zamanda kolektivist deÄŸerlerin ve belirsizlikten kaÃ§Ä±nma eÄŸilimlerinin bir yansÄ±masÄ±dÄ±r. BatÄ±â€™daki esneklik ise, bireyciliÄŸin ve kiÅŸisel tatmine verilen Ã¶nemin bir sonucudur; ancak bu da yaÅŸ ayrÄ±mcÄ±lÄ±ÄŸÄ± gibi kendi zorluklarÄ±nÄ± barÄ±ndÄ±rÄ±r.</p><p>Ancak bu derin kÃ¼ltÃ¼rel farklÄ±lÄ±klar duraÄŸan deÄŸildir. KÃ¼reselleÅŸme ve modernleÅŸme, toplumlarÄ±n evrimleÅŸmesine yol aÃ§maktadÄ±r. KaÄŸÄ±tÃ§Ä±baÅŸÄ±â€™nÄ±n belirttiÄŸi gibi, modernleÅŸme Ã¶zerklik ve aidiyetin bir karÄ±ÅŸÄ±mÄ±na yol aÃ§abilir. TÃ¼rkiyeâ€™nin BatÄ± ÅŸehirlerinin Avrupa yaÅŸamÄ±yla daha fazla etkileÅŸim iÃ§inde olmasÄ± , zamanla kariyer kÃ¼ltÃ¼rÃ¼nÃ¼n de daha esnek ve Ã§eÅŸitli yollara aÃ§Ä±k hale gelmesine katkÄ±da bulunabilir. Bu, gelecekte TÃ¼rkiyeâ€™deki kariyer algÄ±sÄ±nÄ±n da kÃ¼resel trendlere daha fazla uyum saÄŸlayabileceÄŸi yÃ¶nÃ¼nde olumlu bir beklenti yaratmaktadÄ±r.</p><h3>Cesaret Veren Hikayeler ve Kendi Yolunu Ã‡izme Rehberi</h3><p>Kendi kariyer yolculuÄŸum, uluslararasÄ± iliÅŸkilerden turizme, oradan da kendi kendini yetiÅŸtirmiÅŸ bir yazÄ±lÄ±mcÄ±lÄ±ÄŸa uzanan bu dÃ¶nÃ¼ÅŸÃ¼m, cesaretin, uyum yeteneÄŸinin ve kendi yolunu Ã§izme gÃ¼cÃ¼nÃ¼n bir kanÄ±tÄ±dÄ±r. Bu, modern iÅŸ dÃ¼nyasÄ±nda giderek daha fazla gÃ¶rÃ¼len, doÄŸrusal olmayan kariyer yollarÄ±nÄ±n ne kadar deÄŸerli olabileceÄŸinin gÃ¼Ã§lÃ¼ bir Ã¶rneÄŸidir.</p><p>DÃ¼nya genelinde, benim gibi kendi kendini yetiÅŸtirmiÅŸ ve farklÄ± alanlardan teknolojiye geÃ§iÅŸ yapmÄ±ÅŸ birÃ§ok baÅŸarÄ±lÄ± profesyonel bulunmaktadÄ±r. Ã–rneÄŸin, hemÅŸirelik, inÅŸaat mÃ¼hendisliÄŸi, iÅŸletme, Ä°ngilizce Ã¶ÄŸretmenliÄŸi veya insan kaynaklarÄ± gibi tamamen farklÄ± geÃ§miÅŸlerden gelen kiÅŸiler, kendi Ã§abalarÄ±yla tam zamanlÄ± yazÄ±lÄ±mcÄ± olmuÅŸlardÄ±r. Nadia Zhukâ€™un Ä°ngilizce Ã¶ÄŸretmenliÄŸinden full-stack geliÅŸtiriciliÄŸe geÃ§iÅŸi ve Polonya ile Londraâ€™da kariyerini inÅŸa etmesi, aktarÄ±labilir becerilerin ve kÃ¼ltÃ¼rel engelleri aÅŸmanÄ±n mÃ¼mkÃ¼n olduÄŸunu gÃ¶stermektedir. Bu baÅŸarÄ± Ã¶ykÃ¼leri, temel bilgisayar bilimleri bilgisine hakim olmanÄ±n, sÃ¼rekli kod yazmanÄ±n, aÄŸ kurmanÄ±n ve kiÅŸisel markayÄ± inÅŸa etmenin Ã¶nemini vurgulamaktadÄ±r.</p><p>Kariyer dÃ¶nÃ¼ÅŸÃ¼mÃ¼ elbette kolay bir sÃ¼reÃ§ deÄŸildir; zaman, Ã§aba ve dayanÄ±klÄ±lÄ±k gerektirir. Ancak bu sÃ¼reÃ§te atÄ±lacak bilinÃ§li adÄ±mlar, baÅŸarÄ±ya ulaÅŸmada kritik rol oynar. Ä°ÅŸte kendi yolunuzu Ã§izerken size rehberlik edebilecek bazÄ± pratik tavsiyeler:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rw5acNMdcIEk7fpFxG3e-w.png" /></figure><ol><li><strong>Kendinizi KeÅŸfedin ve Nedenlerinizi NetleÅŸtirin:</strong> Kariyer deÄŸiÅŸikliÄŸi isteÄŸinizin altÄ±nda yatan temel motivasyonu anlayÄ±n. Mevcut iÅŸinizdeki mutsuzluk mu, yoksa yeni bir alanda daha bÃ¼yÃ¼k bir potansiyel mi gÃ¶rÃ¼yorsunuz? Turizmdeki 6 yÄ±llÄ±k deneyimim gibi Ã¶nceki deneyimlerinizden edindiÄŸiniz aktarÄ±labilir becerileri (problem Ã§Ã¶zme, mÃ¼ÅŸteri iliÅŸkileri, organizasyon yeteneÄŸi vb.) belirleyin. Bu farkÄ±ndalÄ±k, sÃ¼reci bilinÃ§li ve amaÃ§ odaklÄ± yÃ¶netmenizi saÄŸlar. â€œKendini keÅŸfetmek, baÅŸarÄ±ya giden en bÃ¼yÃ¼k adÄ±mdÄ±râ€.</li><li><strong>Stratejik Ã–ÄŸrenme ve Proje OdaklÄ± GeliÅŸim:</strong> YazÄ±lÄ±m gibi dinamik bir alanda baÅŸarÄ±lÄ± olmak iÃ§in temel bilgisayar bilimleri bilgisine (algoritmalar, veri yapÄ±larÄ±, aÄŸlar gibi) saÄŸlam bir ÅŸekilde hakim olmak hayati Ã¶neme sahiptir. Ãœniversite diplomasÄ± olmadan da bu temelleri Ã¶ÄŸrenmek mÃ¼mkÃ¼ndÃ¼r; internette yÃ¼zlerce Ã¼cretsiz kaynak ve kurs bulunmaktadÄ±r. Kendi projelerinizi geliÅŸtirerek ve bir portfÃ¶y oluÅŸturarak pratik becerilerinizi sergileyin. Bu, Ã¶zellikle BatÄ± teknoloji pazarlarÄ±nda oldukÃ§a deÄŸerlidir.</li><li><strong>AÄŸ Kurma ve Mentorluk:</strong> HedeflediÄŸiniz sektÃ¶rdeki profesyonellerle baÄŸlantÄ± kurun. LinkedIn gibi platformlar veya sektÃ¶r etkinlikleri aracÄ±lÄ±ÄŸÄ±yla aÄŸÄ±nÄ±zÄ± geniÅŸletin. FarklÄ± geÃ§miÅŸlere sahip kiÅŸilere deÄŸer veren profesyonellerle iletiÅŸim kurmak, size yeni kapÄ±lar aÃ§abilir. Bir mentor bulmak, yolculuÄŸunuzda size rehberlik edebilir ve bilgi boÅŸluklarÄ±nÄ±zÄ± doldurmanÄ±za yardÄ±mcÄ± olabilir.</li><li><strong>SabÄ±r ve GerÃ§ekÃ§ilik:</strong> Kariyer geÃ§iÅŸleri zaman alÄ±r ve zorluklarla doludur. Yeni bir alanda uzmanlaÅŸmak veya deneyim kazanmak hemen gerÃ§ekleÅŸmeyebilir. Bu sÃ¼reÃ§te karÅŸÄ±laÅŸacaÄŸÄ±nÄ±z engeller sizi yÄ±ldÄ±rmamalÄ±dÄ±r. â€œBaÅŸarÄ±sÄ±zlÄ±ÄŸa uÄŸrayabilirsiniz, ama yÄ±lmamalÄ±sÄ±nÄ±zâ€. Hedeflerinize ulaÅŸmak iÃ§in sabÄ±rlÄ± olun ve sÃ¼rekli Ã¶ÄŸrenmeye ve geliÅŸmeye odaklanÄ±n.</li><li><strong>KÃ¼resel FÄ±rsatlarÄ± DeÄŸerlendirin:</strong> Uzaktan Ã§alÄ±ÅŸma fÄ±rsatlarÄ±nÄ± veya uluslararasÄ± hareketliliÄŸi araÅŸtÄ±rÄ±n. Ã–zellikle Avrupa ve Amerikaâ€™da kendi kendini yetiÅŸtirmiÅŸ profesyonellere ve esnek Ã§alÄ±ÅŸma dÃ¼zenlemelerine olan kabul artmaktadÄ±r. Bu, TÃ¼rkiyeâ€™deki geleneksel algÄ±larÄ±n Ã¶tesine geÃ§erek yeteneklerinizin daha geniÅŸ bir pazarda deÄŸer bulmasÄ±nÄ± saÄŸlayabilir.</li></ol><p>Kendi kendini Ã¶ÄŸrenme yeteneÄŸi, hem teknik hem de sosyal becerilerin en gÃ¼Ã§lÃ¼ gÃ¶stergelerinden biridir. Sizin gibi bireylerin â€œprojeler ve eÄŸitimlerleâ€ kendilerini geliÅŸtirmeleri, gÃ¼nÃ¼mÃ¼zÃ¼n hÄ±zla deÄŸiÅŸen iÅŸ dÃ¼nyasÄ±nda sadece geÃ§erli deÄŸil, aynÄ± zamanda geleceÄŸe yÃ¶nelik stratejik bir yaklaÅŸÄ±mdÄ±r.</p><h3>Kendi DeÄŸerini Bilmek ve GeleceÄŸi Åekillendirmek</h3><p>Kariyer yolculuÄŸu, gÃ¼nÃ¼mÃ¼zde giderek daha akÄ±ÅŸkan ve kiÅŸiselleÅŸtirilmiÅŸ bir hal almaktadÄ±r. Geleneksel, yaÅŸa baÄŸlÄ± ve doÄŸrusal kariyer Ã§izgileri, yerini daha esnek, Ã§ok yÃ¶nlÃ¼ ve bireysel tercihlere dayalÄ± yollara bÄ±rakmaktadÄ±r. TÃ¼rkiyeâ€™de hissedilen â€œkoÅŸturmacaâ€ ve â€œgeÃ§ kalmÄ±ÅŸlÄ±kâ€ algÄ±sÄ±, Ã¼lkenin kendine Ã¶zgÃ¼ sosyo-ekonomik ve kÃ¼ltÃ¼rel dinamiklerinden kaynaklansa da, bu durum kÃ¼resel eÄŸilimlerle Ã§eliÅŸmektedir.</p><p>Bu analiz, yaÅŸÄ±n sadece bir sayÄ± olduÄŸunu ve 30&#39;lu yaÅŸlarÄ±n, hatta daha ilerisinin, kariyerde yeni baÅŸlangÄ±Ã§lar iÃ§in geÃ§ deÄŸil, aksine olgunluk, deneyim ve daha net bir amaÃ§ duygusuyla dolu gÃ¼Ã§lÃ¼ bir dÃ¶nem olduÄŸunu aÃ§Ä±kÃ§a ortaya koymaktadÄ±r. Jeff Bezos, Vera Wang ve Colonel Sanders gibi ikonik isimlerin hikayeleri, bu gerÃ§eÄŸin en somut kanÄ±tlarÄ±dÄ±r. Ã–nceki deneyimleriniz, farklÄ± bir alandan gelmiÅŸ olsanÄ±z bile, yeni kariyerinizde deÄŸerli birer varlÄ±k haline gelebilir.</p><p>YazÄ±lÄ±m sektÃ¶rÃ¼ Ã¶zelinde, TÃ¼rkiyeâ€™de alaylÄ± yeteneklere karÅŸÄ± hala bazÄ± Ã¶nyargÄ±lar bulunsa da, Avrupa ve Amerikaâ€™daki trendler, beceri ve pratik deneyimin resmi diplomalarÄ±n Ã¶nÃ¼ne geÃ§tiÄŸini gÃ¶stermektedir. Kodlama bootcampâ€™lerinin baÅŸarÄ±sÄ± ve bazÄ± Ã¼lkelerde diploma ÅŸartÄ±nÄ±n kalkmasÄ±, kendi kendini yetiÅŸtirmiÅŸ profesyoneller iÃ§in uluslararasÄ± kapÄ±larÄ± ardÄ±na kadar aÃ§maktadÄ±r.</p><p>En nihayetinde, kariyer baÅŸarÄ±sÄ±nÄ±n temelinde yatan en Ã¶nemli faktÃ¶rler, tutku, Ã¶ÄŸrenme arzusu ve sÃ¼rekli kendini geliÅŸtirmedir. DeÄŸiÅŸim, bireyin kendi iÃ§inde baÅŸlar ve kendi deÄŸerini bilmek, dÄ±ÅŸsal toplumsal baskÄ±lara karÅŸÄ± en gÃ¼Ã§lÃ¼ panzehirdir. Kendi yolunuzu Ã§izmek, kendi baÅŸarÄ± tanÄ±mÄ±nÄ±zÄ± oluÅŸturmak ve geleceÄŸi kendi koÅŸullarÄ±nÄ±zla ÅŸekillendirmek, gÃ¼nÃ¼mÃ¼z dÃ¼nyasÄ±nda sadece bir seÃ§enek deÄŸil, aynÄ± zamanda uzun vadeli kariyer dayanÄ±klÄ±lÄ±ÄŸÄ± ve kiÅŸisel tatmin iÃ§in stratejik bir yaklaÅŸÄ±mdÄ±r. UnutmayÄ±n, â€œhayallerin peÅŸinden gitmek, kendine yapabileceÄŸin en bÃ¼yÃ¼k iyiliktirâ€.</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9a80d2966556" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Kurumsal Java UygulamalarÄ±na CUDA Entegrasyonu Ä°le GPU DÃ¼zeyinde Performans ArttÄ±rma ]]>
</title>
<link>https://pehlivanmert.medium.com/kurumsal-java-uygulamalar%C4%B1na-cuda-entegrasyonu-i%CC%87le-gpu-d%C3%BCzeyinde-performans-getirmek-072e32246444?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/072e32246444</guid>
<category>
<![CDATA[ performance ]]>
</category>
<category>
<![CDATA[ cuda ]]>
</category>
<category>
<![CDATA[ java ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 20 Jun 2025 02:25:26 GMT</pubDate>
<atom:updated>2025-06-20T05:09:23.936Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vNV3Toh2Mn0wPF-2q5Si3g.png" /></figure><p>Kurumsal yazÄ±lÄ±m dÃ¼nyasÄ±nda Java, gÃ¼venilirliÄŸi, taÅŸÄ±nabilirliÄŸi ve zengin ekosistemi sayesinde hala baskÄ±n bir konumda bulunmaktadÄ±r. BÃ¼yÃ¼k ÅŸirketlerin altyapÄ±larÄ±nÄ±n temelini oluÅŸturan bu dil, sÃ¼rekli geliÅŸen kÃ¼tÃ¼phaneleri ve gÃ¼Ã§lÃ¼ sanal makinesi (JVM) ile geniÅŸ bir kullanÄ±m alanÄ±na sahiptir. Ancak, modern uygulamalarÄ±n artan dÃ¼ÅŸÃ¼k gecikme sÃ¼resi ve yÃ¼ksek verim talepleri, Ã¶zellikle gerÃ§ek zamanlÄ± analiz, bÃ¼yÃ¼k gÃ¼nlÃ¼k iÅŸlem hatlarÄ± veya derin hesaplama gerektiren yÃ¼ksek performanslÄ± hesaplama (HPC) veya veri yoÄŸun operasyonlarda Java&#39;nÄ±n yÃ¶netilen Ã§alÄ±ÅŸma zamanÄ± ve Ã§Ã¶p toplama (garbage collection) yÃ¼kÃ¼ bazÄ± zorluklar yaratmaktadÄ±r.</p><p>Bu zorluklar devam ederken, baÅŸlangÄ±Ã§ta gÃ¶rÃ¼ntÃ¼ iÅŸleme iÃ§in tasarlanan Grafik Ä°ÅŸlem Birimleri (GPU&#39;lar), gÃ¼nÃ¼mÃ¼zde paralel hesaplama iÃ§in gÃ¼Ã§lÃ¼ hÄ±zlandÄ±rÄ±cÄ±lar olarak Ã¶ne Ã§Ä±kmÄ±ÅŸtÄ±r. NVIDIA&#39;nÄ±n geliÅŸtirdiÄŸi CUDA gibi teknolojiler, geliÅŸtiricilerin GPU&#39;larÄ±n muazzam gÃ¼cÃ¼nden yararlanmasÄ±nÄ± saÄŸlayarak, hesaplama yoÄŸun gÃ¶revler iÃ§in Ã¶nemli hÄ±zlanmalar elde etmelerine olanak tanÄ±r. Bir CPU&#39;nun en fazla dÃ¼zinelerce Ã§ekirdeÄŸi varken, bir GPU binlerce hafif iÅŸ parÃ§acÄ±ÄŸÄ±nÄ± paralel olarak Ã§alÄ±ÅŸtÄ±rabilir ; bu da veri-paralel iÅŸ yÃ¼kleri iÃ§in eÅŸsiz bir avantaj sunar.</p><p>CUDA, Ã¶ncelikli olarak C/C++ gibi dÃ¼ÅŸÃ¼k seviyeli diller iÃ§in tasarlanmÄ±ÅŸ olsa da, Java geliÅŸtiricilerinin bu uyumsuzluÄŸu aÅŸmasÄ± ve GPU hÄ±zlandÄ±rmasÄ±nÄ± Java uygulamalarÄ±na entegre etmesi mÃ¼mkÃ¼ndÃ¼r. Bu makale de, GPU dÃ¼zeyinde hÄ±zlandÄ±rmanÄ±n Java uygulamalarÄ± iÃ§in ne anlama geldiÄŸini, eÅŸzamanlÄ±lÄ±k modelleri arasÄ±ndaki temel farklarÄ±, pratik entegrasyon yollarÄ±nÄ± (JNI, JCuda vb.), somut bir kullanÄ±m senaryosunu ve kurumsal kullanÄ±ma yÃ¶nelik en iyi uygulamalarÄ± inceleyerek benim gibi Java geliÅŸtiricilerine pratik bir rehber sunmayÄ± amaÃ§lamaktayÄ±m.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LJxg_p6dTG68clgkWBz4fA.png" /></figure><h3>Temel KavramlarÄ± Anlamak: Ã‡oklu Ä°ÅŸ ParÃ§acÄ±ÄŸÄ±, EÅŸzamanlÄ±lÄ±k, Paralellik ve Ã‡oklu Ä°ÅŸlem</h3><p>GPU entegrasyonuna girmeden Ã¶nce, Java geliÅŸtiricilerinin yaygÄ±n olarak kullandÄ±ÄŸÄ± farklÄ± yÃ¼rÃ¼tme modellerini net bir ÅŸekilde anlamak Ã¶nemlidir. Bu kavramlar genellikle birbirinin yerine kullanÄ±lsa da, belirgin farklÄ±lÄ±klarÄ± bulunmaktadÄ±r. Bu ayrÄ±mlarÄ± kavramak, CUDA tabanlÄ± hÄ±zlandÄ±rmanÄ±n nerede gerÃ§ekten iÅŸe yaradÄ±ÄŸÄ±nÄ± anlamaya yardÄ±mcÄ± olacaktÄ±r.</p><h3>Java DÃ¼nyasÄ±nda Bu KavramlarÄ±n Yeri ve FarklarÄ±</h3><ul><li><strong>Ã‡oklu Ä°ÅŸ ParÃ§acÄ±ÄŸÄ± (Multithreading):</strong> Bir CPU&#39;nun veya tek bir iÅŸlemin, aynÄ± bellek alanÄ± iÃ§inde birden fazla iÅŸ parÃ§acÄ±ÄŸÄ±nÄ± eÅŸzamanlÄ± olarak yÃ¼rÃ¼tme yeteneÄŸidir. Java&#39;da bu genellikle Thread ve Runnable sÄ±nÄ±flarÄ± veya ExecutorService gibi daha geliÅŸmiÅŸ yapÄ±lar kullanÄ±larak elde edilir. Ä°ÅŸ parÃ§acÄ±klarÄ± hafif ve hÄ±zlÄ± baÅŸlatÄ±labilir olsa da, tÃ¼m iÅŸ parÃ§acÄ±klarÄ± aynÄ± yÄ±ÄŸÄ±n belleÄŸi paylaÅŸtÄ±ÄŸÄ± iÃ§in yarÄ±ÅŸ koÅŸullarÄ±, kilitlenmeler ve iÅŸ parÃ§acÄ±ÄŸÄ± Ã§ekiÅŸmesi gibi sorunlara yol aÃ§abilir. Bu durum, performans kazanÄ±mlarÄ±nÄ± sÄ±nÄ±rlayabilir ve karmaÅŸÄ±k senkronizasyon mekanizmalarÄ± gerektirebilir.</li><li><strong>EÅŸzamanlÄ±lÄ±k (Concurrency):</strong> Birden fazla gÃ¶revin zaman iÃ§inde ilerlemesini saÄŸlama, tek bir Ã§ekirdekte dÃ¶nÃ¼ÅŸÃ¼mlÃ¼ olarak veya Ã§ekirdekler arasÄ±nda paralel olarak Ã§alÄ±ÅŸtÄ±rma yeteneÄŸidir. EÅŸzamanlÄ±lÄ±k, gÃ¶revlerin aynÄ± anda tamamlanmasÄ± yerine, gÃ¶rev yÃ¼rÃ¼tmesini orkestre etmekle ilgilidir. Java, java.util.concurrent paketi ile eÅŸzamanlÄ±lÄ±ÄŸÄ± destekler ve geliÅŸtiricilere gÃ¶revleri yÃ¶netmek iÃ§in gÃ¼Ã§lÃ¼ araÃ§lar sunar.</li><li><strong>Paralellik (Parallelism):</strong> Birden fazla gÃ¶revin aynÄ± anda yÃ¼rÃ¼tÃ¼lmesidir. GerÃ§ek paralellik, birden Ã§ok CPU Ã§ekirdeÄŸi veya yÃ¼rÃ¼tme birimi gibi donanÄ±m desteÄŸi gerektirir. Java, Fork/Join framework&#39;Ã¼ gibi araÃ§larla destek saÄŸlar, ancak CPU tabanlÄ± paralellik nihayetinde Ã§ekirdek sayÄ±sÄ± ve baÄŸlam deÄŸiÅŸtirme yÃ¼kÃ¼ ile sÄ±nÄ±rlÄ±dÄ±r. Bir uygulamanÄ±n performansÄ±, gÃ¶revlerin ne kadar etkili bir ÅŸekilde paralelleÅŸtirildiÄŸine baÄŸlÄ±dÄ±r.</li><li><strong>Ã‡oklu Ä°ÅŸlem (Multiprocessing):</strong> Her biri kendi bellek alanÄ±na sahip birden fazla iÅŸlemin, ayrÄ± CPU Ã§ekirdeklerinde paralel olarak Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± iÃ§erir. Bu model, Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ±ndan daha izole ve saÄŸlamdÄ±r, Ã§Ã¼nkÃ¼ her iÅŸlem kendi bellek alanÄ±na sahiptir, bu da veri Ã§akÄ±ÅŸmasÄ± riskini azaltÄ±r. Ancak, sÃ¼reÃ§ler arasÄ± iletiÅŸim ve baÄŸlam deÄŸiÅŸtirme nedeniyle daha fazla yÃ¼kÃ¼ vardÄ±r. Java&#39;da gerÃ§ek Ã§oklu iÅŸlem genellikle ayrÄ± JVM&#39;ler baÅŸlatmak veya iÅŸi mikro hizmetlere devretmek anlamÄ±na gelir.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OeVxDztmJYoFG50BnbtDQw.png" /></figure><h3>CUDA&#39;nÄ±n Bu Modeller Ä°Ã§inde Nerede ParladÄ±ÄŸÄ±: BÃ¼yÃ¼k Veri ParalelliÄŸi</h3><p>YukarÄ±daki tÃ¼m modeller bÃ¼yÃ¼k Ã¶lÃ§Ã¼de CPU Ã§ekirdeklerine dayanÄ±rken, GPU&#39;lar binlerce hafif iÅŸ parÃ§acÄ±ÄŸÄ±nÄ± paralel olarak Ã§alÄ±ÅŸtÄ±rabilir. Bir CPU en fazla dÃ¼zinelerce Ã§ekirdeÄŸe sahipken, bir GPU binlerce kÃ¼Ã§Ã¼k, uzmanlaÅŸmÄ±ÅŸ Ã§ekirdeÄŸiyle aynÄ± anda yÃ¼zlerce veya binlerce gÃ¶revi ele alabilir. CUDA, matris iÅŸlemleri, gÃ¶rÃ¼ntÃ¼ iÅŸleme, toplu gÃ¼nlÃ¼k dÃ¶nÃ¼ÅŸtÃ¼rme veya maskeleme ve gerÃ§ek zamanlÄ± veri analizi gibi gÃ¶revler iÃ§in ideal olan bu devasa veri-paralel yÃ¼rÃ¼tme modelinden yararlanmanÄ±zÄ± saÄŸlar. Bu tÃ¼r minik taneli, veri dÃ¼zeyinde paralellik, standart Java Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ± ile neredeyse imkansÄ±zdÄ±r; bu da CUDA&#39;nÄ±n kurumsal uygulamalara gerÃ§ek deÄŸer kattÄ±ÄŸÄ± yerdir. GPU&#39;lar, aynÄ± iÅŸlemi birden fazla veri noktasÄ±na eÅŸzamanlÄ± olarak uygulayan Tek Talimat, Ã‡oklu Veri (SIMD) modeli altÄ±nda Ã§alÄ±ÅŸÄ±r.</p><h3>CUDA ve Java: Entegrasyonun Temelleri</h3><p>Java geliÅŸtiricileri geleneksel olarak JVM&#39;nin gÃ¼venli, yÃ¶netilen dÃ¼nyasÄ±nda, donanÄ±m dÃ¼zeyinde optimizasyonun daha dÃ¼ÅŸÃ¼k seviyeli endiÅŸelerinden uzakta Ã§alÄ±ÅŸÄ±rlar. CUDA ise, belleÄŸi dikkatlice yÃ¶neterek, binlerce iÅŸ parÃ§acÄ±ÄŸÄ± baÅŸlatarak ve GPU kullanÄ±mÄ±nÄ± maksimize ederek performansÄ±n elde edildiÄŸi Ã§ok farklÄ± bir dÃ¼nyada yer alÄ±r.</p><h3>CUDA Nedir ve Neden Java ile DoÄŸal Uyumlu DeÄŸil?</h3><p>Compute Unified Device Architecture (CUDA), NVIDIA&#39;nÄ±n geliÅŸtiricilerin NVIDIA GPU&#39;larÄ±nda bÃ¼yÃ¼k Ã¶lÃ§ekli paralel yÃ¼rÃ¼tme iÃ§in yazÄ±lÄ±m yazmasÄ±na olanak tanÄ±yan paralel bilgi iÅŸlem platformu ve API modelidir. Tipik olarak C veya C++ aracÄ±lÄ±ÄŸÄ±yla kullanÄ±lÄ±r ve GPU&#39;da paralel Ã§alÄ±ÅŸan <strong>Ã§ekirdekler (kernels)</strong> olarak adlandÄ±rÄ±lan fonksiyonlar yazÄ±lÄ±r.</p><p><strong>CUDA&#39;nÄ±n gÃ¼Ã§lÃ¼ olduÄŸu alanlar:</strong></p><ul><li>Veri-paralel iÅŸ yÃ¼kleri (Ã¶rneÄŸin, gÃ¶rÃ¼ntÃ¼ iÅŸleme, finansal simÃ¼lasyonlar, gÃ¼nlÃ¼k dÃ¶nÃ¼ÅŸÃ¼mleri).</li><li>Binlerce iÅŸ parÃ§acÄ±ÄŸÄ±yla minik taneli paralellik.</li><li>Hesaplama yoÄŸun iÅŸlemler iÃ§in geliÅŸtirilmiÅŸ hÄ±zlanma sÃ¼releri.</li></ul><p><strong>Java&#39;nÄ±n CUDA ile doÄŸal uyumlu olmamasÄ±nÄ±n nedenleri:</strong></p><ul><li>JVM&#39;nin GPU belleÄŸine veya yÃ¼rÃ¼tme iÅŸlem hatlarÄ±na doÄŸrudan eriÅŸimi yoktur.</li><li>Ã‡oÄŸu Java kÃ¼tÃ¼phanesi CPU ve iÅŸ parÃ§acÄ±ÄŸÄ± tabanlÄ± eÅŸzamanlÄ±lÄ±k dÃ¼ÅŸÃ¼nÃ¼lerek tasarlanmÄ±ÅŸtÄ±r.</li><li>Java&#39;nÄ±n bellek yÃ¶netimi (Ã§Ã¶p toplama, nesne yaÅŸam dÃ¶ngÃ¼sÃ¼) GPU dostu deÄŸildir.</li></ul><p>Ancak doÄŸru araÃ§larla bu engeller aÅŸÄ±labilir.</p><h3>Mevcut Entegrasyon SeÃ§enekleri</h3><p>AÅŸaÄŸÄ±da, Java-CUDA entegrasyonu iÃ§in mevcut seÃ§eneklerin detaylÄ± bir karÅŸÄ±laÅŸtÄ±rmasÄ± yer almaktadÄ±r.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VuIuLobhx11I9N5EkbdEvg.png" /></figure><h3>Pratik Entegrasyon AdÄ±mlarÄ±: Java&#39;dan CUDA Ã‡aÄŸÄ±rmak</h3><p>Java ve CUDA&#39;nÄ±n Ã§alÄ±ÅŸma zamanÄ±nda nasÄ±l etkileÅŸim kurduÄŸunu anlamak iÃ§in temel bileÅŸenler ve veri akÄ±ÅŸÄ± incelenmelidir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NDm5d2UXiNT4mmTzD4IYlg.png" /></figure><h3>Her KatmanÄ±n RolÃ¼</h3><ul><li><strong>Java Uygulama KatmanÄ±:</strong> Bu, standart bir Java servisidir (Ã¶rn: bir gÃ¼nlÃ¼kleme Ã§erÃ§evesi). Ä°ÅŸlem yoÄŸun iÅŸ yÃ¼kleri, geleneksel iÅŸ parÃ§acÄ±ÄŸÄ± havuzlarÄ± yerine yerel Ã§aÄŸrÄ±larla GPU&#39;ya aktarÄ±lÄ±r. Bu katman, girdi verilerini hazÄ±rlamak, JNI Ã§aÄŸrÄ±larÄ±nÄ± tetiklemek ve sonuÃ§larÄ± entegre etmekten sorumludur. Ã–rneÄŸin, saniyede binlerce kullanÄ±cÄ± oturumu iÃ§in SSH tarzÄ± ÅŸifreleme veya gÃ¼venli anahtar karma iÅŸlemleri GPU&#39;ya aktarÄ±labilir, bÃ¶ylece CPU G/Ã‡ ve orkestrasyon iÃ§in serbest kalÄ±r.</li><li><strong>JNI KÃ¶prÃ¼sÃ¼:</strong> JNI, Java ile CUDA mantÄ±ÄŸÄ±nÄ± iÃ§eren yerel C++ kodu arasÄ±nda bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r. Yerel yÃ¶ntemleri bildirir, paylaÅŸÄ±lan kÃ¼tÃ¼phaneleri (.so, .dll) yÃ¼kler ve bellek aktarÄ±mÄ±nÄ± yÃ¶netir. Genellikle ilkel diziler verimli veri aktarÄ±mÄ± iÃ§in kullanÄ±lÄ±r. Bellek yÃ¶netimi, tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼, savunmacÄ± programlama ve kaynak temizliÄŸi bu katmanda kritik Ã¶neme sahiptir Ã§Ã¼nkÃ¼ hatalar JVM&#39;i Ã§Ã¶kertebilir.</li><li><strong>CUDA Ã‡ekirdekleri (C/C++):</strong> Paralel iÅŸlemlerin gerÃ§ekleÅŸtiÄŸi yerdir. Bunlar, binlerce GPU iÅŸ parÃ§acÄ±ÄŸÄ±nda eÅŸzamanlÄ± Ã§alÄ±ÅŸmak Ã¼zere tasarlanmÄ±ÅŸ hafif C tarzÄ± fonksiyonlardÄ±r. .cu dosyalarÄ±nda yazÄ±lÄ±r ve &lt;&lt;&lt;bloklar, iÅŸ parÃ§acÄ±klarÄ±&gt;&gt;&gt; sÃ¶zdizimi ile baÅŸlatÄ±lÄ±r. Her Ã§ekirdek, JNI&#39;dan gelen veriler Ã¼zerinde bÃ¼yÃ¼k paralel iÅŸlemler (Ã¶rn: ÅŸifreleme, karma) gerÃ§ekleÅŸtirir.</li><li><strong>GPU YÃ¼rÃ¼tme:</strong> Ã‡ekirdek baÅŸlatÄ±ldÄ±ktan sonra, CUDA iÅŸ parÃ§acÄ±ÄŸÄ± zamanlamasÄ±nÄ± ve bellek yÃ¶netimini Ã¼stlenir. Ancak performans ayarÄ±, blok/iÅŸ parÃ§acÄ±ÄŸÄ± boyutlandÄ±rmasÄ± ve cudaGetLastError() gibi API&#39;lerle hata iÅŸleme gibi manuel Ã§abalar gerektirir. Bu katman, Ã§alÄ±ÅŸma zamanÄ± performansÄ± ve hata izolasyonunda kritik bir rol oynar.</li><li><strong>Geri DÃ¶nÃ¼ÅŸ AkÄ±ÅŸÄ±:</strong> Ä°ÅŸlemden sonra sonuÃ§lar JNI katmanÄ±na geri dÃ¶ner ve oradan Java uygulamasÄ±na iletilir. Bu veriler daha sonra bir veritabanÄ±na kaydedilebilir veya baÅŸka bir sisteme gÃ¶nderilebilir.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8Al8aqtwJB6baMsMnCPGRQ.png" /></figure><h3>Kurumsal KullanÄ±m Durumu: Ã–lÃ§eklenebilir Toplu Veri Åifreleme</h3><p>GPU hÄ±zlandÄ±rmanÄ±n etkisini gÃ¶stermek iÃ§in pratik bir senaryo olan bÃ¼yÃ¼k Ã¶lÃ§ekli toplu veri ÅŸifrelemesi incelenebilir. BirÃ§ok arka uÃ§ sistemi, yÃ¼ksek verimle karma veya ÅŸifreleme gerektiren hassas bilgileri (kullanÄ±cÄ± kimlik bilgileri, API anahtarlarÄ± vb.) rutin olarak iÅŸler.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qd9AW6rLgHagjnlQ-nn5EQ.png" /></figure><h3>Neden Åifreleme GPU Ä°Ã§in Ä°deal?</h3><p>Geleneksel Java kÃ¼tÃ¼phaneleri (javax.crypto, Bouncy Castle) CPU&#39;ya baÄŸlÄ±dÄ±r ve yÃ¼ksek verimli ortamlarda yetersiz kalabilir. GPU&#39;lar ise bu iÅŸ yÃ¼kÃ¼ iÃ§in uygundur Ã§Ã¼nkÃ¼ ÅŸifreleme/karma mantÄ±ÄŸÄ± (Ã¶rn: SHA-256) durumsuz, tekdÃ¼ze ve yÃ¼ksek derecede paralelleÅŸtirilebilirdir. Her veri parÃ§asÄ±nÄ±n iÅŸlenmesi diÄŸerlerinden baÄŸÄ±msÄ±zdÄ±r, bu da iÅŸ parÃ§acÄ±klarÄ± arasÄ± iletiÅŸime gerek olmadÄ±ÄŸÄ± anlamÄ±na gelir. Bu tÃ¼r iÅŸ yÃ¼kleri, tek iÅŸ parÃ§acÄ±klÄ± uygulamalara gÃ¶re 50 kata kadar gecikme iyileÅŸtirmesi saÄŸlayabilir.</p><h3>Performans KarÅŸÄ±laÅŸtÄ±rmasÄ±</h3><p>AÅŸaÄŸÄ±daki sentetik kÄ±yaslama, GPU hÄ±zlandÄ±rmasÄ±nÄ±n potansiyelini gÃ¶stermektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4ec7o6RAZJ9Rh6pCqE42kA.png" /></figure><h3>GerÃ§ek DÃ¼nya FaydalarÄ±</h3><p>Åifreleme iÅŸ yÃ¼klerini GPU&#39;ya aktarmak, CPU kaynaklarÄ±nÄ± uygulama mantÄ±ÄŸÄ± ve G/Ã‡ iÃ§in serbest bÄ±rakÄ±r. Bu desen, gÃ¼venli API aÄŸ geÃ§itleri veya belge iÅŸleme hatlarÄ± gibi sistemlerde iyi Ã§alÄ±ÅŸÄ±r. Bu kullanÄ±m durumu, GPU&#39;larÄ±n yalnÄ±zca AI ile sÄ±nÄ±rlÄ± olmadÄ±ÄŸÄ±nÄ±, genel amaÃ§lÄ± veri-paralel gÃ¶revler (gÃ¼venli veri iÅŸleme, finansal simÃ¼lasyonlar) iÃ§in de son derece etkili olduÄŸunu gÃ¶stermektedir.</p><h3>En Ä°yi Uygulamalar ve Tuzaklar: Ãœretime HazÄ±rlama</h3><p>Java&#39;yÄ± CUDA ile entegre etmek gÃ¼Ã§le birlikte karmaÅŸÄ±klÄ±k da getirir. GÃ¼venilir, sÃ¼rdÃ¼rÃ¼lebilir ve gÃ¼venli sistemler kurmak iÃ§in aÅŸaÄŸÄ±daki hususlar kritiktir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-t5R-3Ym8GR8O-D7yLapFA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*doKfj5PkTwYoj24-G9gmEA.png" /></figure><h4>Bellek YÃ¶netimi</h4><p>CUDA, Java&#39;nÄ±n aksine aÃ§Ä±k bellek yÃ¶netimi gerektirir. GPU belleÄŸini serbest bÄ±rakmayÄ± unutmak sisteminizi Ã§Ã¶kertebilir.</p><ul><li>GPU belleÄŸini aÃ§Ä±kÃ§a yÃ¶netmek iÃ§in cudaMalloc() ve cudaFree() kullanÄ±n.</li><li>Her JNI giriÅŸ noktasÄ±nÄ±n bir temizleme adÄ±mÄ±na sahip olduÄŸundan emin olun.</li><li>Bellek tahsis hatalarÄ±nÄ± cudaMalloc&#39;un dÃ¶nÃ¼ÅŸ durumlarÄ±nÄ± kontrol ederek yakalayÄ±n ve cuda-memcheck gibi araÃ§lar kullanÄ±n.</li></ul><h4>Veri AktarÄ±mÄ± (Data Marshalling)</h4><p>Java ve C/C++ arasÄ±nda veri aktarÄ±mÄ± ciddi bir performans darboÄŸazÄ± olabilir.</p><ul><li>KarmaÅŸÄ±k Java nesneleri yerine ilkel diziler kullanÄ±n.</li><li>DÃ¼ÅŸÃ¼k gecikmeli eriÅŸim iÃ§in GetPrimitiveArrayCritical() kullanÄ±n.</li><li>Dize kodlama farklÄ±lÄ±klarÄ±na dikkat edin (Java&#39;nÄ±n UTF-8&#39;i vs. C tarzÄ± dizeler).</li><li>YÃ¼kÃ¼ en aza indirmek iÃ§in yerel arabellekleri bir kez tahsis edip yeniden kullanÄ±n.</li></ul><h4>Ä°ÅŸ ParÃ§acÄ±ÄŸÄ± GÃ¼venliÄŸi (Thread Safety)</h4><p>Ã‡oÄŸu Java servisi Ã§ok iÅŸ parÃ§acÄ±klÄ±dÄ±r, bu da yerel koda Ã§aÄŸrÄ± yaparken risk oluÅŸturur.</p><ul><li>JNI arayÃ¼zÃ¼nÃ¼zÃ¼ durumsuz olacak ÅŸekilde tasarlayÄ±n.</li><li>GPU akÄ±ÅŸlarÄ± ve JNI tanÄ±tÄ±cÄ±larÄ± iÅŸ parÃ§acÄ±klarÄ± arasÄ±nda paylaÅŸÄ±lmamalÄ±dÄ±r.</li><li>Java&#39;nÄ±n synchronized bloklarÄ± idareli kullanÄ±lmalÄ±dÄ±r.</li></ul><h4>Yerel Kod Testi ve Hata AyÄ±klama</h4><p>Yerel koddaki bir Ã§Ã¶kme tÃ¼m JVM&#39;i sonlandÄ±rabilir.</p><ul><li>cudaGetLastError() gibi CUDA hata kontrol API&#39;lerini tutarlÄ± bir ÅŸekilde kullanÄ±n.</li><li>cudaDeviceSynchronize() ile eÅŸzamansÄ±z hatalarÄ± yakalamak iÃ§in gÃ¼venilir kontrol noktalarÄ± oluÅŸturun.</li><li>NVIDIA Nsight gibi hata ayÄ±klama araÃ§larÄ± kullanÄ±n.</li></ul><h4>GÃ¼venlik ve Ä°zolasyon</h4><p>Yerel kod, tehdit yÃ¼zeyinizin bir parÃ§asÄ±dÄ±r.</p><ul><li>JNI&#39;yi Ã§aÄŸÄ±rmadan Ã¶nce Java tarafÄ±ndaki girdileri her zaman doÄŸrulayÄ±n.</li><li>CUDA Ã§ekirdekleri iÃ§inde dinamik bellek tahsisinden kaÃ§Ä±nÄ±n.</li><li>SaldÄ±rÄ± yÃ¼zeyini kÃ¼Ã§Ã¼ltmek iÃ§in yerel modÃ¼llerdeki baÄŸÄ±mlÄ±lÄ±klarÄ± en aza indirin.</li></ul><h4>DaÄŸÄ±tÄ±m ve TaÅŸÄ±nabilirlik</h4><p>GPU hÄ±zlandÄ±rmalÄ± kodu daÄŸÄ±tmak, sadece bir JAR paketlemekten daha fazlasÄ±dÄ±r. GPU sÃ¼rÃ¼cÃ¼ uyumluluÄŸu, CUDA Ã§alÄ±ÅŸma zamanÄ± baÄŸÄ±mlÄ±lÄ±klarÄ± ve iÅŸletim sistemi farklÄ±lÄ±klarÄ± gibi konularÄ± ele almanÄ±z gerekir. TutarlÄ±lÄ±k iÃ§in CMake gibi derleme araÃ§larÄ± kullanmak ve daÄŸÄ±tÄ±mlarÄ± nvidia-docker ile kapsayÄ±cÄ± hale getirmek en iyisidir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hygt0PtGKXiQf3cZ4GuPjw.png" /></figure><h3>SonuÃ§ ve Gelecek</h3><p>Java ve CUDA&#39;nÄ±n birleÅŸimi henÃ¼z ana akÄ±m olmasa da, kurumsal sistemler iÃ§in yeni bir performans sÄ±nÄ±fÄ±nÄ±n kapÄ±larÄ±nÄ± aralamaktadÄ±r. Bu entegrasyon, CPU&#39;larÄ±n tek baÅŸÄ±na eÅŸleÅŸemeyeceÄŸi hÄ±zlanmalar sunmaktadÄ±r.</p><h3>Neden Bu Ã–nemli?</h3><p>Java geliÅŸtiricileri artÄ±k sadece iÅŸ parÃ§acÄ±ÄŸÄ± havuzlarÄ± ile sÄ±nÄ±rlÄ± deÄŸildir. CUDA&#39;ya kÃ¶prÃ¼ kurarak, tÃ¼m yÄ±ÄŸÄ±nÄ± yeniden yazmadan HPC tarzÄ± yÃ¼rÃ¼tmeyi standart kurumsal sistemlere taÅŸÄ±yabilirler.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Tl7r4zJalGbw4_0W6h4MCQ.png" /></figure><ul><li><strong>Hibrit CPU-GPU Zamanlama Modelleri:</strong> Ä°ÅŸ yÃ¼klerini CPU ve GPU arasÄ±nda dinamik olarak dengeleyebilen hibrit zamanlama stratejileri Ã¼zerine araÅŸtÄ±rmalar devam etmektedir. &quot;HybriMoE&quot; gibi Ã§erÃ§eveler, bu dengelemeyi ve Ã¶nbellek yÃ¶netimini iyileÅŸtirmek iÃ§in algoritmalar sunmaktadÄ±r.</li><li><strong>ONNX TabanlÄ± AI Model Ã‡Ä±karÄ±mÄ± (Inference):</strong> Yapay zeka modellerinin GPU&#39;larda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± giderek daha Ã¶nemli hale gelmektedir. ONNX (Open Neural Network Exchange), farklÄ± makine Ã¶ÄŸrenimi Ã§erÃ§evelerinden modelleri temsil etmek iÃ§in bir standart sunar. Microsoft&#39;un ONNX Runtime&#39;Ä±, bu modelleri JVM Ã¼zerinde Ã§alÄ±ÅŸtÄ±rmak iÃ§in bir Java baÄŸlamasÄ± saÄŸlar, bu da PyTorch veya TensorFlow&#39;da eÄŸitilmiÅŸ modellerin Java uygulamalarÄ±na kolayca entegre edilmesini saÄŸlar.</li><li><strong>Foreign Function &amp; Memory API (JEP 454) Benimsenmesi:</strong> JNI&#39;nin yerini almasÄ± beklenen bu API, yerel kÃ¼tÃ¼phaneleri Ã§aÄŸÄ±rmak iÃ§in daha gÃ¼venli ve modern bir yaklaÅŸÄ±m sunmaktadÄ±r. Bellek gÃ¼venliÄŸini (sÄ±nÄ±r dÄ±ÅŸÄ± eriÅŸim ve use-after-free hatalarÄ±nÄ± Ã¶nleyerek) ve kullanÄ±m kolaylÄ±ÄŸÄ±nÄ± artÄ±rÄ±rken, JNI&#39;ye benzer veya daha iyi performans hedeflemektedir. Java 24&#39;te JNI kullanÄ±mÄ±na iliÅŸkin uyarÄ±larÄ±n baÅŸlamasÄ±, bu yeni API&#39;nin gelecekte standart olacaÄŸÄ±nÄ± gÃ¶stermektedir. GeliÅŸtiricilerin bu API&#39;yi yakÄ±ndan takip etmeleri bÃ¼yÃ¼k Ã¶nem taÅŸÄ±maktadÄ±r.</li></ul><p>Bu geliÅŸmeler, Java&#39;nÄ±n yÃ¼ksek performanslÄ± bilgi iÅŸlem alanÄ±ndaki yeteneklerini daha da geniÅŸletecektir.</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=072e32246444" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Java ve Yapay Zeka: Yeni DÃ¶nemin KapÄ±larÄ± AralanÄ±yor mu? ]]>
</title>
<link>https://pehlivanmert.medium.com/java-ve-yapay-zeka-yeni-d%C3%B6nemin-kap%C4%B1lar%C4%B1-aralan%C4%B1yor-mu-facc0a6d77c8?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/facc0a6d77c8</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 18 Jun 2025 01:07:20 GMT</pubDate>
<atom:updated>2025-06-20T05:12:08.264Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qBWnKbUvnfLp74YIbEmkig.png" /></figure><p>Son dÃ¶nemde Yapay Zeka (YZ) alanÄ±ndaki hÄ±zlÄ± geliÅŸmeler, sektÃ¶rÃ¼n gÃ¼ndemini belirliyor. Genellikle Python ile Ã¶zdeÅŸleÅŸtirilen YZ geliÅŸtirme sÃ¼reÃ§leri, Java platformunda da dikkat Ã§ekici ilerlemeler kaydediyor. Oracleâ€™Ä±n â€œJava for AIâ€ sunumu, bu konudaki mevcut ve gelecekteki Ã§alÄ±ÅŸmalarÄ± oldukÃ§a detaylÄ± bir ÅŸekilde ele alÄ±yor. Bir yazÄ±lÄ±mcÄ± olarak bu yenilikleri keÅŸfetmek oldukÃ§a heyecan vericiydi ve sizinle de paylaÅŸmak istedim.</p><p>Java, yÃ¼ksek performans ve geliÅŸtirici verimliliÄŸi gibi temel Ã¶zellikleriyle bilinen, genel amaÃ§lÄ± bir programlama platformu. Bu gÃ¼Ã§lÃ¼ yanlar, YZâ€™nÄ±n Ã¶zel gereksinimlerini karÅŸÄ±lamak Ã¼zere titizlikle adapte ediliyor. Sunumda da belirtildiÄŸi gibi, platforma eklenen yenilikler sadece YZ odaklÄ± deÄŸil, aynÄ± zamanda daha geniÅŸ kullanÄ±m alanlarÄ±na hitap ediyor; bu da Javaâ€™nÄ±n uzun soluklu baÅŸarÄ±sÄ±nÄ±n ardÄ±ndaki temel felsefelerden biri.</p><h3>Javaâ€™nÄ±n YZ Ä°Ã§in Ã–ne Ã‡Ä±kan Ã–zellikleri</h3><p>Sunumda, YZ geliÅŸtirmeleri iÃ§in kritik kabul edilen dÃ¶rt temel Java platformu Ã¶zelliÄŸi tanÄ±tÄ±lÄ±yor:</p><ul><li>Foreign Function and Memory API (Proje Panama): Java dÄ±ÅŸÄ±ndaki belleÄŸi (off-heap memory) daha verimli kullanmayÄ± ve yerel kÃ¼tÃ¼phanelerle etkileÅŸimi gÃ¼venli, hÄ±zlÄ± ve Ã¼retken bir hale getirmeyi saÄŸlÄ±yor. Ã–zellikle sÄ±fÄ±r kopyalama senaryolarÄ±nda bu Ã¶zellik kritik Ã¶neme sahip.</li><li>Vector API (Proje Panama): Javaâ€™da SIMD (Single Instruction, Multiple Data) programlamayÄ± mÃ¼mkÃ¼n kÄ±larak CPUâ€™nun etkin kullanÄ±mÄ±nÄ± saÄŸlÄ±yor. YZ ve makine Ã¶ÄŸrenimi algoritmalarÄ± iÃ§in temel olan sayÄ±sal hesaplamalarÄ± (Ã¶rneÄŸin nokta Ã§arpÄ±mÄ±) ciddi oranda hÄ±zlandÄ±rÄ±yor.</li><li>Value Classes and Objects (Proje Valhalla): YÄ±ÄŸÄ±n iÃ§i (on-heap) belleÄŸin optimal kullanÄ±mÄ±nÄ± hedefliyor ve Float16, Bfloat16 gibi YZâ€™da sÄ±kÃ§a kullanÄ±lan yeni sayÄ± tÃ¼rlerinin platforma entegrasyonunu kolaylaÅŸtÄ±racak.</li><li>Code Reflection (Proje Babylon): GPUâ€™lar (CUDA) veya ONNX gibi farklÄ± programlama modelleriyle etkileÅŸimi mÃ¼mkÃ¼n kÄ±lÄ±yor. Java kodunun otomatik tÃ¼revini (auto-differentiation) destekleyerek, platformun bu tÃ¼r spesifik detaylarÄ± kÃ¼tÃ¼phanelere devretmesini saÄŸlÄ±yor, bu da geliÅŸtiricilere esneklik sunuyor.</li></ul><h3>Mevcut Durum ve Gelecek Potansiyeli</h3><p>YZ model geliÅŸtirmenin bÃ¼yÃ¼k bir kÄ±smÄ± ÅŸu anda Pythonâ€™da yoÄŸunlaÅŸmÄ±ÅŸ durumda. Ancak sunumda bahsedilen Ã¶zelliklerin Javaâ€™yÄ± YZ ekosisteminde daha rekabetÃ§i bir konuma getirme potansiyeli dikkat Ã§ekici. Bu Ã¶zellikler olmadan da YZ Ã§Ã¶zÃ¼mleri geliÅŸtirilebilir; ancak sunuma gÃ¶re, bu yeni araÃ§lar tasarÄ±m, geliÅŸtirme, sÃ¼rdÃ¼rme ve evrim sÃ¼reÃ§lerini Ã¶nemli Ã¶lÃ§Ã¼de kolaylaÅŸtÄ±rÄ±yor.</p><p>Sunumda, yeni Ã¶zelliklerin pratik uygulamalarÄ±nÄ± gÃ¶steren Ã§arpÄ±cÄ± Ã¶rneklere de yer veriliyor:</p><ul><li>Llama Model Ã‡Ä±karÄ±mÄ±: FFM ve Vector API kullanÄ±larak Javaâ€™da Llama 2 modelinin performansÄ±ndaki artÄ±ÅŸ (1.3 tokenden ~15 token/saniyeye) gÃ¶z dolduruyor.</li><li>Anomali Tespiti (MSET 2): Matris API, FFM API ve Vector API kullanarak Javaâ€™da uygulanan bu algoritmanÄ±n, CUDA, MATLAB ve Python/NumPy implementasyonlarÄ±ndan daha iyi performans gÃ¶sterdiÄŸi ve halihazÄ±rda Ã¼retimde kullanÄ±ldÄ±ÄŸÄ± belirtiliyor.</li><li>ONNX Script for Java: Code Reflection ve FFM API kullanarak Java kodundan ONNX makine Ã¶ÄŸrenimi modelleri oluÅŸturma yeteneÄŸi sergileniyor.</li></ul><h3>Kilit Bilgiler ve Daha FazlasÄ±</h3><ul><li>Proje Panama (FFM ve Vector API) Java 22&#39;den itibaren kullanÄ±labilir durumda (FFM API final sÃ¼rÃ¼mde, Vector API ise halen geliÅŸtirme aÅŸamasÄ±nda).</li><li>Proje Valhalla ve Proje Babylon ise aktif olarak geliÅŸtirilmeye devam eden gelecek vaat eden Ã¶zellikler.</li><li>Javaâ€™nÄ±n YZ alanÄ±ndaki bu yenilikleri, temel olarak bellek kullanÄ±mÄ±nÄ± optimize etmeyi, donanÄ±m kullanÄ±mÄ±nÄ± verimli hale getirmeyi, yerel kodlarla etkileÅŸimi gÃ¼Ã§lendirmeyi ve yeni sayÄ± tÃ¼rlerini desteklemeyi hedefliyor.</li></ul><p>TÃ¼m bu geliÅŸmeler Ä±ÅŸÄ±ÄŸÄ±nda, Java platformunun YZ, yÃ¼ksek performanslÄ± hesaplama ve bÃ¼yÃ¼k veri alanlarÄ±ndaki zorluklarÄ± ele almak iÃ§in dinamik bir geliÅŸim iÃ§inde olduÄŸunu sÃ¶yleyebiliriz. Bu Ã¶zellikler, Javaâ€™da performans odaklÄ± YZ Ã§Ã¶zÃ¼mleri oluÅŸturma potansiyelini artÄ±rÄ±yor.</p><p>Bu konuya daha derinlemesine bakmak isterseniz, ilgili <a href="https://www.youtube.com/watch?v=-XnyJad88Ss&amp;t=2s">Oracle OpenJDK topluluÄŸu sunumunu</a> izlemenizi ÅŸiddetle tavsiye ederim. GerÃ§ekten ufuk aÃ§Ä±cÄ± bilgiler iÃ§eriyor.</p><p>Siz bu geliÅŸmeler hakkÄ±nda ne dÃ¼ÅŸÃ¼nÃ¼yorsunuz? Javaâ€™nÄ±n YZ ekosistemindeki yeri gelecekte nasÄ±l ÅŸekillenebilir?</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=facc0a6d77c8" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Gelecek KapÄ±mÄ±zda: Yapay ZekÃ¢ YazÄ±lÄ±mcÄ±larÄ±n Sonunu Mu Getirecek, Yoksa Yeni Bir Ã‡aÄŸ MÄ± BaÅŸlatacak? ]]>
</title>
<link>https://pehlivanmert.medium.com/gelecek-kap%C4%B1m%C4%B1zda-yapay-zek%C3%A2-yaz%C4%B1l%C4%B1mc%C4%B1lar%C4%B1n-sonunu-mu-getirecek-yoksa-yeni-bir-%C3%A7a%C4%9F-m%C4%B1-ba%C5%9Flatacak-4235efc6f12b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4235efc6f12b</guid>
<category>
<![CDATA[ development ]]>
</category>
<category>
<![CDATA[ ai ]]>
</category>
<category>
<![CDATA[ developer-tools ]]>
</category>
<category>
<![CDATA[ developer ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 04 Jun 2025 16:39:51 GMT</pubDate>
<atom:updated>2025-06-20T05:12:30.301Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j76ggknKxckfMfZssQgy1g.png" /></figure><p>Son yÄ±llarda yapay zekÃ¢ (YZ) rÃ¼zgarÄ±, yazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ±nda fÄ±rtÄ±nalar estiriyor. Kod tamamlama, otomatik hata dÃ¼zeltme gibi YZ destekli araÃ§lar sayesinde projelerimiz hÄ±zla ÅŸekilleniyor; Copilot gibi yardÄ±mcÄ±lar iÅŸlerimizi %55&#39;e varan oranlarda hÄ±zlandÄ±rabiliyor. BirÃ§oÄŸumuz bu devrimi kucaklayarak verimliliÄŸimizin arttÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Ancak, bir kesim yazÄ±lÄ±mcÄ± hÃ¢lÃ¢ endiÅŸeli: Ya YZ, iÅŸimizi tamamen elimizden alÄ±rsa?</p><p>EndiÅŸelerin aksine, PwCâ€™nin 2025 YZ Ä°ÅŸ Barometresi bize umut veriyor: YZâ€™nin etkilediÄŸi pek Ã§ok meslekte hem istihdam hem de Ã¼cret seviyeleri artÄ±ÅŸ gÃ¶steriyor. Peki, yazÄ±lÄ±mcÄ±larÄ±n geleceÄŸi nasÄ±l ÅŸekillenecek? Gelin, bu sorunun kÄ±sa ve uzun vadeli etkilerine yakÄ±ndan bakalÄ±m.</p><h3>KÄ±sa Vadede YazÄ±lÄ±mcÄ±lar Ä°Ã§in FÄ±rsatlar ve Zorluklar</h3><h4>Yeni BaÅŸlayanlar ve Junior GeliÅŸtiriciler: Ã–ÄŸrenme ve Adaptasyon Vakti!</h4><p>Junior yazÄ±lÄ±mcÄ±lar iÃ§in YZ araÃ§larÄ± gerÃ§ek bir oyun deÄŸiÅŸtirici. StackOverflow anketine gÃ¶re, kod yazmayÄ± Ã¶ÄŸrenenlerin %82&#39;si YZ araÃ§larÄ±nÄ± kullanÄ±yor veya kullanmayÄ± planlÄ±yor. Bilimsel Ã§alÄ±ÅŸmalar da gÃ¶steriyor ki, Copilot gibi araÃ§lar Ã¶zellikle deneyimsiz geliÅŸtiricilere bÃ¼yÃ¼k fayda saÄŸlÄ±yor. Rutin kodlama gÃ¶revlerini hÄ±zla halletmelerine olanak tanÄ±rken, temel becerilerini pekiÅŸtirmelerine yardÄ±mcÄ± oluyor.</p><p>Ancak dikkat! YZâ€™nin Ã¼rettiÄŸi kodun doÄŸruluÄŸunu ve kalitesini kontrol etme, algoritma mantÄ±ÄŸÄ±nÄ± kavrayarak kodu denetleme sorumluluÄŸu hÃ¢lÃ¢ juniorlarÄ±n omuzlarÄ±nda. Bu, kÄ±sa vadede onlar iÃ§in muazzam bir Ã¶ÄŸrenme fÄ±rsatÄ± sunarken, aynÄ± zamanda YZ Ã¶nerilerine temkinli yaklaÅŸmayÄ± Ã¶ÄŸrenmeleri gerektiÄŸi anlamÄ±na geliyor.</p><h4>Orta Seviye GeliÅŸtiriciler: Verimlilikte Vites ArtÄ±rma ZamanÄ±!</h4><p>Profesyonel yazÄ±lÄ±mcÄ±larÄ±n %70&#39;i kÄ±sa vadede YZ araÃ§larÄ±nÄ± kullanmaya baÅŸlamÄ±ÅŸ veya planlÄ±yor. Orta seviye geliÅŸtiriciler, deneyimleri sayesinde YZâ€™nin kod Ã¶nerilerini eleÅŸtirel bir gÃ¶zle deÄŸerlendirip, sadece tekrarlÄ± iÅŸleri hÄ±zlandÄ±rmak iÃ§in kullanabilirler. YZ, bu grup iÃ§in zaman alan ve tekrarlayan iÅŸleri otomatikleÅŸtirerek, onlarÄ± daha karmaÅŸÄ±k problemlere ve mimari tasarÄ±ma odaklanmaya teÅŸvik edecek. BÃ¶ylece hem verimlilik kazanacaklar hem de Ã¼st dÃ¼zey gÃ¶revlerle birlikte yÃ¶netim becerilerini geliÅŸtirme imkanÄ± bulacaklar.</p><h4>KÄ±demli (Senior) GeliÅŸtiriciler: Stratejik Liderlik Ã–n Planda!</h4><p>Deneyimli yazÄ±lÄ±mcÄ±lar, genellikle mimari tasarÄ±m, ekip yÃ¶netimi ve karmaÅŸÄ±k problem Ã§Ã¶zme gibi kritik roller Ã¼stlenirler. Copilot ile yapÄ±lan deneyler, Ã¶zellikle 25â€“44 yaÅŸ arasÄ± geliÅŸtiricilerin YZ araÃ§larÄ±ndan Ã¶nemli Ã¶lÃ§Ã¼de fayda saÄŸladÄ±ÄŸÄ±nÄ± gÃ¶steriyor. KÄ±sa vadede kÄ±demli geliÅŸtiriciler, tekrarlÄ± kodlama iÅŸleriyle uÄŸraÅŸmak yerine, ekiplerine rehberlik etmeye, sÃ¼reÃ§leri iyileÅŸtirmeye ve yeni teknolojileri entegre etmeye odaklanacaklar. YZ onlara zaman kazandÄ±rÄ±rken, asÄ±l katma deÄŸer yaratan karmaÅŸÄ±k iÅŸlerin sorumluluÄŸu yine kÄ±demli ekibin Ã¼zerinde kalacak.</p><h3>Uzun Vadede YazÄ±lÄ±mcÄ±lar Ä°Ã§in BÃ¼yÃ¼k DÃ¶nÃ¼ÅŸÃ¼mler</h3><h4>Yeni BaÅŸlayanlar ve Junior GeliÅŸtiriciler: SÃ¼rekli Ã–ÄŸrenmenin Ã–nemi</h4><p>Uzun vadede, YZâ€™nin kod Ã¼retme yeteneÄŸinin artmasÄ±yla juniorlarÄ±n rollerinde kÃ¶klÃ¼ deÄŸiÅŸiklikler gÃ¶rÃ¼lebilir. Bir Ã§alÄ±ÅŸma, 2040&#39;ta makinelerin kendi kodlarÄ±nÄ±n Ã§oÄŸunu yazabileceÄŸini Ã¶ngÃ¶rÃ¼yor. Ancak endiÅŸelenmeyin! Bu senaryoda bile geliÅŸtiricilerin tamamen ortadan kalkmayacaÄŸÄ± tahmin ediliyor; Ã§Ã¼nkÃ¼ insanlarÄ±n Ã¶zellikle <strong>veri hazÄ±rlama, algoritma tasarÄ±mÄ± ve sistem entegrasyonu</strong> gibi alanlara odaklanmasÄ± gerekecek.</p><p>Zaten yazÄ±lÄ±mcÄ±lar olarak sÃ¼rekli Ã¶ÄŸrenmeye alÄ±ÅŸkÄ±n bir grubuz; 2015â€“2022 arasÄ±nda gerekli becerilerin %30&#39;dan fazla deÄŸiÅŸtiÄŸini gÃ¶rÃ¼yoruz. TÃ¼rkiyeâ€™de de geleceÄŸe yÃ¶nelik raporlar, Ã§alÄ±ÅŸanlarÄ±n %59&#39;unun yeniden eÄŸitime ihtiyaÃ§ duyacaÄŸÄ±nÄ± vurguluyor. KÄ±sacasÄ±, junior geliÅŸtiriciler iÃ§in uzun vadeli yol haritasÄ±, YZ ile Ã§alÄ±ÅŸmayÄ± Ã¶ÄŸrenmek ve sÃ¼rekli yeni beceriler kazanmak Ã¼zerine kurulu olacak.</p><h4>Orta Seviye GeliÅŸtiriciler: LiderliÄŸe ve YaratÄ±cÄ±lÄ±ÄŸa DoÄŸru!</h4><p>GeÃ§miÅŸteki teknolojik devrimler yeni uzmanlÄ±klar ve iÅŸ alanlarÄ± yaratarak yazÄ±lÄ±mcÄ± talebini artÄ±rdÄ±. Benzer ÅŸekilde, yazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ± 2030 ve Ã¶tesine evrildikÃ§e, kodun bir kÄ±smÄ±nÄ±n YZâ€™ye devredilmesi beklense de geliÅŸtiricilere her zaman ihtiyaÃ§ duyulacak. YZ destekli otomasyon rutin iÅŸleri Ã¼stlenirken, yÃ¼ksek dÃ¼zeyde <strong>yaratÄ±cÄ±lÄ±k ve problem Ã§Ã¶zme</strong> gerektiren gÃ¶revler insanlara bÄ±rakÄ±lacak. Orta dÃ¼zey geliÅŸtiriciler ise uzun vadede <strong>ekip liderliÄŸi, proje yÃ¶netimi ve yeni nesil uygulamalarÄ±n geliÅŸtirilmesi</strong> gibi rollere kayarak deÄŸer katmaya devam edecekler. Yani kodun Ã§oÄŸu otomatikleÅŸse bile, yazÄ±lÄ±mcÄ±larÄ±n yÃ¶nlendirme ve uyarlama rolÃ¼ sÃ¼recek.</p><h4>KÄ±demli (Senior) GeliÅŸtiriciler: OrganizasyonlarÄ±n Rehberleri!</h4><p>Uzun dÃ¶nemde de kÄ±demli geliÅŸtiriciler <strong>stratejik karar alma, bÃ¼yÃ¼k sistemleri tasarlama ve ekipleri yÃ¶nlendirme</strong> gÃ¶revlerinde kilit Ã¶nemde kalacak. Yapay zekÃ¢ uygulamalarÄ± yaygÄ±nlaÅŸtÄ±kÃ§a, bu yazÄ±lÄ±mcÄ±lar yeni sÃ¼reÃ§leri uyarlama, proje planlama ve veri temelli karar alma konularÄ±nda ekiplerine Ã¶ncÃ¼lÃ¼k edecekler. AyrÄ±ca, kurum iÃ§i eÄŸitim programlarÄ± ve hackathonlar dÃ¼zenleyerek, daha az deneyimli meslektaÅŸlarÄ±nÄ±n YZ araÃ§larÄ±nÄ± Ã¶ÄŸrenmesine katkÄ± saÄŸlayacaklarÄ± Ã¶ngÃ¶rÃ¼lÃ¼yor. BÃ¶ylece kÄ±demli geliÅŸtiriciler, hÄ±zla deÄŸiÅŸen teknolojik ortamda organizasyonlarÄ±n yol gÃ¶sterici figÃ¼rleri olmaya devam edecekler.</p><h3>YZâ€™nin DiÄŸer Mesleklere Etkisi ve KÃ¼resel Trendler</h3><p>Yapay zekÃ¢ etkisi sadece yazÄ±lÄ±mcÄ±larla sÄ±nÄ±rlÄ± kalmayacak. DÃ¼nya Ekonomik Forumu (WEF) 2030 projeksiyonlarÄ±na gÃ¶re, yazÄ±lÄ±m geliÅŸtiriciler ve YZ/ML uzmanlarÄ± gibi teknoloji odaklÄ± roller en hÄ±zlÄ± bÃ¼yÃ¼yen meslek gruplarÄ± arasÄ±nda yer alacak. Buna karÅŸÄ±lÄ±k, kasiyer, sekreter ve veri giriÅŸi gibi rutin ofis iÅŸleri azalma eÄŸiliminde. WEF ayrÄ±ca, 2025â€“2030 arasÄ±nda dÃ¼nya genelinde <strong>170 milyon yeni iÅŸ yaratÄ±lacaÄŸÄ±nÄ±</strong>, yaklaÅŸÄ±k 92 milyon iÅŸ kaybÄ± olacaÄŸÄ±nÄ± (net yaklaÅŸÄ±k +78 milyon) Ã¶ngÃ¶rÃ¼yor. Bu veriler, YZâ€™nin genel istihdama bÃ¼yÃ¼k oranda olumlu yansÄ±dÄ±ÄŸÄ±nÄ± gÃ¶steriyor.</p><p>Ã–zellikle saÄŸlÄ±k, eÄŸitim ve yenilenebilir enerji gibi insan merkezli sektÃ¶rlerde bÃ¼yÃ¼me sÃ¼rerken; montaj, lojistik ve mÃ¼ÅŸteri hizmetleri gibi otomasyona uygun iÅŸler gÃ¶zden geÃ§irme gerektirecek. Ã–zetle, dÃ¼ÅŸÃ¼k vasÄ±flÄ± ve tekrarlÄ± iÅŸlerde risk yÃ¼ksek, yÃ¼ksek teknoloji ve yaratÄ±cÄ± iÅŸlerde ise yeni fÄ±rsatlar Ã¶ne Ã§Ä±kÄ±yor.</p><h3>TÃ¼rkiye ve Avrupa BirliÄŸi Perspektifi: DÃ¶nÃ¼ÅŸÃ¼m BaÅŸlÄ±yor!</h3><p>TÃ¼rkiye Ã¶zelinde, Google destekli bir Ã§alÄ±ÅŸma Ã¶nÃ¼mÃ¼zdeki 10 yÄ±lda YZâ€™nin ulusal GSYHâ€™ye %5&#39;e yakÄ±n katkÄ± saÄŸlayabileceÄŸini ve mevcut iÅŸ pozisyonlarÄ±nÄ±n %59&#39;unun YZâ€™den etkilenebileceÄŸini Ã¶ngÃ¶rÃ¼yor. YaklaÅŸÄ±k 17 milyon iÅŸ YZ ile Ã¼retkenlik kazanÄ±rken, 13 milyon iÅŸ otomasyondan fazla etkilenmeyip sabit kalacak; geriye kalan %4 ise tamamen dÃ¶nÃ¼ÅŸÃ¼me uÄŸrayacak. Bu tablo, TÃ¼rkiyeâ€™de net bir iÅŸ kaybÄ± beklenmediÄŸini gÃ¶steriyor. Ancak, YZâ€™nin iÅŸyerlerine entegrasyonunda <strong>ÅŸeffaflÄ±k, iÅŸÃ§i haklarÄ± ve yeniden eÄŸitim</strong> Ã¶ncelikli konular arasÄ±nda.</p><p>Avrupa BirliÄŸi genelinde de benzer bir iyimserlik hakim; ECB anketinde Ã§alÄ±ÅŸanlarÄ±n %41&#39;i YZâ€™nin iÅŸlerini iyileÅŸtireceÄŸini dÃ¼ÅŸÃ¼nÃ¼rken, yalnÄ±zca %20&#39;si olumsuz etkiler bekliyor. Ã–nemli olan, bu deÄŸiÅŸime hazÄ±rlanmak ve yaÅŸam boyu Ã¶ÄŸrenme yaklaÅŸÄ±mÄ±nÄ± benimsemek.</p><h3>GeleceÄŸe NasÄ±l HazÄ±rlanmalÄ±yÄ±z?</h3><p>Yapay zekÃ¢nÄ±n geliÅŸimi, yazÄ±lÄ±m sektÃ¶rÃ¼ ve diÄŸer meslek gruplarÄ± iÃ§in hem fÄ±rsatlar hem de meydan okumalar getiriyor. Mevcut veriler Ä±ÅŸÄ±ÄŸÄ±nda, genel kanÄ± yeni iÅŸ yaratma eÄŸilimlerinin aÄŸÄ±r bastÄ±ÄŸÄ± yÃ¶nÃ¼nde; ancak dÃ¶nÃ¼ÅŸÃ¼mden en Ã§ok etkilenecek alanlarda <strong>beceri ve yeniden eÄŸitim ihtiyacÄ±</strong> artacak. Bir yazÄ±lÄ±mcÄ± olarak aÅŸaÄŸÄ±daki Ã§Ä±karÄ±mlarÄ± Ã¶ncelikli gÃ¶rÃ¼yorum:</p><ul><li><strong>SÃ¼rekli Ã–ÄŸrenme:</strong> Yapay zekÃ¢ ve makine Ã¶ÄŸrenimi temellerini, yeni YZ araÃ§larÄ±nÄ± Ã¶ÄŸrenmek ÅŸart. Kurslar, sertifikalar ve proje Ã§alÄ±ÅŸmalarÄ±yla becerimizi gÃ¼ncel tutmalÄ±yÄ±z.</li><li><strong>YZ AraÃ§larÄ±na Uyum SaÄŸlama:</strong> Kod tamamlama, veri analizi ve otomasyon araÃ§larÄ±nÄ± aktif kullanmak, verimliliÄŸimizi artÄ±rÄ±r. Deneme atÃ¶lyeleri veya hackathonâ€™lar dÃ¼zenleyerek bilgi paylaÅŸabiliriz.</li><li><strong>Esneklik ve Ä°letiÅŸim:</strong> Ä°ÅŸ dÃ¼nyasÄ±nda YZ uygulamalarÄ±nÄ± benimserken iÅŸverenlerle yakÄ±n iÅŸbirliÄŸi yapmalÄ±, belirsizliklere karÅŸÄ± ÅŸeffaflÄ±k talep etmeliyiz. Diyalog kanallarÄ± bu sÃ¼reÃ§te kritik Ã¶nemde.</li><li><strong>Yeni UzmanlÄ±klara YÃ¶nelim:</strong> Veri bilimi, yapay zekÃ¢ mÃ¼hendisliÄŸi ve YZ uygulama geliÅŸtirme gibi alanlara yatÄ±rÄ±m yapmak gelecek iÃ§in avantaj saÄŸlayacak.</li><li><strong>DeÄŸer OluÅŸturmaya Odaklanma:</strong> TekrarlÄ± ve kolay otomatikleÅŸebilir iÅŸler yerine yaratÄ±cÄ±, problem Ã§Ã¶zmeye yÃ¶nelik gÃ¶revlerde uzmanlaÅŸmak Ã¶nemli. Mimari tasarÄ±m, kullanÄ±cÄ± deneyimi, stratejik planlama gibi insan becerisi gerektiren konularda kendimizi geliÅŸtirmeliyiz.</li></ul><p>SonuÃ§ olarak, kÄ±sa vadede Ã¼retkenlik artÄ±ÅŸÄ± Ã¶ne Ã§Ä±karken uzun vadede iÅŸ dÃ¼nyasÄ± dÃ¶nÃ¼ÅŸtÃ¼kÃ§e rolleri uyarlamak kaÃ§Ä±nÄ±lmaz olacak. YazÄ±lÄ±m geliÅŸtiricileri, YZ Ã§aÄŸÄ±nda yeni araÃ§lara ayak uydurarak katma deÄŸer yaratmayÄ± sÃ¼rdÃ¼recekler. DoÄŸru eÄŸitim ve politika adÄ±mlarÄ±yla, TÃ¼rkiye ve ABâ€™de de bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼n yeni iÅŸ fÄ±rsatlarÄ±na dÃ¶nÃ¼ÅŸmesi hedefleniyor. Ancak herkesin bu deÄŸiÅŸime hazÄ±rlanmasÄ±, <strong>yaÅŸam boyu Ã¶ÄŸrenme</strong> yaklaÅŸÄ±mÄ±nÄ± benimsemesi ÅŸart. UnutmayÄ±n, yapay zekÃ¢ bÃ¼yÃ¼k ihtimalle iÅŸleri yok etmeyecek, sadece dÃ¶nÃ¼ÅŸtÃ¼recek; Ã¶nemli olan bu dÃ¶nÃ¼ÅŸÃ¼mden en kÃ¢rlÄ± Ã§Ä±kan taraf olmaktÄ±r.</p><p><strong>Peki siz bu dÃ¶nÃ¼ÅŸÃ¼mÃ¼n neresinde yer almayÄ± hedefliyorsunuz?</strong></p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4235efc6f12b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Bootâ€™u Quarkus ile DeÄŸiÅŸtirdim: Daha HÄ±zlÄ±, Daha Hafif Java UygulamalarÄ±na GeliÅŸtiriciâ€¦ ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-bootu-quarkus-ile-de%C4%9Fi%C5%9Ftirdim-daha-h%C4%B1zl%C4%B1-daha-hafif-java-uygulamalar%C4%B1na-geli%C5%9Ftirici-3d7a41a19117?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/3d7a41a19117</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 27 May 2025 21:25:19 GMT</pubDate>
<atom:updated>2025-06-20T05:13:05.719Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jePivlT6_mBMahzWD2TCQQ.png" /></figure><h3>Spring Bootâ€™u Quarkus ile DeÄŸiÅŸtirdim: Daha HÄ±zlÄ±, Daha Hafif Java UygulamalarÄ±na GeliÅŸtirici YolculuÄŸum ğŸš€</h3><p><strong>TanÄ±dÄ±k bir dosttan yeni bir yarÄ±ÅŸmacÄ±ya geÃ§iÅŸ deneyimimi paylaÅŸtÄ±ÄŸÄ±m, iÃ§gÃ¶rÃ¼lerim ve kod Ã¶rnekleriyle dolu bir yazÄ± kaleme aldÄ±m.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*41fzbNVSA4wcJZiJaDlYLA.png" /></figure><p>YÄ±llardÄ±r <strong>Spring Boot</strong>, Java uygulamalarÄ± geliÅŸtirmek iÃ§in vazgeÃ§ilmez frameworkâ€™Ã¼m oldu. SaÄŸlam, devasa bir topluluÄŸa ve akla gelebilecek neredeyse her ihtiyacÄ± karÅŸÄ±layan bir ekosisteme sahip. Ancak son zamanlarda, sÄ±k sÄ±k â€œSÃ¼personik AtomaltÄ± Javaâ€ olarak lanse edilen <strong>Quarkus</strong> etrafÄ±ndaki heyecanÄ± duyuyordum. Ä°nanÄ±lmaz hÄ±zlÄ± aÃ§Ä±lÄ±ÅŸ sÃ¼releri, dÃ¼ÅŸÃ¼k bellek kullanÄ±mÄ± ve GraalVM ile sorunsuz native derleme vaatleri gÃ¶rmezden gelinemeyecek kadar cazipti.</p><p>Bu yÃ¼zden bir denemeye karar verdim: Mevcut Spring Boot mikroservislerimden birini seÃ§tim ve Quarkusâ€™a taÅŸÄ±dÄ±m. Bu makale benim hikayemâ€Šâ€”â€Šnedenleri, nasÄ±llarÄ±, zorluklarÄ± ve sonuÃ§larÄ±. AmacÄ±m, benzer bir geÃ§iÅŸ yapmayÄ± merak eden junior ve orta seviye geliÅŸtirici arkadaÅŸlarÄ±ma pratik bir yol haritasÄ± sunmak. Quarkusâ€™un gerÃ§ekten de sÃ¶ylendiÄŸi kadar iyi olup olmadÄ±ÄŸÄ±nÄ± ve geliÅŸtirme iÅŸ akÄ±ÅŸÄ±nÄ±z iÃ§in ne anlama geldiÄŸini keÅŸfedeceÄŸiz.</p><p>Bu yazÄ±da ÅŸunlarÄ± ele alacaÄŸÄ±z:</p><ul><li>Spring Boot dÃ¼nyasÄ±nda neden Quarkusâ€™u dÃ¼ÅŸÃ¼nmelisiniz?</li><li>BaÅŸlangÄ±Ã§taki Spring Boot uygulamamÄ±za hÄ±zlÄ± bir bakÄ±ÅŸ.</li><li>Kod Ã¶rnekleriyle Quarkusâ€™a adÄ±m adÄ±m geÃ§iÅŸ sÃ¼reci.</li><li>Proje kurulumu, REST denetleyicileri ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonundaki temel farklar.</li><li>Performans gÃ¶zlemleri (kavramsal).</li><li>KarÅŸÄ±laÅŸÄ±lan zorluklar ve bunlarÄ±n Ã¼stesinden gelmek iÃ§in ipuÃ§larÄ±.</li></ul><h3>ğŸ¤” Neden Spring Bootâ€™un Konfor AlanÄ±ndan Ã‡Ä±kÄ±p Quarkusâ€™a YÃ¶nelmeli?</h3><p>Spring Boot harika, ancak Ã¶zellikle mikroservislerin, sunucusuz (serverless) yapÄ±larÄ±n ve konteynerleÅŸtirmenin yaygÄ±nlaÅŸtÄ±ÄŸÄ±, aÃ§Ä±lÄ±ÅŸ sÃ¼resi ve bellek kullanÄ±mÄ±nÄ±n kritik olduÄŸu bir dÃ¼nyada her zaman mÃ¼kemmel bir seÃ§im olmayabilir. Junior ve orta seviye geliÅŸtiriciler, daha fazla uygulama daÄŸÄ±tmaya baÅŸladÄ±kÃ§a bu zorluklarla sÄ±kÃ§a karÅŸÄ±laÅŸÄ±rlar.</p><p>Quarkusâ€™ta ilgimi Ã§ekenler ÅŸunlar oldu:</p><ul><li><strong>IÅŸÄ±k HÄ±zÄ±nda AÃ§Ä±lÄ±ÅŸ SÃ¼releri:</strong> Quarkus uygulamalarÄ± milisaniyeler iÃ§inde baÅŸlayabilir. Bu, geliÅŸtirme (daha hÄ±zlÄ± geri bildirim dÃ¶ngÃ¼leri!) ve konteynerleÅŸtirilmiÅŸ ortamlarda Ã¶lÃ§eklendirme iÃ§in oyunun kurallarÄ±nÄ± deÄŸiÅŸtiriyor.</li><li><strong>AzaltÄ±lmÄ±ÅŸ Bellek KullanÄ±mÄ±:</strong> Quarkus, inanÄ±lmaz derecede bellek verimli olacak ÅŸekilde tasarlanmÄ±ÅŸtÄ±r; bu da daha dÃ¼ÅŸÃ¼k altyapÄ± maliyetleri ve daha yÃ¼ksek yoÄŸunluklu daÄŸÄ±tÄ±mlar anlamÄ±na gelir.</li><li><strong>GraalVM ile Native Derleme:</strong> Bu, Java kodunuzu native bir yÃ¼rÃ¼tÃ¼lebilir dosyaya derlemenizi saÄŸlar, bu da daha da hÄ±zlÄ± aÃ§Ä±lÄ±ÅŸ ve daha kÃ¼Ã§Ã¼k Ã§alÄ±ÅŸma zamanÄ± boyutuyla sonuÃ§lanÄ±r. Bu bazÄ± karmaÅŸÄ±klÄ±klar getirse de (bunlara deÄŸineceÄŸiz), faydalarÄ± Ã§ok bÃ¼yÃ¼k olabilir.</li><li><strong>GeliÅŸtirici MutluluÄŸu (Developer Joy):</strong> Quarkus, canlÄ± kodlama (live coding), birleÅŸik yapÄ±landÄ±rma ve popÃ¼ler Java kÃ¼tÃ¼phaneleri ile standartlarÄ± iÃ§in kapsamlÄ± destek gibi Ã¶zelliklerle harika bir geliÅŸtirici deneyimi sunmayÄ± amaÃ§lar. Bu, junior geliÅŸtiricilerin yeni sistemleri hÄ±zla anlamalarÄ±na ve oluÅŸturmalarÄ±na yardÄ±mcÄ± olur.</li><li><strong>Ä°mperatif ve Reaktif ArasÄ±nda KÃ¶prÃ¼:</strong> Quarkus, hem geleneksel imperatif programlamayÄ± (Spring Boot geliÅŸtiricilerine tanÄ±dÄ±k) hem de reaktif programlama modellerini destekler.</li></ul><p>Quarkusâ€™un arkasÄ±ndaki temel fikir, Ã§alÄ±ÅŸma zamanÄ± yerine <strong>derleme zamanÄ±nda</strong> mÃ¼mkÃ¼n olduÄŸunca fazla iÅŸ yapmaktÄ±r. Bu, baÄŸÄ±mlÄ±lÄ±k enjeksiyonunu, yapÄ±landÄ±rma iÅŸlemeyi ve framework baÅŸlatmayÄ± iÃ§erir, bu da daha yalÄ±n ve daha hÄ±zlÄ± uygulamalara yol aÃ§ar. Bu yaklaÅŸÄ±m, sadece â€œhÄ±zlÄ± Ã§Ã¶zÃ¼mlerâ€ yerine, temel kavramlarÄ±n saÄŸlam bir ÅŸekilde anlaÅŸÄ±lmasÄ±nÄ± teÅŸvik ederek daha derin bir anlayÄ±ÅŸ gerektirir.</p><h3>ğŸ BaÅŸlangÄ±Ã§ NoktamÄ±z: Basit Bir Spring Boot REST Servisi</h3><p>Ä°ÅŸleri odaklÄ± tutmak iÃ§in Ã§ok basit bir Spring Boot uygulamasÄ± hayal edelim. Bir selamlama mesajÄ± dÃ¶ndÃ¼ren tek bir REST endpointâ€™i var.</p><p><strong>pom.xml (Spring Bootâ€Šâ€”â€ŠTemel BaÄŸÄ±mlÄ±lÄ±klar):</strong></p><p>Bunun bir GitHub Gistâ€™ten gÃ¶mÃ¼ldÃ¼ÄŸÃ¼nÃ¼ veya Mediumâ€™un kod bloÄŸu Ã¶zelliÄŸini kullandÄ±ÄŸÄ±nÄ±zÄ± hayal edin.</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;/dependencies&gt;</pre><p><strong>GreetingController.java (Spring Boot):</strong></p><pre>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class GreetingController {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Kodda sabit deÄŸerlerden kaÃ§Ä±nÄ±n, sabitler kullanÄ±n [cite: 187]<br> @GetMapping(&quot;/hello-spring&quot;)<br> public String greet(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;DÃ¼nya&quot;) String name) {<br> return String.format(template, name);<br> }<br>}</pre><p>Bu standart bir Spring Boot kurulumu. Åimdi, Quarkusâ€™ta aynÄ±sÄ±nÄ± nasÄ±l baÅŸarabileceÄŸimize bakalÄ±m.</p><h3>ğŸ› ï¸ GeÃ§iÅŸ: Spring Bootâ€™tan Quarkusâ€™a AdÄ±m AdÄ±m</h3><p>GeÃ§iÅŸ, Quarkusâ€™un kurallarÄ±nÄ± ve REST, CDI ve yapÄ±landÄ±rma gibi yaygÄ±n gÃ¶revleri nasÄ±l ele aldÄ±ÄŸÄ±nÄ± anlamayÄ± iÃ§erir. Bunu parÃ§a parÃ§a oluÅŸturacak ve deÄŸiÅŸikliklerin ardÄ±ndaki â€œnedenâ€i aÃ§Ä±klayacaÄŸÄ±z.</p><h4><strong>1. Yeni Bir Quarkus Projesi OluÅŸturma</strong></h4><p>Quarkus CLI, Maven eklentisi veya <a href="https://code.quarkus.io/">code.quarkus.io</a> adresinden bir Quarkus projesi oluÅŸturabilirsiniz. Bu Ã¶rnek iÃ§in Maven pom.xml deÄŸiÅŸikliklerine odaklanacaÄŸÄ±z.</p><p><strong>pom.xml (Quarkusâ€Šâ€”â€ŠTemel BaÄŸÄ±mlÄ±lÄ±klar):</strong></p><pre>&lt;dependencyManagement&gt;<br> &lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;<br> &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;<br> &lt;version&gt;&lt;span class=&quot;math-inline&quot;&gt;\{quarkus\.platform\.version\}&lt;/version\&gt;&lt;/31\&gt; &lt;type\&gt;pom&lt;/type\&gt;<br>&lt;scope\&gt;import&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;&lt;/32\&gt;<br>&lt;/dependencyManagement\&gt;<br>&lt;dependencies\&gt;<br>&lt;&lt;34\&gt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive\-jackson&lt;/artifactId\&gt; &lt;/dependency\&gt;&lt;/34\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-arc&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-junit5&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.rest\-assured&lt;/groupId\&gt;<br>&lt;artifactId\&gt;rest\-assured&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;<br>&lt;build\&gt;<br>&lt;plugins\&gt;<br>&lt;&lt;33\&gt;plugin\&gt;<br>&lt;groupId\&gt;io\.quarkus\.platform&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-maven\-plugin&lt;/artifactId\&gt;<br>&lt;version\&gt;&lt;/span&gt;{quarkus.platform.version}&lt;/version&gt;<br> &lt;executions&gt;<br> &lt;execution&gt;<br> &lt;goals&gt;<br> &lt;goal&gt;build&lt;/goal&gt;<br> &lt;goal&gt;generate-code&lt;/goal&gt;<br> &lt;goal&gt;generate-code-tests&lt;/goal&gt;<br> &lt;/goals&gt;<br> &lt;/execution&gt;<br> &lt;/executions&gt;<br> &lt;/plugin&gt;<br> &lt;/plugins&gt;<br>&lt;/build&gt;</pre><ul><li><strong>Temel deÄŸiÅŸiklikler:</strong> BaÄŸÄ±mlÄ±lÄ±k yÃ¶netimi iÃ§in quarkus-bom&#39;u import ediyoruz.</li><li>Spring Web MVC yerine JAX-RS (Quarkusâ€™un kullandÄ±ÄŸÄ± Java EE/Jakarta EEâ€™deki REST standardÄ±) iÃ§in quarkus-resteasy-reactive kullanÄ±lÄ±r.</li><li>quarkus-arc, Quarkus&#39;un CDI (Contexts and Dependency Injection) Ã¼zerine kurulu ArC DI Ã§Ã¶zÃ¼mÃ¼dÃ¼r.</li></ul><h4>2. Quarkusâ€™ta REST Endpointâ€™i OluÅŸturma</h4><p>Quarkus, REST endpointâ€™lerini tanÄ±mlamak iÃ§in JAX-RS anotasyonlarÄ±nÄ± kullanÄ±r. Bunlar standart Java EE anotasyonlarÄ±dÄ±r, bu nedenle Spring dÄ±ÅŸÄ±nda Ã§alÄ±ÅŸtÄ±ysanÄ±z tanÄ±dÄ±k gelebilirler.</p><p><strong>GreetingResource.java (Quarkus):</strong></p><p>(Not: JAX-RSâ€™te denetleyicilere genellikle â€œResourceâ€ denir)</p><pre>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus&quot;) // Bu kaynak iÃ§in temel yol<br>public class GreetingResource {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Sabit kodlanmÄ±ÅŸ dizelerden kaÃ§Ä±nÄ±n, sabitler kullanÄ±n [cite: 187]<br> @GET // HTTP GET metodu<br> @Produces(MediaType.TEXT_PLAIN) // YanÄ±tÄ±n iÃ§erik tÃ¼rÃ¼<br> public String greet(@QueryParam(&quot;name&quot;) String name) { // @RequestParam yerine @QueryParam<br> // name null veya boÅŸsa varsayÄ±lan bir deÄŸer kullanÄ±n<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus DÃ¼nyasÄ±&quot;;<br> return String.format(template, displayName);<br> }<br>}</pre><ul><li>@Path: Bu kaynak iÃ§in temel URI yolunu tanÄ±mlar.</li><li>@GET: Bu metodun HTTP GET isteklerini iÅŸlediÄŸini belirtir.</li><li>@Produces(MediaType.TEXT_PLAIN): YanÄ±t iÃ§erik tÃ¼rÃ¼nÃ¼ gÃ¶sterir.</li><li>@QueryParam(&quot;name&quot;): &quot;name&quot; adlÄ± sorgu parametresinin deÄŸerini enjekte eder. Bu, Spring&#39;in @RequestParam&#39;Ä±na benzer.</li></ul><p>Bu yapÄ± aÃ§Ä±ktÄ±r ve tek bir sorumluluÄŸa odaklanÄ±r, temiz kod ilkelerine uyar.</p><h4>3. BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu (CDI)</h4><p>Quarkus, CDI implementasyonu olan ArCâ€™yi kullanÄ±r. Bunun gibi basit durumlar iÃ§in hemen Ã§ok fazla fark gÃ¶rmeyebilirsiniz, ancak uygulamanÄ±z bÃ¼yÃ¼dÃ¼kÃ§e @ApplicationScoped, @Inject vb. CDI anotasyonlarÄ±nÄ± kullanacaksÄ±nÄ±z.</p><p>GreetingResource&#39;umuzun bir servise ihtiyacÄ± olsaydÄ± ÅŸÃ¶yle gÃ¶rÃ¼nÃ¼rdÃ¼:</p><p><strong>GreetingService.java (Quarkus):</strong></p><pre>import jakarta.enterprise.context.ApplicationScoped; // CDI anotasyonu<br>@ApplicationScoped // Bu bean, uygulamanÄ±n Ã¶mrÃ¼ boyunca yaÅŸayacaktÄ±r<br>public class GreetingService {<br> public String getGreetingMessage(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Servisi&quot;;<br> return String.format(&quot;Servisten merhaba, %s!&quot;, displayName);<br> }<br>}</pre><p><strong>GreetingResource.java (Quarkusâ€Šâ€”â€Šenjekte edilmiÅŸ servisle):</strong></p><pre>import jakarta.inject.Inject; // Enjeksiyon iÃ§in CDI anotasyonu<br>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus-service&quot;)<br>public class GreetingResource {<br> @Inject // GreetingService&#39;i enjekte et<br> GreetingService service;<br> @GET<br> @Produces(MediaType.TEXT_PLAIN)<br> public String greet(@QueryParam(&quot;name&quot;) String name) {<br> return service.getGreetingMessage(name);<br> }<br>}</pre><p>Bu, Springâ€™in @Autowired ve @Service/@Component&#39;Ä±na Ã§ok benzer. Servisler ve metotlar iÃ§in anlamlÄ± isimler kullanmak aÃ§Ä±klÄ±k iÃ§in Ã¶nemlidir.</p><h4>4. YapÄ±landÄ±rma</h4><p>Quarkusâ€™ta yapÄ±landÄ±rma, Spring Bootâ€™ta olduÄŸu gibi src/main/resources iÃ§indeki application.properties aracÄ±lÄ±ÄŸÄ±yla yapÄ±lÄ±r.</p><p>Ã–rnek src/main/resources/application.properties:</p><pre>quarkus.application.name=my-quarkus-app<br>quarkus.application.version=1.0.0<br># HTTP portunu deÄŸiÅŸtirmek iÃ§in (varsayÄ±lan 8080&#39;dir)<br>quarkus.http.port=8081<br># Ã–zel Ã¶zellikler<br>greeting.message.prefix=Aloha</pre><p>Bu Ã¶zellikleri @ConfigProperty kullanarak enjekte edebilirsiniz:</p><pre>import org.eclipse.microprofile.config.inject.ConfigProperty;<br>import jakarta.enterprise.context.ApplicationScoped;<br>@ApplicationScoped<br>public class ConfigurableGreetingService {<br> @ConfigProperty(name = &quot;greeting.message.prefix&quot;, defaultValue = &quot;Merhaba&quot;)<br> String prefix;<br> public String greetWithConfig(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Config DÃ¼nyasÄ±&quot;;<br> return String.format(&quot;%s, %s!&quot;, prefix, displayName);<br> }<br>}</pre><p>Bu isimler birden fazla yerde kullanÄ±lÄ±yorsa, Ã¶zellik adlarÄ± iÃ§in isimlendirilmiÅŸ sabitler kullanmak iyi bir uygulamadÄ±r.</p><h4>5. GeliÅŸtirme Modunda Ã‡alÄ±ÅŸtÄ±rma</h4><p>Quarkusâ€™un en havalÄ± Ã¶zelliklerinden biri geliÅŸtirme modudur:</p><pre>./mvnw quarkus:dev</pre><p>Veya Gradle kullanÄ±yorsanÄ±z:</p><pre>./gradlew quarkusDev</pre><p>Bu, uygulamayÄ± baÅŸlatÄ±r ve kodunuzda yaptÄ±ÄŸÄ±nÄ±z herhangi bir deÄŸiÅŸiklik neredeyse anÄ±nda otomatik olarak yeniden yÃ¼klenir. Bu, geliÅŸtirme dÃ¶ngÃ¼sÃ¼nÃ¼ Ã¶nemli Ã¶lÃ§Ã¼de hÄ±zlandÄ±rÄ±r.</p><h4>6. Ãœretim iÃ§in Derleme</h4><p>Standart bir JAR oluÅŸturabilirsiniz:</p><pre>./mvnw package</pre><p>Bu, target/quarkus-app/ dizininde Ã§alÄ±ÅŸtÄ±rÄ±labilir bir JAR oluÅŸturur.</p><p><strong>Native yÃ¼rÃ¼tÃ¼lebilir dosya</strong> oluÅŸturmak iÃ§in (GraalVMâ€™in kurulu ve yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmasÄ±nÄ± gerektirir):</p><pre>./mvnw package -Pnative</pre><p>Bu, target/ dizininde native bir yÃ¼rÃ¼tÃ¼lebilir dosya Ã¼retecektir. Bu dosya kendi kendine yeterlidir ve inanÄ±lmaz hÄ±zlÄ± baÅŸlar. Native yÃ¼rÃ¼tÃ¼lebilir dosyalar oluÅŸturma sÃ¼reci, Ã¶zellikle bazÄ± kÃ¼tÃ¼phaneler iÃ§in yansÄ±ma (reflection) ihtiyaÃ§larÄ±nÄ± anlamak aÃ§Ä±sÄ±ndan kendi baÅŸÄ±na bir Ã¶ÄŸrenme eÄŸrisi olabilir.</p><h3>ğŸ“Š Performans:</h3><h4><em>Kavramsal Grafik 1: BaÅŸlangÄ±Ã§ SÃ¼resi</em></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zaD-sBfXUd3f-iFYMjXvLQ.png" /></figure><h4><strong>Kavramsal Grafik 2: Bellek KullanÄ±mÄ± (YerleÅŸik KÃ¼me Boyutuâ€Šâ€”â€ŠRSS)</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sVt2Wf45BvPtgeeijhH8Eg.png" /></figure><h3>âš ï¸ Zorluklar ve Ã–ÄŸrenimler</h3><p>GeÃ§iÅŸ genellikle olumluydu, ancak Ã¶ÄŸrenmek bazen zorlayÄ±cÄ± oldu.</p><ul><li><strong>FarklÄ± Ekosistem ve APIâ€™ler:</strong> BirÃ§ok kavram benzer olsa da, belirli APIâ€™ler ve kÃ¼tÃ¼phaneler (Ã¶rneÄŸin, REST iÃ§in JAX-RS, yapÄ±landÄ±rma iÃ§in MicroProfile Config) Springâ€™inkinden farklÄ±dÄ±r. Bu, bazÄ± ÅŸeyleri unutmayÄ± ve yeniden Ã¶ÄŸrenmeyi gerektirir. Bu, yeni kod tabanlarÄ± veya frameworkâ€™lerle karÅŸÄ±laÅŸan junior geliÅŸtiriciler iÃ§in yaygÄ±n bir engeldir.</li><li><strong>Native Derleme Ä°ncelikleri:</strong> UygulamanÄ±z Ã§ok fazla yansÄ±ma (reflection) veya dinamik sÄ±nÄ±f yÃ¼kleme kullanÄ±yorsa native yÃ¼rÃ¼tÃ¼lebilir dosyalar oluÅŸturmak bazen zor olabilir, Ã§Ã¼nkÃ¼ GraalVMâ€™in derleme zamanÄ±nda bunlarÄ± bilmesi gerekir. Quarkus Ã§ok yardÄ±mcÄ± olur, ancak zaman zaman ipuÃ§larÄ± vermeniz gerekebilir. Bu, sadece yÃ¼zeysel kodlamanÄ±n Ã¶tesinde daha derin bir anlayÄ±ÅŸa duyulan ihtiyacÄ± pekiÅŸtirir.</li><li><strong>Daha KÃ¼Ã§Ã¼k (ama BÃ¼yÃ¼yen) Topluluk:</strong> Quarkusâ€™un topluluÄŸu aktif ve hÄ±zla bÃ¼yÃ¼yor olsa da, henÃ¼z Spring kadar geniÅŸ deÄŸil. Bu, Ã§ok Ã¶zel sorunlara Ã§Ã¶zÃ¼m bulmanÄ±n bazen biraz daha fazla araÅŸtÄ±rma gerektirebileceÄŸi anlamÄ±na gelir.</li><li><strong>â€œDerleme ZamanÄ±ndaâ€ DÃ¼ÅŸÃ¼nmek:</strong> Daha fazlasÄ±nÄ± derleme zamanÄ±nda yapmaya geÃ§iÅŸ gÃ¼Ã§lÃ¼dÃ¼r ancak hafif bir zihinsel uyum gerektirir. Springâ€™de Ã§alÄ±ÅŸma zamanÄ±nda â€œsadece Ã§alÄ±ÅŸanâ€ bazÄ± ÅŸeyler, Quarkusâ€™ta derleme zamanÄ± dostu olmak iÃ§in aÃ§Ä±k yapÄ±landÄ±rma veya eklentiler gerektirebilir.</li></ul><p>Bu karmaÅŸÄ±k fikirleri basitleÅŸtirmek ve bunlarÄ±, temel bilgilerini hala geliÅŸtirmekte olan geliÅŸtiriciler iÃ§in sindirilebilir parÃ§alara ayÄ±rmak Ã§ok Ã¶nemlidir. Burada analojiler yardÄ±mcÄ± olabilir; Ã¶rneÄŸin, Quarkusâ€™un derleme zamanÄ± iÅŸlemesini, bir ÅŸefin piÅŸirmeden Ã¶nce tÃ¼m malzemeleri hazÄ±rlamasÄ± (mise en place) gibi dÃ¼ÅŸÃ¼nmek, Spring Bootâ€™un ise daha fazla hazÄ±rlÄ±ÄŸÄ± gerÃ§ek piÅŸirme iÅŸlemi sÄ±rasÄ±nda yapmasÄ±na karÅŸÄ±lÄ±k gelir.</p><h3>âœ… Karar: Spring Boot vs. Quarkusâ€Šâ€”â€ŠBenim Ã‡Ä±karÄ±mÄ±m</h3><p>Peki, Spring Bootâ€™u Quarkus ile deÄŸiÅŸtirmek buna deÄŸer miydi? <strong>Bu Ã¶zel mikroservis iÃ§in kesinlikle evet.</strong></p><p>BaÅŸlangÄ±Ã§ sÃ¼resi ve bellek azaltÄ±mÄ±ndaki performans kazanÄ±mlarÄ±, JVM modunda bile Ã¶nemliydi. CanlÄ± yeniden yÃ¼kleme ile geliÅŸtirici deneyimi harika. Quarkus modern, yalÄ±n ve bulut tabanlÄ± uygulamalar iÃ§in mÃ¼kemmel bir ÅŸekilde uygun hissettiriyor.</p><p><strong>Quarkusâ€™u ne zaman dÃ¼ÅŸÃ¼nmelisiniz:</strong></p><ul><li>Yeni mikroservisler veya sunucusuz iÅŸlevler oluÅŸtururken.</li><li>DÃ¼ÅŸÃ¼k bellek ayak izi ve hÄ±zlÄ± baÅŸlangÄ±Ã§ kritik olduÄŸunda.</li><li>GraalVM native derlemesinden yararlanmakla ilgileniyorsanÄ±z.</li><li>Kaynak verimliliÄŸinin maliyet tasarrufuna dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼ uygulamalar iÃ§in.</li></ul><p><strong>Spring Boot ne zaman hala daha iyi bir seÃ§im olabilir:</strong></p><ul><li>Tam bir yeniden yazÄ±mÄ±n mÃ¼mkÃ¼n olmadÄ±ÄŸÄ± bÃ¼yÃ¼k, mevcut monolitik uygulamalar.</li><li>HenÃ¼z doÄŸrudan Quarkus eÅŸdeÄŸerleri olmayan belirli Springâ€™e Ã¶zgÃ¼ kÃ¼tÃ¼phanelere veya modÃ¼llere bÃ¼yÃ¼k Ã¶lÃ§Ã¼de baÄŸÄ±mlÄ± projeler.</li><li>Mevcut derin Spring uzmanlÄ±ÄŸÄ±nÄ±n, acil proje hedefleri iÃ§in yeni bir frameworkâ€™Ã¼n Ã¶ÄŸrenme eÄŸrisinden daha aÄŸÄ±r bastÄ±ÄŸÄ± ekipler.</li></ul><p>Bu geÃ§iÅŸ, geliÅŸtiriciler olarak sÃ¼rekli olarak yeni araÃ§larÄ± ve paradigmalarÄ± keÅŸfetmemiz gerektiÄŸi fikrini pekiÅŸtiren deÄŸerli bir Ã¶ÄŸrenme deneyimi oldu. Mesele â€œX her zaman Yâ€™den iyidirâ€ deÄŸil, Ã¶dÃ¼nleÅŸimleri anlamak ve iÅŸ iÃ§in doÄŸru aracÄ± seÃ§mektir. Bu yolculuk aynÄ± zamanda, Ã¶zellikle yapay zeka gibi araÃ§larÄ±n derinlemesine anlamadan hÄ±zlÄ± Ã§Ã¶zÃ¼mler sunabileceÄŸi bir dÃ¶nemde, sadece framework sihrine gÃ¼venmek yerine temel Java kavramlarÄ±nÄ± anlamanÄ±n Ã¶nemini de vurguladÄ±.</p><h3>ğŸš€ SÄ±ra Sizde! Sonraki AdÄ±mlar ve Daha Fazla KeÅŸif</h3><p>Quarkus ilginizi Ã§ektiyse, baÅŸlamanÄ±za yardÄ±mcÄ± olacak bazÄ± kaynaklar ÅŸunlardÄ±r:</p><ul><li><strong>Quarkus KÄ±lavuzlarÄ±:</strong> <a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a>â€Šâ€”â€ŠResmi belgeler mÃ¼kemmeldir ve neredeyse her ÅŸey iÃ§in adÄ±m adÄ±m kÄ±lavuzlar sunar.</li><li><strong>Quarkus YouTube KanalÄ±:</strong> Harika eÄŸitimler ve konuÅŸmalar sunar.</li><li>Daha bÃ¼yÃ¼k projelere giriÅŸmeden Ã¶nce frameworkâ€™e alÄ±ÅŸmak iÃ§in kÃ¼Ã§Ã¼k bir <strong>â€œoyuncak uygulamaâ€</strong> oluÅŸturmayÄ± deneyin.</li></ul><h4>ğŸ’¬ Sizin DÃ¼ÅŸÃ¼nceleriniz Neler?</h4><p>Deneyimlerinizi duymak isterim!</p><ul><li>Quarkusâ€™u denediniz mi? Ä°zleniminiz neydi?</li><li>Spring Bootâ€™tan veya baÅŸka bir frameworkâ€™ten geÃ§meyi dÃ¼ÅŸÃ¼nÃ¼yor musunuz?</li><li>Ã–ngÃ¶rdÃ¼ÄŸÃ¼nÃ¼z en bÃ¼yÃ¼k zorluklar veya faydalar nelerdir?</li></ul><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d7a41a19117" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile E-posta GÃ¶nderimi ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-e-posta-g%C3%B6nderimi-d6715e02cefa?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/d6715e02cefa</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 06:12:35 GMT</pubDate>
<atom:updated>2025-06-20T05:13:43.939Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/737/1*JB9KkS2Ay2msUHwKXxCljw.png" /></figure><p>GÃ¼nÃ¼mÃ¼z uygulamalarÄ±nÄ±n vazgeÃ§ilmez bir parÃ§asÄ± olan e-posta iletiÅŸimi, kullanÄ±cÄ± kaydÄ±ndan bildirimlere, ÅŸifre sÄ±fÄ±rlamadan pazarlama kampanyalarÄ±na kadar geniÅŸ bir yelpazede kullanÄ±lÄ±yor. Spring Boot, spring-boot-starter-mail paketi ile bu sÃ¼reci oldukÃ§a basitleÅŸtiriyor. Ancak, sadece basit bir metin e-postasÄ± gÃ¶ndermenin Ã¶tesine geÃ§mek, HTML iÃ§erikler, ekler, ÅŸablonlar kullanmak ve asenkron gÃ¶nderim gibi konular, uygulamanÄ±zÄ±n profesyonelliÄŸini ve kullanÄ±cÄ± deneyimini doÄŸrudan etkiler.</p><p>Bu kapsamlÄ± rehberde, Spring Boot ile e-posta gÃ¶ndermenin temellerinden baÅŸlayarak, daha karmaÅŸÄ±k senaryolara ve en iyi uygulamalara kadar derinlemesine bir yolculuÄŸa Ã§Ä±kacaÄŸÄ±z. AmacÄ±mÄ±z, sadece e-posta gÃ¶ndermenizi saÄŸlamak deÄŸil, aynÄ± zamanda bu konuda ufkunuzu aÃ§arak daha saÄŸlam ve esnek Ã§Ã¶zÃ¼mler Ã¼retebilmenize yardÄ±mcÄ± olmak.</p><p><strong>Makale Ä°Ã§eriÄŸi:</strong></p><p><strong>Temel Kurulum ve BaÄŸÄ±mlÄ±lÄ±klar</strong></p><p><strong>application.properties ile YapÄ±landÄ±rma: SÄ±rlarÄ± ve Ä°ncelikleri</strong></p><ul><li>Gmail ile HÄ±zlÄ± BaÅŸlangÄ±Ã§ (Uygulama Åifresi OluÅŸturma)</li><li>DiÄŸer SMTP SaÄŸlayÄ±cÄ±larÄ± Ä°Ã§in Genel Ayarlar</li></ul><p><strong>JavaMailSender ArayÃ¼zÃ¼ ve Spring Boot Auto-Configuration Sihri</strong></p><p><strong>Ä°lk E-postamÄ±z: </strong><strong>SimpleMailMessage ile Basit Metin GÃ¶nderimi</strong></p><p><strong>UfuklarÄ± GeniÅŸletelim: </strong><strong>MimeMessage ile GeliÅŸmiÅŸ E-posta Ä°ÅŸlevleri</strong></p><ul><li>HTML Ä°Ã§erikli E-postalar GÃ¶nderme</li><li>Dosya Eki (Attachment) Ekleme</li><li>SatÄ±r Ä°Ã§i GÃ¶rseller (Inline Images) Kullanma</li></ul><p><strong>E-posta ÅablonlarÄ± ile Dinamik Ä°Ã§erikler: Thymeleaf Entegrasyonu</strong></p><p><strong>Asenkron E-posta GÃ¶nderimi: PerformansÄ± ArtÄ±rma (</strong><strong>@Async)</strong></p><p><strong>YapÄ±landÄ±rma ve GÃ¼venlik Ä°puÃ§larÄ±</strong></p><ul><li>Hassas Bilgilerin (Åifreler) GÃ¼venli YÃ¶netimi</li><li>Birden Fazla JavaMailSender YapÄ±landÄ±rmasÄ±</li></ul><p><strong>Test Stratejileri: E-postalarÄ± GerÃ§ekten GÃ¶ndermeden Test Etme</strong></p><p><strong>En Ä°yi Uygulamalar ve Ek Hususlar</strong></p><ul><li>Hata YÃ¶netimi ve Yeniden Deneme MekanizmalarÄ±</li><li>UluslararasÄ±laÅŸtÄ±rma (i18n)</li><li>Profesyonel E-posta Servisleri (SendGrid, Mailgun vb.) Ne Zaman DÃ¼ÅŸÃ¼nÃ¼lmeli?</li></ul><p><strong>SonuÃ§</strong></p><p>HazÄ±rsanÄ±z, Spring Boot ile e-posta gÃ¶ndermenin derinliklerine dalalÄ±m!</p><h3>1. Temel Kurulum ve BaÄŸÄ±mlÄ±lÄ±klar</h3><p>Her Spring Boot projesinde olduÄŸu gibi, iÅŸe pom.xml (Maven kullanÄ±yorsanÄ±z) veya build.gradle (Gradle kullanÄ±yorsanÄ±z) dosyamÄ±za gerekli baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekleyerek baÅŸlÄ±yoruz.</p><p><strong>Maven (</strong><strong>pom.xml):</strong></p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Bu â€œstarterâ€ paket, JavaMail APIâ€™sini ve Spring Frameworkâ€™Ã¼n e-posta gÃ¶nderimi iÃ§in sunduÄŸu soyutlama katmanlarÄ±nÄ± projenize dahil eder.</p><h3>2. application.properties ile YapÄ±landÄ±rma: SÄ±rlarÄ± ve Ä°ncelikleri</h3><p>Spring Boot, application.properties (veya application.yml) dosyasÄ±ndaki belirli anahtarlarÄ± okuyarak JavaMailSender&#39;Ä± otomatik olarak yapÄ±landÄ±rÄ±r.</p><p><strong>Gmail ile HÄ±zlÄ± BaÅŸlangÄ±Ã§:</strong></p><p>En yaygÄ±n kullanÄ±lan senaryolardan biri Gmail SMTP sunucusunu kullanmaktÄ±r.</p><ul><li><strong>AdÄ±m 2.1: Google HesabÄ±nÄ±zda Uygulama Åifresi OluÅŸturma (Ã‡OK Ã–NEMLÄ°!)</strong> Google, gÃ¼venlik nedeniyle standart hesap ÅŸifrenizin uygulamalar tarafÄ±ndan doÄŸrudan kullanÄ±lmasÄ±nÄ± kÄ±sÄ±tlar. Bu nedenle bir â€œUygulama Åifresiâ€ oluÅŸturmanÄ±z gerekir.</li></ul><ol><li><a href="https://myaccount.google.com/">Google HesabÄ±nÄ±za</a> gidin.</li><li>Sol menÃ¼den â€œGÃ¼venlikâ€ sekmesine tÄ±klayÄ±n.</li><li>â€œGoogleâ€™da oturum aÃ§maâ€ bÃ¶lÃ¼mÃ¼nde â€œ2 AdÄ±mlÄ± DoÄŸrulamaâ€nÄ±n <strong>etkin olduÄŸundan emin olun</strong>. DeÄŸilse, etkinleÅŸtirin.</li><li>2 AdÄ±mlÄ± DoÄŸrulama etkinse, aynÄ± bÃ¶lÃ¼mde â€œUygulama ÅŸifreleriâ€ seÃ§eneÄŸini gÃ¶receksiniz. (EÄŸer gÃ¶remiyorsanÄ±z, arama Ã§ubuÄŸuna â€œUygulama ÅŸifreleriâ€ yazÄ±n.)</li><li>â€œUygulama seÃ§inâ€ altÄ±nda â€œDiÄŸer (Ã–zel ad)â€ seÃ§eneÄŸini seÃ§in, uygulamanÄ±za bir isim verin (Ã¶rn: â€œSpringBootMailAppâ€) ve â€œOLUÅTURâ€ butonuna tÄ±klayÄ±n.</li><li>Google size 16 karakterlik bir uygulama ÅŸifresi verecektir. <strong>Bu ÅŸifreyi kopyalayÄ±n ve gÃ¼venli bir yere not edin.</strong> Bu pencereyi kapattÄ±ktan sonra tekrar gÃ¶remezsiniz.</li></ol><ul><li><strong>AdÄ±m 2.2: </strong><strong>application.properties DosyasÄ±nÄ± Ayarlama</strong> AÅŸaÄŸÄ±daki ayarlarÄ± src/main/resources/application.properties dosyanÄ±za ekleyin:</li></ul><pre>spring.mail.username=youremail@gmail.com # Gmail kullanÄ±cÄ± adÄ±nÄ±z (e-posta adresiniz) <br>spring.mail.password=BU_ALANA_KOPYALADIGINIZ_UYGULAMA_SIFRESINI_YAPISTIRIN <br># Gmail SMTP Sunucu AyarlarÄ± <br>spring.mail.host=smtp.gmail.com <br>spring.mail.port=587 # TLS iÃ§in Ã¶nerilen port <br># Ek JavaMail Ã–zellikleri <br>spring.mail.properties.mail.smtp.auth=true <br>spring.mail.properties.mail.smtp.starttls.enable=true <br># TLS&#39;yi etkinleÅŸtirir <br>spring.mail.properties.mail.smtp.starttls.required=true <br># TLS zorunlu <br>spring.mail.transport.protocol=smtp <br># KullanÄ±lacak protokol <br># Ä°steÄŸe BaÄŸlÄ±: Hata ayÄ±klama iÃ§in loglamayÄ± aÃ§ar (Ã¼retimde kapatÄ±n) <br>spring.mail.properties.mail.debug=true</pre><ul><li><strong>Ufuk AÃ§an Not:</strong> spring.mail.properties.* ile baÅŸlayan ayarlar, doÄŸrudan JavaMail API&#39;sine geÃ§irilen Ã¶zelliklerdir. Bu, Spring Boot&#39;un soyutlamasÄ±nÄ±n Ã¶tesinde, JavaMail&#39;in tÃ¼m gÃ¼cÃ¼nÃ¼ kullanabileceÄŸiniz anlamÄ±na gelir. Ã–rneÄŸin, baÄŸlantÄ± zaman aÅŸÄ±mÄ± (mail.smtp.connectiontimeout), yazma zaman aÅŸÄ±mÄ± (mail.smtp.writetimeout) gibi daha ince ayarlarÄ± buradan yapabilirsiniz.</li></ul><p><strong>DiÄŸer SMTP SaÄŸlayÄ±cÄ±larÄ± Ä°Ã§in Genel Ayarlar:</strong></p><p>EÄŸer Gmail dÄ±ÅŸÄ±nda bir SMTP sunucusu (Ã¶rneÄŸin, ÅŸirketinizin kendi sunucusu veya SendGrid, Mailgun gibi bir servis) kullanacaksanÄ±z, host, port, username, password ve properties ayarlarÄ±nÄ± saÄŸlayÄ±cÄ±nÄ±zÄ±n belgelerine gÃ¶re dÃ¼zenlemeniz yeterlidir.</p><h3>3. JavaMailSender ArayÃ¼zÃ¼ ve Spring Boot Auto-Configuration Sihri</h3><p>Spring Boot, yukarÄ±daki application.properties ayarlarÄ±nÄ± kullanarak otomatik olarak bir JavaMailSender bean&#39;i oluÅŸturur ve yÃ¶netir. Bu sayede, Ã§oÄŸu zaman sizin manuel bir JavaMailSender bean&#39;i tanÄ±mlamanÄ±za gerek kalmaz.</p><p>Ancak, kaynakta belirtilen @Configuration sÄ±nÄ±fÄ± ile manuel bean tanÄ±mÄ±:</p><pre>@Configuration<br>public class MailConfiguration {<br> @Bean<br> public JavaMailSender getJavaMailSender() {<br> JavaMailSenderImpl mailSender = new JavaMailSenderImpl();<br> mailSender.setHost(&quot;smtp.gmail.com&quot;);<br> // ... diÄŸer ayarlar<br> return mailSender;<br> }<br> }</pre><p>Bu yaklaÅŸÄ±m, eÄŸer application.properties dosyasÄ±nda zaten tÃ¼m ayarlarÄ± yaptÄ±ysanÄ±z <strong>genellikle gereksizdir</strong>. Spring Boot sizin iÃ§in bunu zaten yapar.</p><p><strong>Peki ne zaman manuel bean tanÄ±mÄ±na ihtiyaÃ§ duyulur?</strong></p><ul><li>Birden fazla, farklÄ± ayarlara sahip JavaMailSender bean&#39;ine ihtiyacÄ±nÄ±z varsa (Ã¶rn: biri Gmail, diÄŸeri baÅŸka bir SMTP iÃ§in).</li><li>JavaMailSenderImpl Ã¼zerinde application.properties ile ayarlanamayan Ã§ok Ã¶zel programatik yapÄ±landÄ±rmalar yapmak istiyorsanÄ±z.</li><li>Spring Bootâ€™un otomatik yapÄ±landÄ±rmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±p tam kontrol sahibi olmak istiyorsanÄ±z (spring.mail.host ayarÄ±nÄ± boÅŸ bÄ±rakmak otomatik yapÄ±landÄ±rmayÄ± devre dÄ±ÅŸÄ± bÄ±rakabilir).</li></ul><p>Ã‡oÄŸu senaryoda, Spring Bootâ€™un otomatik yapÄ±landÄ±rmasÄ± yeterli ve tercih edilen yoldur.</p><h3>4. Ä°lk E-postamÄ±z: SimpleMailMessage ile Basit Metin GÃ¶nderimi</h3><p>Åimdi basit bir metin e-postasÄ± gÃ¶nderecek servisi oluÅŸturalÄ±m.</p><p><strong>MailSenderService.java:</strong></p><pre>package com.example.demo.mail; // Kendi paket yapÄ±nÄ±za gÃ¶re dÃ¼zenleyin<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.mail.SimpleMailMessage;<br>import org.springframework.mail.javamail.JavaMailSender;<br>import org.springframework.stereotype.Service;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // Spring Boot, application.properties&#39;teki ayarlara gÃ¶re<br> // JavaMailSender bean&#39;ini otomatik olarak enjekte edecektir.<br> // @Value(&quot;${spring.mail.username}&quot;) // GÃ¶nderici adresini properties&#39;ten almak iÃ§in<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> public void sendSimpleMail(String to, String subject, String body) {<br> SimpleMailMessage message = new SimpleMailMessage();<br> // message.setFrom(fromEmail); // GÃ¶nderici adresi (genellikle properties&#39;te ayarlanÄ±r ve otomatik kullanÄ±lÄ±r)<br> message.setTo(to);<br> message.setSubject(subject);<br> message.setText(body);<br> try {<br> mailSender.send(message);<br> System.out.println(&quot;Mail sent successfully to &quot; + to);<br> } catch (Exception e) {<br> System.err.println(&quot;Error while sending mail to &quot; + to + &quot;: &quot; + e.getMessage());<br> // Burada daha geliÅŸmiÅŸ hata yÃ¶netimi yapÄ±labilir (logging, retry vb.)<br> }<br> }<br>}</pre><pre><strong>Not:</strong> SimpleMailMessage sÄ±nÄ±fÄ±, adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± gibi sadece basit metin tabanlÄ± e-postalar iÃ§in uygundur. HTML, ek dosya veya satÄ±r iÃ§i gÃ¶rsel desteklemez.</pre><p><strong>E-postayÄ± Tetikleme (Ã–rnek bir Controller veya baÅŸka bir Servis):</strong></p><pre>package com.example.demo.controller; // Kendi paket yapÄ±nÄ±za gÃ¶re dÃ¼zenleyin<br>import com.example.demo.mail.MailSenderService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class MailController {<br> private final MailSenderService mailService;<br> @Autowired<br> public MailController(MailSenderService mailService) {<br> this.mailService = mailService;<br> }<br> @GetMapping(&quot;/send-test-email&quot;)<br> public String sendTestEmail(@RequestParam String to) {<br> mailService.sendSimpleMail(to, &quot;Spring Boot Test E-postasÄ±&quot;, &quot;Merhaba,\n\nBu Spring Boot uygulamasÄ±ndan gÃ¶nderilmiÅŸ bir test e-postasÄ±dÄ±r.&quot;);<br> return &quot;Test e-postasÄ± gÃ¶nderildi: &quot; + to;<br> }<br>}</pre><p>UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rÄ±p tarayÄ±cÄ±dan http://localhost:8080/send-test-email?to=alici_email@example.com adresine giderek test edebilirsiniz.</p><h3>5. UfuklarÄ± GeniÅŸletelim: MimeMessage ile GeliÅŸmiÅŸ E-posta Ä°ÅŸlevleri</h3><p>Daha zengin iÃ§erikli e-postalar iÃ§in JavaMailSender&#39;Ä±n createMimeMessage() metodunu ve MimeMessageHelper sÄ±nÄ±fÄ±nÄ± kullanÄ±rÄ±z.</p><p><strong>GeliÅŸmiÅŸ </strong><strong>MailSenderService.java:</strong></p><pre>// ... (Ã¶nceki importlar)<br>import org.springframework.mail.javamail.MimeMessageHelper;<br>import jakarta.mail.MessagingException; // javax.mail yerine jakarta.mail (Spring Boot 3+)<br>import jakarta.mail.internet.MimeMessage;<br>import org.springframework.core.io.FileSystemResource; // Dosya ekleri iÃ§in<br>import java.io.File;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // @Value(&quot;${spring.mail.username}&quot;)<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> // ... sendSimpleMail metodu ...<br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> // &#39;true&#39; parametresi multipart message oluÅŸturulacaÄŸÄ±nÄ± belirtir.<br> // Ä°kinci &#39;true&#39; ise UTF-8 encoding iÃ§in.<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(htmlBody, true); // &#39;true&#39; HTML iÃ§eriÄŸi olduÄŸunu belirtir.<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;HTML mail sent successfully to &quot; + to);<br> }<br> public void sendMailWithAttachment(String to, String subject, String body, String attachmentPath) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); // &#39;true&#39; for multipart message<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(body);<br> FileSystemResource file = new FileSystemResource(new File(attachmentPath));<br> if (file.exists()) {<br> helper.addAttachment(file.getFilename(), file); // Ä°kinci parametre dosya kaynaÄŸÄ±<br> System.out.println(&quot;Attachment added: &quot; + file.getFilename());<br> } else {<br> System.err.println(&quot;Attachment file not found: &quot; + attachmentPath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with attachment sent successfully to &quot; + to);<br> }<br> public void sendMailWithInlineImage(String to, String subject, String htmlBody, String imagePath, String imageContentId) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> // HTML iÃ§eriÄŸinde &lt;img src=&#39;cid:imageContentId&#39;&gt; ÅŸeklinde referans verilir.<br> helper.setText(htmlBody, true);<br> FileSystemResource res = new FileSystemResource(new File(imagePath));<br> if (res.exists()) {<br> // &#39;imageContentId&#39; HTML iÃ§indeki cid ile aynÄ± olmalÄ±<br> helper.addInline(imageContentId, res);<br> System.out.println(&quot;Inline image added: &quot; + imageContentId);<br> } else {<br> System.err.println(&quot;Inline image file not found: &quot; + imagePath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with inline image sent successfully to &quot; + to);<br> }<br>}</pre><ul><li><strong>Not (HTML):</strong> helper.setText(htmlBody, true); satÄ±rÄ±ndaki ikinci true parametresi, gÃ¶nderilen metnin HTML olarak yorumlanmasÄ±nÄ± saÄŸlar.</li><li><strong>Not (Ek):</strong> MimeMessageHelper(mimeMessage, true) constructor&#39;Ä±ndaki true parametresi, mesajÄ±n &quot;multipart&quot; olacaÄŸÄ±nÄ± belirtir, bu da ek dosya ve satÄ±r iÃ§i gÃ¶rseller iÃ§in gereklidir. addAttachment ile dosya adÄ± ve kaynaÄŸÄ±nÄ± belirtirsiniz.</li><li><strong>Not (SatÄ±r Ä°Ã§i GÃ¶rsel):</strong> addInline metodu kullanÄ±lÄ±r. HTML iÃ§inde &lt;img src=&#39;cid:myImageIdentifier&#39;&gt; ÅŸeklinde bir referans verilir ve addInline(&quot;myImageIdentifier&quot;, resource) Ã§aÄŸrÄ±sÄ±yla bu ID&#39;ye karÅŸÄ±lÄ±k gelen gÃ¶rsel eklenir. Bu, gÃ¶rselin e-postanÄ±n iÃ§ine gÃ¶mÃ¼lmesini saÄŸlar, kÄ±rÄ±k link sorununu azaltÄ±r. E-posta istemcisinin multipart/related iÃ§eriÄŸi desteklemesi gerekir.</li></ul><h3>6. E-posta ÅablonlarÄ± ile Dinamik Ä°Ã§erikler: Thymeleaf Entegrasyonu</h3><p>Sabit HTML stringâ€™leri yerine dinamik iÃ§erikler oluÅŸturmak iÃ§in Thymeleaf gibi bir ÅŸablon motoru kullanmak Ã§ok daha pratiktir.</p><ul><li><strong>AdÄ±m 6.1: Thymeleaf BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± Ekleme (</strong><strong>pom.xml)</strong></li></ul><pre>&lt;dependency&gt; <br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; <br>&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; <br>&lt;/dependency&gt;</pre><ul><li><strong>AdÄ±m 6.2: E-posta Åablonu OluÅŸturma (</strong><strong>src/main/resources/templates/email/my-template.html)</strong></li></ul><pre>&lt;!DOCTYPE html&gt; <br>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; <br>&lt;head&gt; <br>&lt;meta charset=&quot;UTF-8&quot;&gt; <br>&lt;title th:text=&quot;${subject}&quot;&gt;E-posta BaÅŸlÄ±ÄŸÄ±&lt;/title&gt; <br>&lt;style&gt; <br>body { font-family: Arial, sans-serif; } <br>.container { padding: 20px; border: 1px solid #ddd; } <br>&lt;/style&gt; <br>&lt;/head&gt; <br>&lt;body&gt; <br>&lt;div class=&quot;container&quot;&gt; <br>&lt;h1 th:text=&quot;${title}&quot;&gt;Merhaba!&lt;/h1&gt; <br>&lt;p&gt;Sevgili &lt;strong th:text=&quot;${name}&quot;&gt;KullanÄ±cÄ±&lt;/strong&gt;,&lt;/p&gt; <br>&lt;p th:text=&quot;${messageContent}&quot;&gt;Bu dinamik bir e-posta iÃ§eriÄŸidir.&lt;/p&gt; &lt;hr&gt; &lt;p&gt;TeÅŸekkÃ¼rler,&lt;br&gt;Spring Boot UygulamanÄ±z&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</pre><ul><li><strong>AdÄ±m 6.3: </strong><strong>MailSenderService&#39;i GÃ¼ncelleme</strong></li></ul><pre>// ... (Ã¶nceki importlar) <br>import org.thymeleaf.context.Context; <br>import org.thymeleaf.spring6.SpringTemplateEngine; <br>// Spring Boot 3 iÃ§in spring6 <br>@Service <br>public class MailSenderService { <br>private final JavaMailSender mailSender; <br>private final SpringTemplateEngine templateEngine; <br>Thymeleaf motorunu enjekte et <br>@Value(&quot;${spring.mail.username}&quot;) <br>private String fromEmail; <br>@Autowired <br>public MailSenderService(JavaMailSender mailSender, SpringTemplateEngine templateEngine) { <br> this.mailSender = mailSender; <br> this.templateEngine = templateEngine; <br>} <br>// ... diÄŸer metotlar ... <br>public void sendMailWithTemplate(String to, String subject, String templateName, Context context) throws MessagingException { <br> MimeMessage mimeMessage = mailSender.createMimeMessage(); <br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;); <br> // Thymeleaf context&#39;inden HTML iÃ§eriÄŸini iÅŸle <br> String htmlContent = templateEngine.process(&quot;email/&quot; + templateName, context); <br> // &quot;email/&quot; templates altÄ±ndaki klasÃ¶r <br> // helper.setFrom(fromEmail); <br> helper.setTo(to); <br> helper.setSubject(subject); <br> helper.setText(htmlContent, true); <br> mailSender.send(mimeMessage); <br> System.out.println(&quot;Templated mail sent successfully to &quot; + to); <br> } <br>}</pre><ul><li><strong>KullanÄ±mÄ±:</strong></li></ul><pre>// Bir controller veya baÅŸka bir serviste <br>// Context context = new Context(); <br>// context.setVariable(&quot;subject&quot;, &quot;Thymeleaf ile Merhaba!&quot;); <br>// context.setVariable(&quot;title&quot;, &quot;HoÅŸ Geldiniz!&quot;); <br>// context.setVariable(&quot;name&quot;, &quot;Ahmet YÄ±lmaz&quot;); <br>// context.setVariable(&quot;messageContent&quot;, &quot;Thymeleaf kullanarak dinamik bir e-posta gÃ¶nderdiniz.&quot;); <br>// mailService.sendMailWithTemplate(&quot;alici@example.com&quot;, &quot;Thymeleaf Test&quot;, &quot;my-template.html&quot;, context);</pre><ul><li><strong>Not:</strong> Context nesnesi, ÅŸablona geÃ§irilecek dinamik verileri iÃ§erir. templateEngine.process metodu, ÅŸablon adÄ±nÄ± ve context&#39;i alarak sonuÃ§ HTML&#39;i Ã¼retir. Bu yaklaÅŸÄ±m, e-posta iÃ§eriÄŸi ile sunumunu ayÄ±rarak bakÄ±mÄ± kolaylaÅŸtÄ±rÄ±r.</li></ul><h3>7. Asenkron E-posta GÃ¶nderimi: PerformansÄ± ArtÄ±rma (@Async)</h3><p>E-posta gÃ¶nderme iÅŸlemi, SMTP sunucusunun yanÄ±t verme sÃ¼resine baÄŸlÄ± olarak zaman alabilir. KullanÄ±cÄ± etkileÅŸimli bir iÅŸlem sÄ±rasÄ±nda (Ã¶rneÄŸin, kayÄ±t sonrasÄ± hoÅŸ geldin e-postasÄ±) senkron e-posta gÃ¶nderimi, kullanÄ±cÄ±ya yavaÅŸ bir deneyim sunabilir. @Async kullanarak e-posta gÃ¶nderimini arka planda Ã§alÄ±ÅŸacak ayrÄ± bir thread&#39;e devredebiliriz.</p><ul><li><strong>AdÄ±m 7.1: Asenkron DesteÄŸi EtkinleÅŸtirme</strong> Ana uygulama sÄ±nÄ±fÄ±nÄ±za veya bir @Configuration sÄ±nÄ±fÄ±na @EnableAsync ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.EnableAsync; <br>@SpringBootApplication <br>@EnableAsync // Asenkron metodlarÄ± etkinleÅŸtirir <br>public class DemoApplication { <br> public static void main(String[] args) { <br> SpringApplication.run(DemoApplication.class, args); <br> } <br>}</pre><ul><li><strong>AdÄ±m 7.2: Servis Metodunu </strong><strong>@Async ile Ä°ÅŸaretleme</strong> MailSenderService iÃ§indeki e-posta gÃ¶nderim metotlarÄ±nÄ±za @Async ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.Async; <br>// ... @Service <br>public class MailSenderService { <br>// ... @Async <br> // Bu metod asenkron Ã§alÄ±ÅŸacak <br> public void sendSimpleMail(String to, String subject, String body) { <br> // ... (iÃ§erik aynÄ±) } <br> @Async <br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException { <br> // ... (iÃ§erik aynÄ±) } <br> // DiÄŸer metotlar iÃ§in de @Async eklenebilir. <br>}</pre><ul><li><strong>Not:</strong> @Async metodlarÄ±n public olmasÄ± ve aynÄ± sÄ±nÄ±f iÃ§inden Ã§aÄŸrÄ±lmamasÄ± gerekir (proxy mekanizmasÄ± nedeniyle). EÄŸer aynÄ± sÄ±nÄ±f iÃ§inden Ã§aÄŸÄ±rmanÄ±z gerekiyorsa, kendinize enjekte ederek (self-injection) Ã§Ã¶zebilirsiniz veya e-posta gÃ¶nderimini ayrÄ± bir bean&#39;e taÅŸÄ±yabilirsiniz. AyrÄ±ca, @Async iÃ§in Ã¶zel bir TaskExecutor yapÄ±landÄ±rarak thread havuzu boyutunu vb. yÃ¶netebilirsiniz.</li></ul><pre> // TaskExecutor konfigÃ¼rasyonu (isteÄŸe baÄŸlÄ±) <br> import org.springframework.context.annotation.Bean; <br> import org.springframework.context.annotation.Configuration; <br> import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; <br> import java.util.concurrent.Executor; <br> <br> @Configuration <br> public class AsyncConfig { <br> @Bean(name = &quot;mailTaskExecutor&quot;) <br> public Executor mailTaskExecutor() { <br> ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); <br> executor.setCorePoolSize(5); <br>// AynÄ± anda Ã§alÄ±ÅŸacak min thread <br> executor.setMaxPoolSize(10); <br> Max thread <br> executor.setQueueCapacity(25); <br>// Kuyruk kapasitesi <br><br> executor.setThreadNamePrefix(&quot;MailAsync-&quot;); <br> executor.initialize(); <br> return executor; <br> } <br> } <br> @Async(&quot;mailTaskExecutor&quot;) <br> Belirli bir executor kullanmak iÃ§in</pre><h3>8. YapÄ±landÄ±rma ve GÃ¼venlik Ä°puÃ§larÄ±</h3><ul><li><strong>Hassas Bilgilerin GÃ¼venli YÃ¶netimi:</strong> spring.mail.password gibi hassas bilgileri doÄŸrudan application.properties dosyasÄ±na yazmak ve bunu Git gibi versiyon kontrol sistemlerine gÃ¶ndermek <strong>GÃœVENLÄ°K AÃ‡IÄIDIR.</strong></li><li><strong>Ã‡Ã¶zÃ¼m 1: Ortam DeÄŸiÅŸkenleri (Environment Variables):</strong> application.properties dosyasÄ±nda: spring.mail.password=${MAIL_APP_PASSWORD} UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±z ortamda MAIL_APP_PASSWORD adÄ±nda bir ortam deÄŸiÅŸkeni tanÄ±mlayÄ±n.</li><li><strong>Ã‡Ã¶zÃ¼m 2: Spring Cloud Config Server:</strong> Merkezi ve gÃ¼venli yapÄ±landÄ±rma yÃ¶netimi iÃ§in.</li><li><strong>Ã‡Ã¶zÃ¼m 3: HashiCorp Vault:</strong> SÄ±rlarÄ±n (secrets) gÃ¼venli depolanmasÄ± ve eriÅŸimi iÃ§in.</li><li><strong>Birden Fazla </strong><strong>JavaMailSender YapÄ±landÄ±rmasÄ±:</strong> FarklÄ± amaÃ§lar iÃ§in (Ã¶rn: iÅŸlem e-postalarÄ± iÃ§in bir SMTP, pazarlama iÃ§in baÅŸka bir SMTP) farklÄ± JavaMailSender bean&#39;leri tanÄ±mlayabilirsiniz. Bu durumda, her bir bean&#39;i @Primary ile varsayÄ±lan olarak iÅŸaretleyebilir veya @Qualifier ile belirli bir bean&#39;i enjekte edebilirsiniz.</li></ul><pre> @Configuration <br> public class MultipleMailConfig { <br> @Bean <br> @Primary <br> public JavaMailSender primaryMailSender() { <br> /* ... ayarlar ... */ <br> } <br> <br> @Bean <br> @Qualifier(&quot;marketingMailSender&quot;) <br> public JavaMailSender marketingMailSender() { <br> /* ... farklÄ± ayarlar ... */ <br> } <br> } <br> <br> <br>// KullanÄ±m <br> @Autowired <br> @Qualifier(&quot;marketingMailSender&quot;) <br> private JavaMailSender marketingSender;</pre><h3>9. Test Stratejileri: E-postalarÄ± GerÃ§ekten GÃ¶ndermeden Test Etme</h3><p>Entegrasyon testleri sÄ±rasÄ±nda sÃ¼rekli gerÃ§ek e-posta gÃ¶ndermek pratik deÄŸildir ve SMTP sunucunuzu gereksiz yere yorabilir.</p><ul><li><strong>Ã‡Ã¶zÃ¼m 1: Wiser (SubEthaSMTP Ã¼zerinden Spring Boot Test DesteÄŸi):</strong> Spring Boot, testler iÃ§in gÃ¶mÃ¼lÃ¼ bir SMTP sunucusu baÅŸlatmanÄ±za olanak tanÄ±r. spring-boot-starter-test ile birlikte gelir. application-test.properties dosyasÄ±na (genellikle src/test/resources altÄ±nda):</li></ul><pre>spring.mail.host=localhost spring.mail.port=2525 # Wiser iÃ§in varsayÄ±lan veya testte ayarlanan port spring.mail.username=testuser spring.mail.password=testpass spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.transport.protocol=smtp</pre><ul><li>Test sÄ±nÄ±fÄ±nÄ±zda:</li></ul><pre> import com.icegreen.greenmail.configuration.GreenMailConfiguration; <br> import com.icegreen.greenmail.junit5.GreenMailExtension; <br> import com.icegreen.greenmail.util.ServerSetupTest; <br> import jakarta.mail.internet.MimeMessage; <br> import org.junit.jupiter.api.Test; <br> import org.junit.jupiter.api.extension.RegisterExtension; <br> import org.springframework.beans.factory.annotation.Autowired; <br> import org.springframework.boot.test.context.SpringBootTest; <br> import static org.assertj.core.api.Assertions.assertThat; <br> <br> @SpringBootTest <br> public class MailServiceIntegrationTest { <br> <br> @RegisterExtension <br>// JUnit 5 iÃ§in <br> static GreenMailExtension greenMail = new GreenMailExtension(ServerSetupTest.SMTP) <br> .withConfiguration(GreenMailConfiguration.aConfig().withUser(&quot;testuser&quot;, &quot;testpass&quot;)) <br> .withPerMethodLifecycle(false); // TÃ¼m test metotlarÄ± iÃ§in tek bir GreenMail instance <br> <br> @Autowired <br> private MailSenderService mailService; <br> <br> @Test <br> void testSendSimpleMail() throws Exception { <br> String to = &quot;recipient@example.com&quot;; <br> String subject = &quot;Test Subject&quot;; <br> String body = &quot;Test Body&quot;; <br> <br> mailService.sendSimpleMail(to, subject, body); <br> <br> MimeMessage[] receivedMessages = greenMail.getReceivedMessages(); <br> assertThat(receivedMessages.length).isEqualTo(1); <br> MimeMessage receivedMessage = receivedMessages[0]; <br> assertThat(receivedMessage.getSubject()).isEqualTo(subject); <br> assertThat(receivedMessage.getAllRecipients()[0].toString()).isEqualTo(to); <br> <br>// Ä°Ã§eriÄŸi de kontrol edebilirsiniz. <br> } <br> }</pre><ul><li><em>GreenMail gibi kÃ¼tÃ¼phaneler (Wiser da SubEthaSMTPâ€™yi temel alÄ±r) gelen e-postalarÄ± yakalayÄ±p iÃ§eriÄŸini doÄŸrulamanÄ±zÄ± saÄŸlar.</em></li><li><strong>Ã‡Ã¶zÃ¼m 2: Mocking </strong><strong>JavaMailSender:</strong> Birim testlerinde JavaMailSender&#39;Ä± mocklayarak send() metodunun Ã§aÄŸrÄ±lÄ±p Ã§aÄŸrÄ±lmadÄ±ÄŸÄ±nÄ± ve doÄŸru parametrelerle Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nÄ± doÄŸrulayabilirsiniz.</li></ul><h3>10. En Ä°yi Uygulamalar ve Ek Hususlar</h3><ul><li><strong>Logging:</strong> E-posta gÃ¶nderim baÅŸarÄ±larÄ±nÄ± ve hatalarÄ±nÄ± detaylÄ± loglayÄ±n.</li><li><strong>Hata YÃ¶netimi ve Yeniden Deneme:</strong> GeÃ§ici SMTP hatalarÄ± (baÄŸlantÄ± sorunlarÄ± vb.) iÃ§in Spring Retry gibi mekanizmalarla yeniden deneme stratejileri uygulayabilirsiniz.</li><li><strong>UluslararasÄ±laÅŸtÄ±rma (i18n):</strong> E-posta iÃ§eriklerini ve baÅŸlÄ±klarÄ±nÄ± farklÄ± dillerde sunmak iÃ§in Springâ€™in i18n desteÄŸini (ResourceBundleMessageSource) Thymeleaf ile birlikte kullanÄ±n.</li><li><strong>Abonelikten Ã‡Ä±kma (Unsubscribe) Linkleri:</strong> Ã–zellikle pazarlama e-postalarÄ± iÃ§in yasal bir zorunluluktur ve kullanÄ±cÄ± deneyimi iÃ§in Ã¶nemlidir.</li><li><strong>Rate Limiting:</strong> SMTP sunucularÄ±nÄ±n genellikle gÃ¶nderim limitleri vardÄ±r. Toplu e-posta gÃ¶nderimlerinde bu limitlere dikkat edin.</li><li><strong>Profesyonel E-posta Servisleri (SendGrid, Amazon SES, Mailgun vb.):</strong> YÃ¼ksek hacimli e-posta gÃ¶nderimi, geliÅŸmiÅŸ analizler, teslim edilebilirlik (deliverability) takibi, IP itibarÄ± yÃ¶netimi gibi ihtiyaÃ§larÄ±nÄ±z varsa, bu tÃ¼r harici servisleri kullanmayÄ± dÃ¼ÅŸÃ¼nÃ¼n. Genellikle kendi APIâ€™leri ve Spring Boot entegrasyon kÃ¼tÃ¼phaneleri bulunur.</li></ul><h3>11. SonuÃ§</h3><p>Spring Boot ile e-posta gÃ¶ndermek, spring-boot-starter-mail sayesinde oldukÃ§a kolaylaÅŸmÄ±ÅŸtÄ±r. Ancak, bu rehberde gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi, basit bir metin e-postasÄ±ndan Ã§ok daha fazlasÄ±nÄ± yapabiliriz. HTML iÃ§erikler, ekler, ÅŸablonlar, asenkron gÃ¶nderim ve doÄŸru test stratejileri ile uygulamalarÄ±nÄ±zda profesyonel ve etkili bir e-posta iletiÅŸim altyapÄ±sÄ± kurabilirsiniz.</p><p>UnutmayÄ±n, e-posta gÃ¶nderimi sadece teknik bir iÅŸlem deÄŸil, aynÄ± zamanda kullanÄ±cÄ± deneyiminin ve uygulamanÄ±zÄ±n imajÄ±nÄ±n Ã¶nemli bir parÃ§asÄ±dÄ±r. Bu nedenle, bu sÃ¼reÃ§lere Ã¶zen gÃ¶stermek ve en iyi uygulamalarÄ± takip etmek, projenizin baÅŸarÄ±sÄ±na katkÄ± saÄŸlayacaktÄ±r.</p><p>UmarÄ±m bu kapsamlÄ± rehber, Spring Boot ile e-posta gÃ¶nderimi konusunda ufkunuzu aÃ§mÄ±ÅŸ ve size deÄŸerli bilgiler sunmuÅŸtur. Yorumlarda sorularÄ±nÄ±zÄ± ve deneyimlerinizi paylaÅŸmaktan Ã§ekinmeyin!</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d6715e02cefa" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Reaktif Programlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-reaktif-programlamaya-ad%C4%B1m-ad%C4%B1m-yeni-ba%C5%9Flayanlar-i%CC%87%C3%A7in-kapsaml%C4%B1-bir-rehber-ve-5815c96be738?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/5815c96be738</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 05:03:44 GMT</pubDate>
<atom:updated>2025-06-20T05:14:00.883Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vOd2FBimvVRwHFflS44SNg.png" /></figure><p>GÃ¼nÃ¼mÃ¼zÃ¼n yÃ¼ksek trafikli ve anlÄ±k veri akÄ±ÅŸÄ± gerektiren uygulamalarÄ±nda performans ve Ã¶lÃ§eklenebilirlik hayati Ã¶nem taÅŸÄ±yor. Ä°ÅŸte tam da bu noktada <strong>Reaktif Programlama</strong> devreye giriyor. Spring Bootâ€™un <strong>Spring WebFlux</strong> ile sunduÄŸu mÃ¼kemmel destek sayesinde, geliÅŸtiriciler olarak engellemeyen (non-blocking), olay gÃ¼dÃ¼mlÃ¼ (event-driven) uygulamalar geliÅŸtirebiliyoruz.</p><p>Bu yazÄ±da, Spring Boot kullanarak reaktif programlamanÄ±n temellerini adÄ±m adÄ±m keÅŸfedecek, pratik Ã¶rneklerle pekiÅŸtirecek ve bu dÃ¼nyaya ilk adÄ±mÄ±nÄ± atanlar iÃ§in Ã¶nemli ipuÃ§larÄ± ve â€œince triklerâ€ paylaÅŸacaÄŸÄ±m. Hadi, baÅŸlayalÄ±m!</p><h3>1. Reaktif Programlama Nedir? Neden Gerekli?</h3><p>En basit tanÄ±mÄ±yla reaktif programlama, <strong>asenkron veri akÄ±ÅŸlarÄ±</strong> ve <strong>olay gÃ¼dÃ¼mlÃ¼ mimari</strong> Ã¼zerine kurulu bir programlama paradigmasÄ±dÄ±r. Geleneksel (imperative) programlamada bir iÅŸlem bitmeden diÄŸerine geÃ§emezken (blocking), reaktif yaklaÅŸÄ±mda iÅŸlemler birbirini beklemez. Bu sayede, Ã¶zellikle I/O (Input/Output) iÅŸlemleri gibi zaman alÄ±cÄ± operasyonlarda kaynaklarÄ±mÄ±zÄ± Ã§ok daha verimli kullanÄ±rÄ±z.</p><p><strong>Peki, bu ne anlama geliyor?</strong></p><p>DÃ¼ÅŸÃ¼nÃ¼n ki bir restoranda tek bir garson var ve her sipariÅŸi alÄ±p, mutfaÄŸa iletip, yemek piÅŸtikten sonra servis edip, ancak ondan sonra yeni bir sipariÅŸ alabiliyor. Bu, geleneksel programlamadaki â€œblockingâ€ mantÄ±ÄŸÄ±na benzer. Reaktif programlamada ise garson sipariÅŸi alÄ±r almaz mutfaÄŸa iletir ve hemen bir sonraki mÃ¼ÅŸteriden sipariÅŸ almaya devam eder. Mutfak yemeÄŸi hazÄ±rladÄ±ÄŸÄ±nda garsona haber verir ve garson da servisi yapar. Bu sayede Ã§ok daha fazla mÃ¼ÅŸteriye aynÄ± anda hizmet verilebilir.</p><p><strong>Reaktif ProgramlamanÄ±n Anahtar KavramlarÄ±:</strong></p><ul><li><strong>Reactive Streams:</strong> Asenkron veri iÅŸlemeyi â€œbackpressureâ€ (geri basÄ±nÃ§) ile yÃ¶netmek iÃ§in bir ÅŸartnamedir.</li><li><strong>Backpressure</strong>, <em>yayÄ±ncÄ±nÄ±n (Publisher) tÃ¼keticiyi (Subscriber) veriyle boÄŸmasÄ±nÄ± engeller. TÃ¼ketici, ne kadar veri alabileceÄŸini yayÄ±ncÄ±ya bildirir. Bu, sistemin Ã§Ã¶kmesini Ã¶nleyen kritik bir mekanizmadÄ±r.</em></li><li><strong>Publisher (YayÄ±ncÄ±):</strong> Bir veri akÄ±ÅŸÄ± yayar. (Ã–rn: VeritabanÄ±ndan gelen kullanÄ±cÄ± listesi)</li><li><strong>Subscriber (Abone):</strong> Publisher tarafÄ±ndan yayÄ±lan akÄ±ÅŸÄ± tÃ¼ketir. (Ã–rn: KullanÄ±cÄ± listesini alÄ±p iÅŸleyen bir servis)</li><li><strong>Subscription (Abonelik):</strong> Publisher ve Subscriber arasÄ±ndaki etkileÅŸimi yÃ¶netir. Subscriberâ€™Ä±n ne kadar veri talep ettiÄŸini ve aboneliÄŸi iptal etme gibi iÅŸlemleri kontrol eder.</li><li><strong>Processor (Ä°ÅŸlemci):</strong> Hem Publisher hem de Subscriber Ã¶zelliklerini taÅŸÄ±r. Veriyi alÄ±p, iÅŸleyip, farklÄ± bir formatta tekrar yayÄ±nlayabilir.</li></ul><h3>2. Reaktif Spring Boot Projesi Kurulumu: Ä°lk AdÄ±mlar</h3><p>Spring Boot ile reaktif programlamaya baÅŸlamak iÃ§in projemize bazÄ± temel baÄŸÄ±mlÄ±lÄ±klarÄ± eklememiz gerekiyor.</p><p><strong>AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± </strong><strong>pom.xml DosyasÄ±na Ekleyelim</strong></p><p>EÄŸer bir Maven projesi kullanÄ±yorsanÄ±z, pom.xml dosyanÄ±za aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br> &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br> &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br> &lt;optional&gt;true&lt;/optional&gt;<br> &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><ul><li><em>spring-boot-starter-webflux baÄŸÄ±mlÄ±lÄ±ÄŸÄ±, Netty gibi gÃ¶mÃ¼lÃ¼ reaktif sunucularÄ± ve reaktif HTTP istemcisi olan </em><em>WebClient&#39;Ä± projenize dahil eder. Geleneksel Spring MVC&#39;deki </em><em>spring-boot-starter-web ile aynÄ± anda kullanÄ±lmamalÄ±dÄ±r, Ã§Ã¼nkÃ¼ farklÄ± iÅŸ parÃ§acÄ±ÄŸÄ± modellerine dayanÄ±rlar.</em></li></ul><h3>3. Reaktif Veri Tipleri: Mono ve Flux ile TanÄ±ÅŸma</h3><p>Spring WebFlux, Project Reactor kÃ¼tÃ¼phanesini temel alÄ±r ve iki ana reaktif veri tipi sunar: Mono ve Flux.</p><ul><li><strong>Mono&lt;T&gt;:</strong> <strong>0 ya da 1</strong> eleman iÃ§eren bir akÄ±ÅŸÄ± temsil eder. Genellikle tek bir nesne dÃ¶ndÃ¼receÄŸiniz (Ã¶rneÄŸin, ID ile bir kullanÄ±cÄ± getirme) veya bir iÅŸlemin tamamlandÄ±ÄŸÄ±nÄ± (void) belirten durumlarda kullanÄ±lÄ±r.</li><li><strong><em>Ã–rnek:</em> </strong>Mono&lt;User&gt; (bir kullanÄ±cÄ±), Mono&lt;Void&gt; (bir iÅŸlem tamamlandÄ±).</li><li><strong>Flux&lt;T&gt;:</strong> <strong>0&#39;dan N&#39;e kadar</strong> (yani birden fazla) eleman iÃ§eren bir akÄ±ÅŸÄ± temsil eder. Veri akÄ±ÅŸlarÄ±, listeler veya sonsuz akÄ±ÅŸlar iÃ§in idealdir.</li><li><strong><em>Ã–rnek:</em> </strong>Flux&lt;Product&gt; (tÃ¼m Ã¼rÃ¼nler), Flux&lt;String&gt; (bir olay akÄ±ÅŸÄ±).</li></ul><p><strong>Mono ve </strong><strong>Flux Ã–rneÄŸi:</strong></p><pre>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>public class ReactiveExample {<br> public static void main(String[] args) {<br> // Tek bir deÄŸer iÃ§eren Mono<br> Mono&lt;String&gt; monoExample = Mono.just(&quot;Merhaba Reaktif DÃ¼nya!&quot;)<br> .log(); // AkÄ±ÅŸtaki olaylarÄ± gÃ¶rmek iÃ§in log() ekleyebiliriz.<br> // Mono&#39;ya abone olunduÄŸunda veri iÅŸlenir.<br> monoExample.subscribe(<br> data -&gt; System.out.println(&quot;Mono&#39;dan gelen: &quot; + data), // onNext: Veri geldiÄŸinde<br> error -&gt; System.err.println(&quot;Mono&#39;da hata: &quot; + error), // onError: Hata oluÅŸtuÄŸunda<br> () -&gt; System.out.println(&quot;Mono tamamlandÄ±!&quot;) // onComplete: AkÄ±ÅŸ bittiÄŸinde<br> );<br> System.out.println(&quot;---&quot;); // Ã‡Ä±ktÄ±larÄ± ayÄ±rmak iÃ§in<br> // Birden fazla deÄŸer iÃ§eren Flux<br> Flux&lt;String&gt; fluxExample = Flux.just(&quot;Elma&quot;, &quot;Armut&quot;, &quot;Ã‡ilek&quot;, &quot;Muz&quot;)<br> .map(String::toUpperCase) // Her elemanÄ± bÃ¼yÃ¼k harfe Ã§evir<br> .log(); // AkÄ±ÅŸtaki olaylarÄ± gÃ¶rmek iÃ§in<br> // Flux&#39;a abone olunduÄŸunda veri akÄ±ÅŸÄ± baÅŸlar.<br> fluxExample.subscribe(<br> data -&gt; System.out.println(&quot;Flux&#39;tan gelen: &quot; + data),<br> error -&gt; System.err.println(&quot;Flux&#39;ta hata: &quot; + error),<br> () -&gt; System.out.println(&quot;Flux tamamlandÄ±!&quot;)<br> );<br> }<br>}</pre><ul><li><em>Mono ve </em><em>Flux &quot;tembel&quot; (lazy) yapÄ±dadÄ±r. Yani, onlara </em><em>subscribe() metoduyla abone olunana kadar hiÃ§bir iÅŸlem yapmazlar. </em><em>subscribe() Ã§aÄŸrÄ±sÄ±, veri akÄ±ÅŸÄ±nÄ± tetikler. Bu, reaktif programlamaya yeni baÅŸlayanlarÄ±n sÄ±kÃ§a gÃ¶zden kaÃ§Ä±rdÄ±ÄŸÄ± bir noktadÄ±r. EÄŸer </em><em>subscribe() yapmazsanÄ±z, </em><em>map, </em><em>filter gibi operatÃ¶rleriniz Ã§alÄ±ÅŸmayacaktÄ±r!</em></li><li><em>.log() operatÃ¶rÃ¼, akÄ±ÅŸÄ±n iÃ§indeki olaylarÄ± (istek, yayÄ±nlama, tamamlama, iptal vb.) konsola yazdÄ±rmak iÃ§in geliÅŸtirme aÅŸamasÄ±nda Ã§ok faydalÄ±dÄ±r.</em></li></ul><h3>4. Reaktif Bir REST API Ä°nÅŸa Edelim: CRUD Ã–rneÄŸi</h3><p>Åimdi Spring WebFlux ve Reaktif MongoDB kullanarak basit bir ÃœrÃ¼n (Product) yÃ¶netimi iÃ§in CRUD (Create, Read, Update, Delete) APIâ€™si oluÅŸturalÄ±m.</p><p><strong>AdÄ±m 1: Entity SÄ±nÄ±fÄ±nÄ± TanÄ±mlayalÄ±m (</strong><strong>Product.java)</strong></p><p>MongoDBâ€™deki products koleksiyonumuza karÅŸÄ±lÄ±k gelecek bir model sÄ±nÄ±fÄ± oluÅŸturalÄ±m.</p><pre>import lombok.Data; // Getter, Setter, toString vb. iÃ§in<br>import lombok.AllArgsConstructor;<br>import lombok.NoArgsConstructor;<br>import org.springframework.data.annotation.Id;<br>import org.springframework.data.mongodb.core.mapping.Document;<br>@Data // Lombok: Getter, Setter, equals, hashCode, toString metodlarÄ±nÄ± otomatik oluÅŸturur.<br>@NoArgsConstructor // Lombok: ArgÃ¼mansÄ±z constructor oluÅŸturur.<br>@AllArgsConstructor // Lombok: TÃ¼m argÃ¼manlarÄ± iÃ§eren constructor oluÅŸturur.<br>@Document(collection = &quot;products&quot;) // Bu sÄ±nÄ±fÄ±n MongoDB&#39;de &#39;products&#39; adlÄ± bir koleksiyona karÅŸÄ±lÄ±k geldiÄŸini belirtir.<br>public class Product {<br> @Id // Bu alanÄ±n MongoDB&#39;deki _id alanÄ± olduÄŸunu belirtir.<br> private String id;<br> private String name;<br> private double price;<br> // Reaktif programlamada entity&#39;ler genellikle deÄŸiÅŸmez (immutable) olarak tasarlanÄ±r,<br> // ancak bu Ã¶rnekte basitlik iÃ§in Lombok @Data kullandÄ±k.<br>}</pre><p><strong>AdÄ±m 2: Reaktif Repository OluÅŸturalÄ±m (</strong><strong>ProductRepository.java)</strong></p><p>Spring Data, ReactiveMongoRepository arayÃ¼zÃ¼ ile MongoDB iÃ§in engellemeyen operasyonlarÄ± destekler.</p><pre>import org.springframework.data.mongodb.repository.ReactiveMongoRepository;<br>import reactor.core.publisher.Flux; <br>import org.springframework.stereotype.Repository;<br>@Repository // Bu arayÃ¼zÃ¼n bir Spring bileÅŸeni (repository) olduÄŸunu belirtir.<br>public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {<br> // ReactiveMongoRepository bize temel CRUD operasyonlarÄ±nÄ± (findAll, findById, save, deleteById vb.)<br> // Mono ve Flux dÃ¶necek ÅŸekilde hazÄ±r olarak sunar.<br> // Ä°htiyaÃ§ duyarsak Ã¶zel sorgu metotlarÄ± da tanÄ±mlayabiliriz.<br> // Spring Data, metot isminden sorguyu otomatik tÃ¼retir.<br> Flux&lt;Product&gt; findByName(String name); // Ä°sme gÃ¶re Ã¼rÃ¼nleri reaktif olarak getirir.<br>}</pre><ul><li><em>ReactiveMongoRepository&lt;Product, String&gt; ifadesindeki </em><em>Product entity tipini, </em><em>String ise </em><em>@Id ile iÅŸaretlediÄŸimiz alanÄ±n tipini (yani </em><em>id alanÄ±nÄ±n tipi) temsil eder.</em></li></ul><p><strong>AdÄ±m 3: Reaktif Servis KatmanÄ±nÄ± OluÅŸturalÄ±m (</strong><strong>ProductService.java)</strong></p><p>Ä°ÅŸ mantÄ±ÄŸÄ±mÄ±zÄ± yÃ¶neteceÄŸimiz servis sÄ±nÄ±fÄ±nÄ± oluÅŸturalÄ±m.</p><pre>import org.springframework.stereotype.Service;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired; // Alternatif olarak constructor injection<br>@Service // Bu sÄ±nÄ±fÄ±n bir Spring bileÅŸeni (servis) olduÄŸunu belirtir.<br>public class ProductService {<br> private final ProductRepository productRepository;<br> // BaÄŸÄ±mlÄ±lÄ±klarÄ± constructor Ã¼zerinden enjekte etmek best practice&#39;dir.<br> @Autowired // Spring 4.3 ve sonrasÄ± iÃ§in constructor injection&#39;da @Autowired zorunlu deÄŸil,<br> // eÄŸer sÄ±nÄ±fta tek bir constructor varsa.<br> public ProductService(ProductRepository productRepository) {<br> this.productRepository = productRepository;<br> }<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productRepository.findAll();<br> }<br> public Mono&lt;Product&gt; getProductById(String id) {<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;ÃœrÃ¼n bulunamadÄ±: &quot; + id))); // ÃœrÃ¼n yoksa Ã¶zel hata fÄ±rlat<br> }<br> public Mono&lt;Product&gt; createProduct(Product product) {<br> // Gelen Ã¼rÃ¼nÃ¼n ID&#39;si varsa (gÃ¼ncelleme gibi), bunu engellemek veya farklÄ± yÃ¶netmek isteyebilirsiniz.<br> // Bu Ã¶rnekte basitÃ§e save() Ã§aÄŸÄ±rÄ±yoruz. MongoDB yeni bir ID atayacaktÄ±r eÄŸer null ise.<br> return productRepository.save(product);<br> }<br> public Mono&lt;Product&gt; updateProduct(String id, Product product) {<br> return productRepository.findById(id)<br> .flatMap(existingProduct -&gt; { // flatMap, Mono&lt;Mono&lt;Product&gt;&gt; yerine Mono&lt;Product&gt; dÃ¶nmek iÃ§in kullanÄ±lÄ±r.<br> existingProduct.setName(product.getName());<br> existingProduct.setPrice(product.getPrice());<br> return productRepository.save(existingProduct);<br> })<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;GÃ¼ncellenecek Ã¼rÃ¼n bulunamadÄ±: &quot; + id)));<br> }<br> public Mono&lt;Void&gt; deleteProduct(String id) {<br> // Ã–nce var olup olmadÄ±ÄŸÄ±nÄ± kontrol edip sonra silmek daha gÃ¼venli olabilir.<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Silinecek Ã¼rÃ¼n bulunamadÄ±: &quot; + id)))<br> .flatMap(productRepository::delete); // product -&gt; productRepository.delete(product) ile aynÄ±.<br> // deleteById de kullanÄ±labilir: productRepository.deleteById(id)<br> }<br>}<br>// Basit bir custom exception sÄ±nÄ±fÄ±<br>class ProductNotFoundException extends RuntimeException {<br> public ProductNotFoundException(String message) {<br> super(message);<br> }<br>}</pre><ul><li><em>switchIfEmpty() operatÃ¶rÃ¼, bir </em><em>Mono veya </em><em>Flux boÅŸ geldiÄŸinde (yani hiÃ§ eleman yayÄ±nlamadÄ±ÄŸÄ±nda) alternatif bir </em><em>Mono veya </em><em>Flux saÄŸlamak ya. da bir hata fÄ±rlatmak iÃ§in kullanÄ±lÄ±r. </em><em>getProductById Ã¶rneÄŸinde, Ã¼rÃ¼n bulunamazsa </em><em>ProductNotFoundException fÄ±rlatÄ±yoruz.</em></li><li><em>flatMap() operatÃ¶rÃ¼, bir </em><em>Mono veya </em><em>Flux iÃ§indeki elemanÄ± alÄ±p, bu elemanla baÅŸka bir asenkron iÅŸlem (baÅŸka bir </em><em>Mono veya </em><em>Flux dÃ¶ndÃ¼ren) yapmak istediÄŸinizde kullanÄ±lÄ±r. Sonucu &quot;dÃ¼zleÅŸtirir&quot;. EÄŸer </em><em>map() kullansaydÄ±k </em><em>Mono&lt;Mono&lt;Product&gt;&gt; gibi bir sonuÃ§ alÄ±rdÄ±k, </em><em>flatMap ise bunu </em><em>Mono&lt;Product&gt;&#39;a Ã§evirir.</em></li></ul><p><strong>AdÄ±m 4: Reaktif REST Controller OluÅŸturalÄ±m (</strong><strong>ProductController.java)</strong></p><p>API endpointâ€™lerimizi dÄ±ÅŸ dÃ¼nyaya aÃ§acaÄŸÄ±mÄ±z controller sÄ±nÄ±fÄ±nÄ± yazalÄ±m.</p><pre>import org.springframework.web.bind.annotation.*;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.http.HttpStatus;<br>import org.springframework.http.ResponseEntity; // ResponseEntity ile daha detaylÄ± yanÄ±tlar<br>@RestController // Bu sÄ±nÄ±fÄ±n bir RESTful controller olduÄŸunu belirtir.<br> // Gelen istekleri iÅŸler ve HTTP yanÄ±tlarÄ± dÃ¶ner.<br>@RequestMapping(&quot;/api/v1/products&quot;) // Bu controller&#39;daki tÃ¼m endpoint&#39;ler &quot;/api/v1/products&quot; altÄ±nda olacak.<br>public class ProductController {<br> private final ProductService productService;<br> @Autowired<br> public ProductController(ProductService productService) {<br> this.productService = productService;<br> }<br> @GetMapping<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productService.getAllProducts();<br> }<br> @GetMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {<br> return productService.getProductById(id)<br> .map(ResponseEntity::ok) // Product -&gt; ResponseEntity.ok(product)<br> .defaultIfEmpty(ResponseEntity.notFound().build()); // Mono boÅŸsa 404 Not Found<br> }<br> @PostMapping<br> @ResponseStatus(HttpStatus.CREATED) // BaÅŸarÄ±lÄ± POST isteÄŸi iÃ§in 201 Created durumu dÃ¶ner.<br> public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {<br> // @RequestBody: Gelen JSON verisini Product nesnesine mapler.<br> return productService.createProduct(product);<br> }<br> @PutMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(@PathVariable String id, @RequestBody Product product) {<br> return productService.updateProduct(id, product)<br> .map(ResponseEntity::ok)<br> .defaultIfEmpty(ResponseEntity.notFound().build());<br> }<br> @DeleteMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteProduct(@PathVariable String id) {<br> return productService.deleteProduct(id)<br> .map(ResponseEntity.noContent()::build) // BaÅŸarÄ±lÄ± silme sonrasÄ± 204 No Content<br> .onErrorResume(ProductNotFoundException.class, e -&gt; Mono.just(ResponseEntity.notFound().build())); // ÃœrÃ¼n yoksa 404<br> }<br> // Hata yÃ¶netimi iÃ§in merkezi bir @ExceptionHandler da eklenebilir.<br> @ExceptionHandler(ProductNotFoundException.class)<br> public ResponseEntity&lt;String&gt; handleProductNotFound(ProductNotFoundException ex) {<br> return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());<br> }<br>}</pre><ul><li><em>Controller metotlarÄ±mÄ±z artÄ±k </em><em>Mono&lt;Product&gt;, </em><em>Flux&lt;Product&gt; veya </em><em>Mono&lt;ResponseEntity&lt;T&gt;&gt; gibi reaktif tipler dÃ¶nÃ¼yor. Spring WebFlux, bu reaktif tiplere abone olup, sonuÃ§lar geldikÃ§e HTTP yanÄ±tÄ±nÄ± asenkron olarak yazar.</em></li><li><em>@ResponseStatus(HttpStatus.CREATED) gibi anotasyonlarla veya </em><em>ResponseEntity kullanarak HTTP durum kodlarÄ±nÄ± daha detaylÄ± yÃ¶netebilirsiniz. </em><em>defaultIfEmpty ve </em><em>onErrorResume gibi operatÃ¶rler, controller seviyesinde de hata durumlarÄ±nÄ± ve boÅŸ sonuÃ§larÄ± yÃ¶netmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.</em></li></ul><h3>5. Reaktif APIâ€™mizi Test Edelim</h3><p>APIâ€™nizi test etmek iÃ§in Postman, Insomnia gibi araÃ§larÄ± veya cURL komut satÄ±rÄ± aracÄ±nÄ± kullanabilirsiniz. Spring Boot uygulamanÄ±z varsayÄ±lan olarak 8080 portunda Ã§alÄ±ÅŸacaktÄ±r.</p><p><strong>Yeni Bir ÃœrÃ¼n OluÅŸturma (POST):</strong></p><pre>curl -X POST http://localhost:8080/api/v1/products \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;AkÄ±llÄ± Saat&quot;,&quot;price&quot;:2500.75}&#39;</pre><p><strong>TÃ¼m ÃœrÃ¼nleri Getirme (GET):</strong></p><pre>curl -X GET http://localhost:8080/api/v1/products</pre><p><em>Bu komut, bir JSON dizisi olarak Ã¼rÃ¼nleri listeler. EÄŸer </em><em>text/event-stream olarak isterseniz, sunucu tarafÄ±nda bunu desteklemeniz gerekir ve istemci de buna gÃ¶re istek yapmalÄ±dÄ±r.</em></p><p><strong>ID ile ÃœrÃ¼n Getirme (GET):</strong> Ã–nce bir Ã¼rÃ¼n oluÅŸturup IDâ€™sini alÄ±n, sonra o ID ile sorgulayÄ±n.</p><pre># ID&#39;yi bir Ã¶nceki POST isteÄŸinin yanÄ±tÄ±ndan veya GET All Products&#39;tan alÄ±n<br>curl -X GET http://localhost:8080/api/v1/products/{id}</pre><p><strong>ÃœrÃ¼n GÃ¼ncelleme (PUT):</strong></p><pre>curl -X PUT http://localhost:8080/api/v1/products/{id} \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Yeni AkÄ±llÄ± Saat Model X&quot;,&quot;price&quot;:2750.00}&#39;</pre><p><strong>ÃœrÃ¼n Silme (DELETE):</strong></p><pre>curl -X DELETE http://localhost:8080/api/v1/products/{id}</pre><ul><li><em>Spring WebFlux ile </em><em>WebClient kullanarak reaktif API&#39;lerinizi programatik olarak test edebilirsiniz. Bu, Ã¶zellikle entegrasyon testleri yazarken Ã§ok kullanÄ±ÅŸlÄ±dÄ±r.</em></li></ul><pre>// Ã–rnek WebClient kullanÄ±mÄ± (test sÄ±nÄ±fÄ± iÃ§inde)<br>// @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br>// class ProductControllerIntegrationTests {<br>//<br>// @Autowired<br>// private WebTestClient webTestClient;<br>//<br>// @Test<br>// void testGetAllProducts() {<br>// webTestClient.get().uri(&quot;/api/v1/products&quot;)<br>// .exchange() // Ä°steÄŸi gÃ¶nder ve yanÄ±tÄ± al<br>// .expectStatus().isOk() // HTTP durumunun 200 OK olmasÄ±nÄ± bekle<br>// .expectHeader().contentType(MediaType.APPLICATION_JSON) // Ä°Ã§erik tipinin JSON olmasÄ±nÄ± bekle<br>// .expectBodyList(Product.class).hasSize(expectedSize); // Beklenen sayÄ±da Ã¼rÃ¼n olmasÄ±nÄ± kontrol et<br>// }<br>// }</pre><h3>6. Reaktif ProgramlamanÄ±n FaydalarÄ± (KÄ±saca)</h3><ul><li><strong>Engellemeyen I/O (Non-blocking I/O):</strong> Daha az kaynakla daha fazla isteÄŸi iÅŸleyebilir. Her istek iÃ§in ayrÄ± bir thread oluÅŸturmak yerine, az sayÄ±da thread ile (event loop) Ã§ok sayÄ±da isteÄŸi yÃ¶netir.</li><li><strong>Daha Ä°yi Ã–lÃ§eklenebilirlik:</strong> Ã–zellikle mikroservis mimarilerinde ve gerÃ§ek zamanlÄ± uygulamalarda yatay Ã¶lÃ§eklenmeyi kolaylaÅŸtÄ±rÄ±r.</li><li><strong>Verimli Kaynak KullanÄ±mÄ±:</strong> Threadâ€™lerin bloke olmasÄ±nÄ± azaltarak CPU ve bellek kullanÄ±mÄ±nÄ± optimize eder.</li><li><strong>AkÄ±ÅŸ (Streaming) Yetenekleri:</strong> BÃ¼yÃ¼k veri kÃ¼melerini veya sonsuz veri akÄ±ÅŸlarÄ±nÄ± (Ã¶rneÄŸin, sensÃ¶r verileri, sosyal medya akÄ±ÅŸlarÄ±) verimli bir ÅŸekilde iÅŸleyebilir.</li></ul><h3>7. Reaktif Programlama Ne Zaman KullanÄ±lmalÄ±? (AltÄ±n Kural!)</h3><p>âœ… <strong>GerÃ§ek zamanlÄ± uygulamalar</strong> iÃ§in idealdir: Sohbet uygulamalarÄ±, canlÄ± borsa verileri, IoT (Nesnelerin Ä°nterneti) uygulamalarÄ±, bildirim servisleri.</p><p>âœ… <strong>YÃ¼ksek trafikli (high-throughput)</strong> ve Ã¶lÃ§eklenebilirlik gerektiren servisler iÃ§in Ã§ok faydalÄ±dÄ±r. Ã–zellikle I/O baÄŸÄ±mlÄ± (veritabanÄ±, harici API Ã§aÄŸrÄ±larÄ±) iÅŸlemleri yoÄŸun olan servisler.</p><p>âœ… <strong>Veri akÄ±ÅŸlarÄ±nÄ±n (data streams)</strong> iÅŸlenmesi gereken durumlar.</p><p>âŒ <strong>DÃ¼ÅŸÃ¼k eÅŸzamanlÄ±lÄ±k (concurrency)</strong> ihtiyacÄ± olan, basit CRUD (Create, Read, Update, Delete) tabanlÄ± geleneksel uygulamalar iÃ§in <strong>gereksiz karmaÅŸÄ±klÄ±k</strong> getirebilir. EÄŸer uygulamanÄ±zÄ±n darboÄŸazÄ± I/O deÄŸilse veya trafik Ã§ok dÃ¼ÅŸÃ¼kse, reaktif programlamanÄ±n faydalarÄ±nÄ± gÃ¶remeyebilirsiniz.</p><ul><li><em>Reaktif programlama bir â€œgÃ¼mÃ¼ÅŸ kurÅŸunâ€ deÄŸildir. Her probleme Ã§Ã¶zÃ¼m sunmaz. Projenizin ihtiyaÃ§larÄ±nÄ± iyi analiz edip, reaktif mimarinin getireceÄŸi faydalarÄ±n, Ã¶ÄŸrenme eÄŸrisi ve potansiyel karmaÅŸÄ±klÄ±ÄŸa deÄŸip deÄŸmeyeceÄŸine karar vermelisiniz.</em></li></ul><h3>Yeni BaÅŸlayanlar Ä°Ã§in Ekstra Ä°puÃ§larÄ± ve Dikkat Edilmesi Gerekenler</h3><ol><li><strong>FarklÄ± DÃ¼ÅŸÃ¼nme BiÃ§imi:</strong> Reaktif programlama, geleneksel imperative programlamadan farklÄ± bir dÃ¼ÅŸÃ¼nme biÃ§imi gerektirir. AkÄ±ÅŸlarÄ± ve olaylarÄ± dÃ¼ÅŸÃ¼nmeye alÄ±ÅŸmak zaman alabilir.</li><li><strong>subscribe() Hayati Ã–nem TaÅŸÄ±r:</strong> UnutmayÄ±n, Mono ve Flux tembeldir. subscribe() Ã§aÄŸrÄ±lmadÄ±kÃ§a hiÃ§bir ÅŸey olmaz.</li><li><strong>Hata YÃ¶netimi:</strong> Reaktif akÄ±ÅŸlarda hata yÃ¶netimi farklÄ±dÄ±r. onErrorMap, onErrorResume, onErrorReturn gibi operatÃ¶rlerle hatalarÄ± yakalayÄ±p yÃ¶netebilirsiniz. Merkezi hata yÃ¶netimi iÃ§in @ControllerAdvice ve ExceptionHandler kullanabilirsiniz.</li><li><strong>Debugging (Hata AyÄ±klama):</strong> Reaktif akÄ±ÅŸlarÄ± debug etmek, geleneksel kodlara gÃ¶re biraz daha zorlayÄ±cÄ± olabilir. .log(), doOnNext(), doOnError() gibi operatÃ¶rler ve Reactor&#39;un BlockHound gibi araÃ§larÄ± yardÄ±mcÄ± olabilir. IDE&#39;nizin reaktif debug yeteneklerini de keÅŸfedin.</li><li><strong>Thread YÃ¶netimi:</strong> Spring WebFlux, varsayÄ±lan olarak Nettyâ€™nin event loopâ€™larÄ±nÄ± kullanÄ±r. Uzun sÃ¼ren CPU-yoÄŸun iÅŸlemleriniz varsa, bunlarÄ± Schedulers.boundedElastic() gibi farklÄ± bir thread havuzunda Ã§alÄ±ÅŸtÄ±rmayÄ± dÃ¼ÅŸÃ¼nmelisiniz ki event loop&#39;larÄ± bloke etmeyin.</li><li><strong>Engellemeyen KÃ¼tÃ¼phaneler:</strong> Reaktif bir sistemde, tÃ¼m Ã§aÄŸrÄ±larÄ±n (veritabanÄ±, harici servisler vb.) engellemeyen (non-blocking) olmasÄ± Ã¶nemlidir. EÄŸer reaktif bir akÄ±ÅŸ iÃ§inde engelleme yapan bir kÃ¼tÃ¼phane Ã§aÄŸrÄ±sÄ± yaparsanÄ±z, reaktifliÄŸin tÃ¼m faydalarÄ±nÄ± kaybedebilirsiniz. Spring Data Reactive Repositories (MongoDB, R2DBC vs.) ve WebClient bu yÃ¼zden Ã¶nemlidir.</li></ol><h3>SonuÃ§</h3><p>Bu yazÄ±da, Spring Boot ve WebFlux ile reaktif programlamaya kapsamlÄ± bir giriÅŸ yaptÄ±k. Temel kavramlarÄ±, Mono ve Flux&#39;Ä±, reaktif bir REST API&#39;nin nasÄ±l oluÅŸturulacaÄŸÄ±nÄ± ve test edileceÄŸini adÄ±m adÄ±m inceledik. AyrÄ±ca, yeni baÅŸlayanlar iÃ§in Ã¶nemli ipuÃ§larÄ± ve dikkat edilmesi gereken noktalarÄ± paylaÅŸtÄ±m.</p><p>Reaktif programlama, modern uygulama geliÅŸtirmenin gÃ¼Ã§lÃ¼ bir aracÄ±dÄ±r, ancak doÄŸru yerde ve doÄŸru ÅŸekilde kullanÄ±ldÄ±ÄŸÄ±nda en iyi sonuÃ§larÄ± verir. EÄŸer uygulamanÄ±z asenkron ve engellemeyen bir yapÄ±ya gerÃ§ekten ihtiyaÃ§ duyuyorsa, Spring WebFlux sizin iÃ§in harika bir seÃ§enektir.</p><p>UmarÄ±m bu yazÄ±, reaktif programlama yolculuÄŸunuzda size iyi bir baÅŸlangÄ±Ã§ noktasÄ± sunmuÅŸtur. Yorumlarda sorularÄ±nÄ±zÄ± ve deneyimlerinizi paylaÅŸmaktan Ã§ekinmeyin! Mutlu kodlamalar!</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5815c96be738" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Apache Kafka Entegrasyonu: AdÄ±m AdÄ±m Rehber ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-apache-kafka-entegrasyonu-ad%C4%B1m-ad%C4%B1m-rehber-8f2d4416f987?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/8f2d4416f987</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:21:57 GMT</pubDate>
<atom:updated>2025-06-20T05:14:23.618Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*4TWM0sbXF0b8oxc2EPkomg.png" /></figure><p>Apache Kafka, yÃ¼ksek hacimli veri akÄ±ÅŸlarÄ±nÄ± iÅŸlemek iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ bir daÄŸÄ±tÄ±k mesajlaÅŸma sistemidir. Spring Boot ise mikroservis mimarilerinde ve modern uygulamalarda hÄ±zlÄ± geliÅŸtirme iÃ§in ideal bir frameworkâ€™tÃ¼r. Bu yazÄ±da Spring Boot uygulamasÄ± ile Apache Kafkaâ€™yÄ± nasÄ±l entegre edeceÄŸimizi adÄ±m adÄ±m Ã¶ÄŸreneceÄŸiz.</p><h3>ğŸ”§ 1. Gerekli AraÃ§lar ve Kurulumlar</h3><h3>KullandÄ±ÄŸÄ±mÄ±z Teknolojiler:</h3><ul><li><strong>Java 17+</strong></li><li><strong>Spring Boot 3.x</strong></li><li><strong>Apache Kafka (2.8+)</strong></li><li><strong>Spring Tool Suite (STS) veya IntelliJ IDEA</strong></li><li><strong>Maven (Dependency Management)</strong></li><li><strong>Postman (API Testi)</strong></li></ul><h3>Kafka Kurulumu:</h3><ol><li>Apache Kafkaâ€™yÄ± <a href="https://kafka.apache.org/downloads">resmi sitesinden</a> indirin.</li><li>config/server.properties dosyasÄ±nÄ± aÃ§Ä±n ve gerekirse listeners ve port ayarlarÄ±nÄ± dÃ¼zenleyin (varsayÄ±lan port: 9092).</li><li>Kafkaâ€™yÄ± baÅŸlatÄ±n:</li></ol><pre># Zookeeper&#39;Ä± baÅŸlat bin/zookeeper-server-start.sh config/zookeeper.properties <br># Kafka broker&#39;Ä± baÅŸlat bin/kafka-server-start.sh config/server.properties</pre><h3>ğŸ“¦ 2. Spring Boot Projesi OluÅŸturma</h3><p>STS veya IntelliJ Ã¼zerinden yeni bir Spring Boot projesi oluÅŸturun. Gerekli baÄŸÄ±mlÄ±lÄ±klar:</p><pre>&lt;!-- Spring for Apache Kafka --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Web (REST API iÃ§in) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Boot DevTools (GeliÅŸtirme KolaylÄ±ÄŸÄ±) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>ğŸ” 3. Ana SÄ±nÄ±f: Kafka Entegrasyonunu Aktif Hale Getirme</h3><p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za @EnableKafka ekleyerek Kafka desteÄŸi aktif edilir:</p><pre>@SpringBootApplication<br>@EnableKafka<br>public class SpringBootKafkaApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(SpringBootKafkaApplication.class, args);<br> }<br>}</pre><h3>ğŸ—„ï¸ 4. MesajlarÄ± Saklamak Ä°Ã§in Repository OluÅŸturma</h3><p>Basit bir MessageRepository, alÄ±nan Kafka mesajlarÄ±nÄ± geÃ§ici olarak saklamak iÃ§in kullanÄ±lÄ±r.</p><pre>@Component<br>public class MessageRepository {<br> private List&lt;String&gt; messages = new ArrayList&lt;&gt;();<br>public void addMessage(String message) {<br> messages.add(message);<br> }<br> public String getAllMessages() {<br> return messages.toString();<br> }<br>}</pre><blockquote><em>ğŸ’¡ Bu repository, sadece demo amaÃ§lÄ±dÄ±r. GerÃ§ek senaryolarda Redis, MongoDB gibi veri tabanlarÄ± kullanÄ±labilir.</em></blockquote><h3>ğŸšš 5. Mesaj Ãœretici (Producer): Kafkaâ€™ya Veri GÃ¶nderimi</h3><p>MessageProducer, Kafka topicâ€™ine mesaj gÃ¶ndermek iÃ§in kullanÄ±lÄ±r:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageProducer {<br><br> private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br><br> @Value(&quot;${myapp.kafka.topic}&quot;)<br> private String topic;<br><br> public void sendMessage(String message) {<br> log.info(&quot;MESAJ ÃœRETÄ°CÄ°DEN GÃ–NDERÄ°LÄ°YOR -&gt; {}&quot;, message);<br> kafkaTemplate.send(topic, message);<br> }<br>}</pre><h3>KafkaTemplate Nedir?</h3><ul><li>Kafka ile etkileÅŸim kurmak iÃ§in kullanÄ±lan Springâ€™in yÃ¼ksek seviye APIâ€™sidir.</li><li>KafkaTemplate sayesinde mesaj gÃ¶nderimi (send) kolaylaÅŸtÄ±rÄ±lÄ±r.</li></ul><h3>ğŸ“¥ 6. Mesaj TÃ¼ketici (Consumer): Kafkaâ€™dan Veri Alma</h3><p>@KafkaListener, belirtilen topicâ€™teki mesajlarÄ± dinler ve iÅŸler:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageConsumer {<br><br> private final MessageRepository messageRepo;<br><br> @KafkaListener(topics = &quot;${myapp.kafka.topic}&quot;, groupId = &quot;kafka-group&quot;)<br> public void consume(String message) {<br> log.info(&quot;MESAJ TÃœKETÄ°CÄ°YE ULAÅTI -&gt; {}&quot;, message);<br> messageRepo.addMessage(message);<br> }<br>}</pre><h3>Anahtar Ã–zellikler:</h3><ul><li><strong>topics</strong>: Dinlenen Kafka topicâ€™i.</li><li><strong>groupId</strong>: TÃ¼ketici grubunu tanÄ±mlar. AynÄ± gruptaki tÃ¼keticiler mesajlarÄ± paylaÅŸÄ±r.</li></ul><h3>ğŸŒ 7. REST API ile EtkileÅŸim: KafkaRestController</h3><p>REST istemcileri iÃ§in basit bir arayÃ¼z saÄŸlar:</p><pre>@Slf4j<br>@RestController<br>@RequestMapping(&quot;/api/kafka&quot;)<br>@RequiredArgsConstructor<br>public class KafkaRestController {<br><br> private final MessageProducer producer;<br> private final MessageRepository messageRepo;<br><br> // Kafka topic&#39;ine mesaj gÃ¶nder<br> @GetMapping(&quot;/send&quot;)<br> public ResponseEntity&lt;String&gt; sendMsg(@RequestParam(&quot;msg&quot;) String message) {<br> log.info(&quot;REST API ÃœZERÄ°NDEN MESAJ ALINDI -&gt; {}&quot;, message);<br> producer.sendMessage(message);<br> return ResponseEntity.ok(&quot;&#39;&quot; + message + &quot;&#39; mesajÄ± baÅŸarÄ±yla gÃ¶nderildi!&quot;);<br> }<br><br> // AlÄ±nan tÃ¼m mesajlarÄ± listele<br> @GetMapping(&quot;/messages&quot;)<br> public ResponseEntity&lt;String&gt; getAllMessages() {<br> return ResponseEntity.ok(messageRepo.getAllMessages());<br> }<br>}</pre><h3>API KullanÄ±mÄ±:</h3><p>GET /send?msg=... Kafka topic&#39;ine mesaj gÃ¶nder</p><p>GET /getAllTÃ¼m alÄ±nan mesajlarÄ± listele</p><h3>âš™ï¸ 8. Uygulama YapÄ±landÄ±rmasÄ±: application.yml</h3><pre>server:<br> port: 9090<br>spring:<br> kafka:<br> producer:<br> bootstrap-servers: localhost:9092<br> key-serializer: org.apache.kafka.common.serialization.StringSerializer<br> value-serializer: org.apache.kafka.common.serialization.StringSerializer<br> consumer:<br> bootstrap-servers: localhost:9092<br> key-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br> value-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br>myapp:<br> kafka:<br> topic: myKafkaTest</pre><h3>YapÄ±landÄ±rma AÃ§Ä±klamalarÄ±:</h3><ul><li><strong>bootstrap-servers</strong>: Kafka brokerâ€™Ä±n adresi.</li><li><strong>key-serializer/deserializer</strong>: AnahtarlarÄ±n nasÄ±l serileÅŸtirileceÄŸi.</li><li><strong>value-serializer/deserializer</strong>: Mesaj iÃ§eriÄŸinin serileÅŸtirme biÃ§imi.</li><li><strong>topic</strong>: Dinlenen veya yazÄ±lan Kafka topicâ€™i.</li></ul><h3>ğŸ§  9. Kafka Entegrasyonu Ä°Ã§in Ä°puÃ§larÄ± ve En Ä°yi Uygulamalar</h3><h3>1. Hata YÃ¶netimi ve Retry MekanizmalarÄ±</h3><ul><li>@Retryable anotasyonu ile otomatik tekrar deneme yapÄ±labilir.</li><li>Kafka Consumer iÃ§inde Acknowledgment ile manuel commit yapÄ±labilir.</li></ul><pre>@KafkaListener(topics = &quot;myTopic&quot;)<br>public void listen(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack) {<br> try {<br> // Ä°ÅŸlemler<br> ack.acknowledge(); // BaÅŸarÄ±lÄ±ysa commit<br> } catch (Exception e) {<br> // Hata yÃ¶netimi<br> }<br>}</pre><h3>2. Dead Letter Queue (DLQ)</h3><ul><li>BaÅŸarÄ±sÄ±z mesajlarÄ± baÅŸka bir topicâ€™e yÃ¶nlendirmek iÃ§in DLQ kullanÄ±labilir.</li></ul><h3>3. Serialization</h3><ul><li>JSON formatÄ±nda mesaj gÃ¶ndermek iÃ§in JsonSerializer kullanÄ±labilir.</li><li>@KafkaListener metotlarÄ±nda ConsumerRecord ile header bilgileri de alÄ±nabilir.</li></ul><h3>4. Partitions ve Offset YÃ¶netimi</h3><ul><li>Topic partition sayÄ±sÄ± artÄ±rÄ±larak paralel tÃ¼ketim saÄŸlanabilir.</li><li>auto.offset.reset ayarÄ± ile tÃ¼ketici baÅŸlangÄ±Ã§ta hangi offsetâ€™ten baÅŸlayacak belirlenir (Ã¶rnek: earliest, latest).</li></ul><h3>ğŸ§ª 10. Test SÃ¼reci</h3><h3>1. Kafka Topic OluÅŸturma</h3><pre>bin/kafka-topics.sh --create --topic myKafkaTest --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1</pre><h3>2. Kafka Consumer CLI ile Mesaj Dinleme</h3><pre>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic myKafkaTest --from-beginning</pre><h3>3. API ile Mesaj GÃ¶nderme</h3><pre>curl http://localhost:9090/send?msg=MerhabaKafka</pre><h3>4. AlÄ±nan MesajlarÄ± GÃ¶rÃ¼ntÃ¼leme</h3><pre>curl http://localhost:9090/getAll</pre><h3>ğŸ“Œ 11. GÃ¼venlik ve Performans Ä°puÃ§larÄ±</h3><h3>1. SSL/TLS ile GÃ¼venli BaÄŸlantÄ±</h3><ul><li>Kafka baÄŸlantÄ±sÄ± iÃ§in SSL ayarlarÄ± yapÄ±labilir.</li><li>ssl.truststore.location ve ssl.keystore.location gibi parametreler application.ymlâ€™de tanÄ±mlanÄ±r.</li></ul><h3>2. Mesaj SÄ±kÄ±ÅŸtÄ±rmasÄ±</h3><ul><li>compression.type ile mesajlar sÄ±kÄ±ÅŸtÄ±rÄ±labilir (gzip, snappy, lz4).</li></ul><h3>3. Mesaj DoÄŸrulama</h3><ul><li>@Validated ve @KafkaListener ile gelen mesajlar doÄŸrulanabilir.</li></ul><h3>ğŸ§­ 12. SonuÃ§</h3><p>Spring Boot ile Apache Kafka entegrasyonu, mikroservislerde asenkron mesajlaÅŸma, olay tabanlÄ± mimariler, log toplama ve gerÃ§ek zamanlÄ± veri iÅŸleme gibi birÃ§ok senaryoda gÃ¼Ã§lÃ¼ Ã§Ã¶zÃ¼mler sunar. Bu yazÄ±da, temel yapÄ±landÄ±rmalarla birlikte Kafka topicâ€™ine mesaj gÃ¶nderme ve alma iÅŸlemlerini basitÃ§e adÄ±m adÄ±m Ã¶ÄŸrendik.</p><h3>âœ… Ã–ÄŸrendiklerimiz:</h3><ul><li>Kafka ile Spring Boot entegrasyonu</li><li>Producer ve Consumer sÄ±nÄ±flarÄ±</li><li>REST API ile Kafka etkileÅŸimi</li><li>YapÄ±landÄ±rma ve hata yÃ¶netimi</li><li>GÃ¼venlik ve performans optimizasyonlarÄ±</li></ul><p>Bu temel yapÄ±yÄ± alarak Kafka ile daha karmaÅŸÄ±k senaryolar (Ã¶rneÄŸin event sourcing, stream processing) da geliÅŸtirebilirsiniz.</p><h3>ğŸ“˜ Ekstra Kaynaklar</h3><ul><li><a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/">Spring Kafka Documentation</a></li><li><a href="https://kafka.apache.org/documentation/">Apache Kafka Official Docs</a></li><li><a href="https://kafka.apache.org/documentation/streams/">Kafka Streams ile GerÃ§ek ZamanlÄ± Veri Ä°ÅŸleme</a></li><li><a href="https://www.baeldung.com/spring-kafka">Kafka ile Mikroservis Mimari TasarÄ±mÄ±â€Šâ€”â€ŠBaeldung</a></li></ul><p>EÄŸer bu yazÄ± hoÅŸunuza gittiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± ya da Ã¶nerilerinizi yorumlarda bekliyorum. ğŸ˜Š</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8f2d4416f987" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Javaâ€™da SerileÅŸtirme (Serialization) ve En Ä°yi Uygulamalar ]]>
</title>
<link>https://pehlivanmert.medium.com/javada-serile%C5%9Ftirme-serialization-ve-en-i%CC%87yi-uygulamalar-4fd05ec48a4a?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4fd05ec48a4a</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:05:31 GMT</pubDate>
<atom:updated>2025-06-20T05:14:35.910Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/629/1*pwMbKl8czO8lGyLut1HDZQ.png" /></figure><p>Javaâ€™da serileÅŸtirme (<strong>serialization</strong>), bir nesnenin durumunun (state) bayt dizisine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recidir. Bu iÅŸlem sayesinde nesneler kalÄ±cÄ± olarak saklanabilir (Ã¶rneÄŸin dosya ya da veritabanÄ±nda), aÄŸ Ã¼zerinden aktarÄ±labilir veya geÃ§ici olarak Ã¶nbellekte tutulabilir. SerileÅŸtirme sÃ¼recinin tersi olan <strong>deserileÅŸtirme (deserialization)</strong> ise bu bayt dizisinin tekrar orijinal nesneye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesini saÄŸlar.</p><p>Bu yazÄ±da Javaâ€™daki serileÅŸtirme mekanizmasÄ±nÄ± ele alacak, ne zaman kullanÄ±lmasÄ± gerektiÄŸini ve en iyi uygulama yÃ¶ntemlerini adÄ±m adÄ±m inceleyeceÄŸiz.</p><h3>ğŸ“Œ SerileÅŸtirme Nedir?</h3><p>SerileÅŸtirme, bir nesnenin iÃ§eriÄŸini (durumunu) bayt dizisine Ã§evirerek farklÄ± ortamlarda taÅŸÄ±nabilir hale getiren bir tekniktir. Ã–zetle:</p><ul><li>Nesneler kalÄ±cÄ± olarak saklanabilir.</li><li>AÄŸ Ã¼zerinden gÃ¶nderilip alÄ±nabilir.</li><li>HÄ±zlÄ±ca geri yÃ¼klenebilir (deserialize edilebilir).</li></ul><p>Bir sÄ±nÄ±fÄ±n serileÅŸtirilebilmesi iÃ§in java.io.Serializable arayÃ¼zÃ¼nÃ¼ uygulamasÄ± gerekir. Bu, sadece bir iÅŸaretleme arayÃ¼zÃ¼dÃ¼r (marker interface), herhangi bir metot iÃ§ermez.</p><pre>public class Employee implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private String name;<br> private int age;</pre><pre> // constructor, getters and setters<br>}</pre><blockquote><em>âš ï¸ </em><em>Serializable uygulamak, sÄ±nÄ±fÄ±nÄ±zÄ±n otomatik olarak gÃ¼venli ya da optimize edilmiÅŸ bir serileÅŸtirme sÃ¼recinden geÃ§eceÄŸi anlamÄ±na gelmez. Dikkatli kullanÄ±m ÅŸarttÄ±r.</em></blockquote><h3>âœ… SerileÅŸtirme Ne Zaman KullanÄ±lÄ±r?</h3><h3>1. KalÄ±cÄ±lÄ±k (Persistence):</h3><p>Nesneleri dosyalarda veya veritabanlarÄ±nda saklamak iÃ§in kullanÄ±lÄ±r.</p><h3>2. Ä°letiÅŸim (Communication):</h3><p>AÄŸ Ã¼zerinden nesnelerin gÃ¶nderilmesi gerektiÄŸinde (Ã¶rneÄŸin RMIâ€Šâ€”â€ŠRemote Method Invocation) serileÅŸtirme devreye girer.</p><h3>3. Ã–nbellekleme (Caching):</h3><p>GeÃ§ici olarak nesnelerin bellekte saklanmasÄ± ve daha sonra hÄ±zlÄ±ca eriÅŸilmesi iÃ§in kullanÄ±lÄ±r.</p><h3>ğŸ§  Java SerileÅŸtirme Ä°Ã§in En Ä°yi Uygulamalar</h3><h3>1. GerektiÄŸi Zaman KullanÄ±n</h3><p>Her sÄ±nÄ±fÄ±n serileÅŸtirilebilir olmasÄ± gerekmez. Sadece gerÃ§ekten ihtiyaÃ§ duyduÄŸunuz sÄ±nÄ±flara Serializable uygulayÄ±n. Gereksiz serileÅŸtirme, gÃ¼venlik aÃ§Ä±klarÄ±na ve performans kayÄ±plarÄ±na yol aÃ§abilir.</p><pre>public class Employee implements Serializable { ... }</pre><h3>2. SaklanmasÄ± Gereken AlanlarÄ± transient ile Gizleyin</h3><p>BazÄ± alanlar serileÅŸtirilmemelidir. Ã–rneÄŸin ÅŸifre, API anahtarÄ± gibi hassas bilgileri transient anahtar kelimesiyle iÅŸaretleyin.</p><pre>public class User implements Serializable {<br> private String username;<br> private transient String password; // Åifre serileÅŸtirilmez<br>}</pre><h3>3. serialVersionUID TanÄ±mlayÄ±n</h3><p>Her serileÅŸtirilebilir sÄ±nÄ±f iÃ§in private static final long serialVersionUID = 1L; tanÄ±mlanmalÄ±dÄ±r. Bu, sÄ±nÄ±fÄ±n sÃ¼rÃ¼m numarasÄ±nÄ± temsil eder ve farklÄ± sÃ¼rÃ¼mler arasÄ±nda uyumluluÄŸu saÄŸlar.</p><blockquote><em>EÄŸer </em><em>serialVersionUID tanÄ±mlanmazsa, JVM otomatik olarak Ã¼retir ama bu, kÃ¼Ã§Ã¼k deÄŸiÅŸikliklerde bile </em><em>InvalidClassException hatasÄ±na neden olabilir.</em></blockquote><h3>4. Ã–zel SerileÅŸtirme MantÄ±ÄŸÄ± Ekleyin (Ä°steÄŸe BaÄŸlÄ±)</h3><p>EÄŸer varsayÄ±lan serileÅŸtirme yeterli deÄŸilse, writeObject() ve readObject() metodlarÄ±nÄ± override ederek Ã¶zel mantÄ±k ekleyebilirsiniz.</p><pre>private void writeObject(ObjectOutputStream oos) throws IOException {<br> oos.defaultWriteObject();<br> // Ã–zel serileÅŸtirme iÅŸlemleri burada yapÄ±labilir<br>}</pre><pre>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<br> ois.defaultReadObject();<br> // Ã–zel deserileÅŸtirme iÅŸlemleri burada yapÄ±labilir<br>}</pre><h3>5. Hassas Verilerin SerileÅŸtirilmesinden KaÃ§Ä±nÄ±n</h3><p>Åifre, kimlik bilgileri, kredi kartÄ± bilgileri gibi veriler asla serileÅŸtirilmemelidir. Bunu Ã¶nlemek iÃ§in yukarÄ±da bahsedilen transient kullanÄ±mÄ± oldukÃ§a Ã¶nemlidir.</p><h3>6. SerileÅŸtirme Proxyâ€™leri KullanÄ±n (GeliÅŸmiÅŸ Seviye)</h3><p>Daha fazla kontrol ve gÃ¼venlik istiyorsanÄ±z, serileÅŸtirme proxy desenini kullanabilirsiniz. Bu yÃ¶ntem, sÄ±nÄ±fÄ±n doÄŸrudan serileÅŸtirilmesini engeller ve Ã¶zel bir yapÄ±yla koruma saÄŸlar.</p><pre>private Object writeReplace() {<br> return new SerializationProxy(this);<br>}</pre><pre>private static class SerializationProxy implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private final String username;</pre><pre> SerializationProxy(User user) {<br> this.username = user.username;<br> }</pre><pre> private Object readResolve() {<br> return new User(username);<br> }<br>}</pre><p>Bu yaklaÅŸÄ±m, nesne oluÅŸturma sÃ¼recini kontrol altÄ±na alÄ±r ve gÃ¼venlik aÃ§Ä±klarÄ±nÄ± azaltÄ±r.</p><h3>7. Alternatif SerileÅŸtirme KÃ¼tÃ¼phaneleri KullanÄ±n</h3><p>Javaâ€™nÄ±n yerel serileÅŸtirme mekanizmasÄ±, her zaman en verimli Ã§Ã¶zÃ¼m olmayabilir. Ã–zellikle bÃ¼yÃ¼k sistemlerde, yÃ¼ksek performans gerektiren senaryolarda ÅŸu alternatifler dÃ¼ÅŸÃ¼nÃ¼lebilir:</p><ul><li><strong>Google Protocol Buffers (protobuf)</strong></li><li><strong>Apache Avro</strong></li><li><strong>Jackson (JSON formatÄ±nda serileÅŸtirme)</strong></li><li><strong>Kryo (hÄ±zlÄ±, kompakt serileÅŸtirme)</strong></li><li><strong>MessagePack</strong></li></ul><p>Bu kÃ¼tÃ¼phaneler genellikle daha az yer kaplar, daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r ve platformlar arasÄ± uyumluluk saÄŸlar.</p><h3>ğŸ§ª Basit Bir SerileÅŸtirme &amp; DeserileÅŸtirme Ã–rneÄŸi</h3><h3>1. Nesneyi SerileÅŸtirme</h3><pre>Employee emp = new Employee(&quot;John Doe&quot;, 30);</pre><pre>try (FileOutputStream fileOut = new FileOutputStream(&quot;employee.ser&quot;);<br> ObjectOutputStream out = new ObjectOutputStream(fileOut)) {<br> out.writeObject(emp);<br>} catch (IOException e) {<br> e.printStackTrace();<br>}</pre><h3>2. Nesneyi DeserileÅŸtirme</h3><pre>Employee emp = null;</pre><pre>try (FileInputStream fileIn = new FileInputStream(&quot;employee.ser&quot;);<br> ObjectInputStream in = new ObjectInputStream(fileIn)) {<br> emp = (Employee) in.readObject();<br>} catch (IOException | ClassNotFoundException e) {<br> e.printStackTrace();<br>}</pre><pre>System.out.println(&quot;Name: &quot; + emp.getName() + &quot;, Age: &quot; + emp.getAge());</pre><h3>ğŸ¯ SonuÃ§ Olarak</h3><p>Javaâ€™nÄ±n serileÅŸtirme mekanizmasÄ± gÃ¼Ã§lÃ¼dÃ¼r ama doÄŸru ve dikkatli kullanÄ±lmasÄ± gereken bir Ã¶zelliktir. YukarÄ±daki en iyi uygulamalara uyarak:</p><ul><li>PerformansÄ± artÄ±rabilir,</li><li>GÃ¼venliÄŸi gÃ¼Ã§lendirebilir,</li><li>SÃ¼rÃ¼m uyumsuzluklarÄ±ndan kaÃ§Ä±nabilir,</li><li>Uygun yerlerde alternatif Ã§Ã¶zÃ¼mler tercih ederek sisteminizi optimize edebilirsiniz.</li></ul><p>UnutmayÄ±n: Her nesne serileÅŸtirilmeye mÃ¼sait deÄŸildir. Dikkatli planlama yapmak, hem kod kalitenizi hem de sisteminizin gÃ¼venliÄŸini artÄ±racaktÄ±r.</p><h3>ğŸ“˜ Ekstra Kaynaklar</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html">Oracle Java Documentationâ€Šâ€”â€ŠSerialization</a></li><li><a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Effective Java by Joshua Blochâ€Šâ€”â€ŠItem 74â€“78 on Serialization</a></li><li><a href="https://www.baeldung.com/java-serialization">Baeldungâ€Šâ€”â€ŠJava Serialization Guide</a></li></ul><p>EÄŸer bu yazÄ± faydalÄ± geldiyse ğŸ‘ beÄŸenmeyi unutmayÄ±n ve arkadaÅŸlarÄ±nÄ±zla paylaÅŸÄ±n! SorularÄ±nÄ±zÄ± veya deneyimlerinizi yorumlarda paylaÅŸmaktan Ã§ekinmeyin. ğŸ˜Š</p><blockquote><strong>Mert Pehlivanâ€Šâ€”â€ŠJava Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>ğŸŒ Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>ğŸ’¼ LinkedIn</strong></a><strong> | ğŸ“§ </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>ğŸ–¥ï¸ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fd05ec48a4a" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
</channel>
</rss>