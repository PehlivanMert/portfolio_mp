<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html" version="2.0" class="hidden">
<link type="text/css" id="dark-mode" rel="stylesheet" href=""/>
<style type="text/css" id="dark-mode-сustom-style"/>
<style type="text/css" id="dark-mode-theme-changer-style"/>
<channel>
<title>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</title>
<description>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</description>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
<image>
<url>https://cdn-images-1.medium.com/fit/c/150/150/0*B8-_pQzPr4S4bxYR</url>
<title>Stories by Mert Pehlivan on Medium</title>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
</image>
<generator>Medium</generator>
<lastBuildDate>Wed, 18 Jun 2025 04:43:41 GMT</lastBuildDate>
<atom:link href="https://medium.com/@pehlivanmert/feed" rel="self" type="application/rss+xml"/>
<webMaster>
<![CDATA[ yourfriends@medium.com ]]>
</webMaster>
<atom:link href="http://medium.superfeedr.com" rel="hub"/>
<item>
<title>
<![CDATA[ Java ve Yapay Zeka: Yeni Dönemin Kapıları Aralanıyor mu? ]]>
</title>
<link>https://pehlivanmert.medium.com/java-ve-yapay-zeka-yeni-d%C3%B6nemin-kap%C4%B1lar%C4%B1-aralan%C4%B1yor-mu-facc0a6d77c8?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/facc0a6d77c8</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 18 Jun 2025 01:07:20 GMT</pubDate>
<atom:updated>2025-06-18T01:07:20.305Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qBWnKbUvnfLp74YIbEmkig.png" /></figure><p>Son dönemde Yapay Zeka (YZ) alanındaki hızlı gelişmeler, sektörün gündemini belirliyor. Genellikle Python ile özdeşleştirilen YZ geliştirme süreçleri, Java platformunda da dikkat çekici ilerlemeler kaydediyor. Oracle'ın "Java for AI" sunumu, bu konudaki mevcut ve gelecekteki çalışmaları oldukça detaylı bir şekilde ele alıyor. Bir yazılımcı olarak bu yenilikleri keşfetmek oldukça heyecan vericiydi ve sizinle de paylaşmak istedim.</p><p>Java, yüksek performans ve geliştirici verimliliği gibi temel özellikleriyle bilinen, genel amaçlı bir programlama platformu. Bu güçlü yanlar, YZ'nın özel gereksinimlerini karşılamak üzere titizlikle adapte ediliyor. Sunumda da belirtildiği gibi, platforma eklenen yenilikler sadece YZ odaklı değil, aynı zamanda daha geniş kullanım alanlarına hitap ediyor; bu da Java'nın uzun soluklu başarısının ardındaki temel felsefelerden biri.</p><h3>Java'nın YZ İçin Öne Çıkan Özellikleri</h3><p>Sunumda, YZ geliştirmeleri için kritik kabul edilen dört temel Java platformu özelliği tanıtılıyor:</p><ul><li>Foreign Function and Memory API (Proje Panama): Java dışındaki belleği (off-heap memory) daha verimli kullanmayı ve yerel kütüphanelerle etkileşimi güvenli, hızlı ve üretken bir hale getirmeyi sağlıyor. Özellikle sıfır kopyalama senaryolarında bu özellik kritik öneme sahip.</li><li>Vector API (Proje Panama): Java'da SIMD (Single Instruction, Multiple Data) programlamayı mümkün kılarak CPU'nun etkin kullanımını sağlıyor. YZ ve makine öğrenimi algoritmaları için temel olan sayısal hesaplamaları (örneğin nokta çarpımı) ciddi oranda hızlandırıyor.</li><li>Value Classes and Objects (Proje Valhalla): Yığın içi (on-heap) belleğin optimal kullanımını hedefliyor ve Float16, Bfloat16 gibi YZ'da sıkça kullanılan yeni sayı türlerinin platforma entegrasyonunu kolaylaştıracak.</li><li>Code Reflection (Proje Babylon): GPU'lar (CUDA) veya ONNX gibi farklı programlama modelleriyle etkileşimi mümkün kılıyor. Java kodunun otomatik türevini (auto-differentiation) destekleyerek, platformun bu tür spesifik detayları kütüphanelere devretmesini sağlıyor, bu da geliştiricilere esneklik sunuyor.</li></ul><h3>Mevcut Durum ve Gelecek Potansiyeli</h3><p>YZ model geliştirmenin büyük bir kısmı şu anda Python'da yoğunlaşmış durumda. Ancak sunumda bahsedilen özelliklerin Java'yı YZ ekosisteminde daha rekabetçi bir konuma getirme potansiyeli dikkat çekici. Bu özellikler olmadan da YZ çözümleri geliştirilebilir; ancak sunuma göre, bu yeni araçlar tasarım, geliştirme, sürdürme ve evrim süreçlerini önemli ölçüde kolaylaştırıyor.</p><p>Sunumda, yeni özelliklerin pratik uygulamalarını gösteren çarpıcı örneklere de yer veriliyor:</p><ul><li>Llama Model Çıkarımı: FFM ve Vector API kullanılarak Java'da Llama 2 modelinin performansındaki artış (1.3 tokenden ~15 token/saniyeye) göz dolduruyor.</li><li>Anomali Tespiti (MSET 2): Matris API, FFM API ve Vector API kullanarak Java'da uygulanan bu algoritmanın, CUDA, MATLAB ve Python/NumPy implementasyonlarından daha iyi performans gösterdiği ve halihazırda üretimde kullanıldığı belirtiliyor.</li><li>ONNX Script for Java: Code Reflection ve FFM API kullanarak Java kodundan ONNX makine öğrenimi modelleri oluşturma yeteneği sergileniyor.</li></ul><h3>Kilit Bilgiler ve Daha Fazlası</h3><ul><li>Proje Panama (FFM ve Vector API) Java 22&#39;den itibaren kullanılabilir durumda (FFM API final sürümde, Vector API ise halen geliştirme aşamasında).</li><li>Proje Valhalla ve Proje Babylon ise aktif olarak geliştirilmeye devam eden gelecek vaat eden özellikler.</li><li>Java'nın YZ alanındaki bu yenilikleri, temel olarak bellek kullanımını optimize etmeyi, donanım kullanımını verimli hale getirmeyi, yerel kodlarla etkileşimi güçlendirmeyi ve yeni sayı türlerini desteklemeyi hedefliyor.</li></ul><p>Tüm bu gelişmeler ışığında, Java platformunun YZ, yüksek performanslı hesaplama ve büyük veri alanlarındaki zorlukları ele almak için dinamik bir gelişim içinde olduğunu söyleyebiliriz. Bu özellikler, Java'da performans odaklı YZ çözümleri oluşturma potansiyelini artırıyor.</p><p>Bu konuya daha derinlemesine bakmak isterseniz, ilgili <a href="https://www.youtube.com/watch?v=-XnyJad88Ss&amp;t=2s">Oracle OpenJDK topluluğu sunumunu</a> izlemenizi şiddetle tavsiye ederim. Gerçekten ufuk açıcı bilgiler içeriyor.</p><p>Siz bu gelişmeler hakkında ne düşünüyorsunuz? Java'nın YZ ekosistemindeki yeri gelecekte nasıl şekillenebilir?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=facc0a6d77c8" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Gelecek Kapımızda: Yapay Zekâ Yazılımcıların Sonunu Mu Getirecek, Yoksa Yeni Bir Çağ Mı Başlatacak? ]]>
</title>
<link>https://pehlivanmert.medium.com/gelecek-kap%C4%B1m%C4%B1zda-yapay-zek%C3%A2-yaz%C4%B1l%C4%B1mc%C4%B1lar%C4%B1n-sonunu-mu-getirecek-yoksa-yeni-bir-%C3%A7a%C4%9F-m%C4%B1-ba%C5%9Flatacak-4235efc6f12b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4235efc6f12b</guid>
<category>
<![CDATA[ development ]]>
</category>
<category>
<![CDATA[ ai ]]>
</category>
<category>
<![CDATA[ developer-tools ]]>
</category>
<category>
<![CDATA[ developer ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 04 Jun 2025 16:39:51 GMT</pubDate>
<atom:updated>2025-06-04T16:39:51.283Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j76ggknKxckfMfZssQgy1g.png" /></figure><p>Son yıllarda yapay zekâ (YZ) rüzgarı, yazılım geliştirme dünyasında fırtınalar estiriyor. Kod tamamlama, otomatik hata düzeltme gibi YZ destekli araçlar sayesinde projelerimiz hızla şekilleniyor; Copilot gibi yardımcılar işlerimizi %55&#39;e varan oranlarda hızlandırabiliyor. Birçoğumuz bu devrimi kucaklayarak verimliliğimizin arttığını görüyoruz. Ancak, bir kesim yazılımcı hâlâ endişeli: Ya YZ, işimizi tamamen elimizden alırsa?</p><p>Endişelerin aksine, PwC'nin 2025 YZ İş Barometresi bize umut veriyor: YZ'nin etkilediği pek çok meslekte hem istihdam hem de ücret seviyeleri artış gösteriyor. Peki, yazılımcıların geleceği nasıl şekillenecek? Gelin, bu sorunun kısa ve uzun vadeli etkilerine yakından bakalım.</p><h3>Kısa Vadede Yazılımcılar İçin Fırsatlar ve Zorluklar</h3><h4>Yeni Başlayanlar ve Junior Geliştiriciler: Öğrenme ve Adaptasyon Vakti!</h4><p>Junior yazılımcılar için YZ araçları gerçek bir oyun değiştirici. StackOverflow anketine göre, kod yazmayı öğrenenlerin %82&#39;si YZ araçlarını kullanıyor veya kullanmayı planlıyor. Bilimsel çalışmalar da gösteriyor ki, Copilot gibi araçlar özellikle deneyimsiz geliştiricilere büyük fayda sağlıyor. Rutin kodlama görevlerini hızla halletmelerine olanak tanırken, temel becerilerini pekiştirmelerine yardımcı oluyor.</p><p>Ancak dikkat! YZ'nin ürettiği kodun doğruluğunu ve kalitesini kontrol etme, algoritma mantığını kavrayarak kodu denetleme sorumluluğu hâlâ juniorların omuzlarında. Bu, kısa vadede onlar için muazzam bir öğrenme fırsatı sunarken, aynı zamanda YZ önerilerine temkinli yaklaşmayı öğrenmeleri gerektiği anlamına geliyor.</p><h4>Orta Seviye Geliştiriciler: Verimlilikte Vites Artırma Zamanı!</h4><p>Profesyonel yazılımcıların %70&#39;i kısa vadede YZ araçlarını kullanmaya başlamış veya planlıyor. Orta seviye geliştiriciler, deneyimleri sayesinde YZ'nin kod önerilerini eleştirel bir gözle değerlendirip, sadece tekrarlı işleri hızlandırmak için kullanabilirler. YZ, bu grup için zaman alan ve tekrarlayan işleri otomatikleştirerek, onları daha karmaşık problemlere ve mimari tasarıma odaklanmaya teşvik edecek. Böylece hem verimlilik kazanacaklar hem de üst düzey görevlerle birlikte yönetim becerilerini geliştirme imkanı bulacaklar.</p><h4>Kıdemli (Senior) Geliştiriciler: Stratejik Liderlik Ön Planda!</h4><p>Deneyimli yazılımcılar, genellikle mimari tasarım, ekip yönetimi ve karmaşık problem çözme gibi kritik roller üstlenirler. Copilot ile yapılan deneyler, özellikle 25–44 yaş arası geliştiricilerin YZ araçlarından önemli ölçüde fayda sağladığını gösteriyor. Kısa vadede kıdemli geliştiriciler, tekrarlı kodlama işleriyle uğraşmak yerine, ekiplerine rehberlik etmeye, süreçleri iyileştirmeye ve yeni teknolojileri entegre etmeye odaklanacaklar. YZ onlara zaman kazandırırken, asıl katma değer yaratan karmaşık işlerin sorumluluğu yine kıdemli ekibin üzerinde kalacak.</p><h3>Uzun Vadede Yazılımcılar İçin Büyük Dönüşümler</h3><h4>Yeni Başlayanlar ve Junior Geliştiriciler: Sürekli Öğrenmenin Önemi</h4><p>Uzun vadede, YZ'nin kod üretme yeteneğinin artmasıyla juniorların rollerinde köklü değişiklikler görülebilir. Bir çalışma, 2040&#39;ta makinelerin kendi kodlarının çoğunu yazabileceğini öngörüyor. Ancak endişelenmeyin! Bu senaryoda bile geliştiricilerin tamamen ortadan kalkmayacağı tahmin ediliyor; çünkü insanların özellikle <strong>veri hazırlama, algoritma tasarımı ve sistem entegrasyonu</strong> gibi alanlara odaklanması gerekecek.</p><p>Zaten yazılımcılar olarak sürekli öğrenmeye alışkın bir grubuz; 2015–2022 arasında gerekli becerilerin %30&#39;dan fazla değiştiğini görüyoruz. Türkiye'de de geleceğe yönelik raporlar, çalışanların %59&#39;unun yeniden eğitime ihtiyaç duyacağını vurguluyor. Kısacası, junior geliştiriciler için uzun vadeli yol haritası, YZ ile çalışmayı öğrenmek ve sürekli yeni beceriler kazanmak üzerine kurulu olacak.</p><h4>Orta Seviye Geliştiriciler: Liderliğe ve Yaratıcılığa Doğru!</h4><p>Geçmişteki teknolojik devrimler yeni uzmanlıklar ve iş alanları yaratarak yazılımcı talebini artırdı. Benzer şekilde, yazılım geliştirme dünyası 2030 ve ötesine evrildikçe, kodun bir kısmının YZ'ye devredilmesi beklense de geliştiricilere her zaman ihtiyaç duyulacak. YZ destekli otomasyon rutin işleri üstlenirken, yüksek düzeyde <strong>yaratıcılık ve problem çözme</strong> gerektiren görevler insanlara bırakılacak. Orta düzey geliştiriciler ise uzun vadede <strong>ekip liderliği, proje yönetimi ve yeni nesil uygulamaların geliştirilmesi</strong> gibi rollere kayarak değer katmaya devam edecekler. Yani kodun çoğu otomatikleşse bile, yazılımcıların yönlendirme ve uyarlama rolü sürecek.</p><h4>Kıdemli (Senior) Geliştiriciler: Organizasyonların Rehberleri!</h4><p>Uzun dönemde de kıdemli geliştiriciler <strong>stratejik karar alma, büyük sistemleri tasarlama ve ekipleri yönlendirme</strong> görevlerinde kilit önemde kalacak. Yapay zekâ uygulamaları yaygınlaştıkça, bu yazılımcılar yeni süreçleri uyarlama, proje planlama ve veri temelli karar alma konularında ekiplerine öncülük edecekler. Ayrıca, kurum içi eğitim programları ve hackathonlar düzenleyerek, daha az deneyimli meslektaşlarının YZ araçlarını öğrenmesine katkı sağlayacakları öngörülüyor. Böylece kıdemli geliştiriciler, hızla değişen teknolojik ortamda organizasyonların yol gösterici figürleri olmaya devam edecekler.</p><h3>YZ'nin Diğer Mesleklere Etkisi ve Küresel Trendler</h3><p>Yapay zekâ etkisi sadece yazılımcılarla sınırlı kalmayacak. Dünya Ekonomik Forumu (WEF) 2030 projeksiyonlarına göre, yazılım geliştiriciler ve YZ/ML uzmanları gibi teknoloji odaklı roller en hızlı büyüyen meslek grupları arasında yer alacak. Buna karşılık, kasiyer, sekreter ve veri girişi gibi rutin ofis işleri azalma eğiliminde. WEF ayrıca, 2025–2030 arasında dünya genelinde <strong>170 milyon yeni iş yaratılacağını</strong>, yaklaşık 92 milyon iş kaybı olacağını (net yaklaşık +78 milyon) öngörüyor. Bu veriler, YZ'nin genel istihdama büyük oranda olumlu yansıdığını gösteriyor.</p><p>Özellikle sağlık, eğitim ve yenilenebilir enerji gibi insan merkezli sektörlerde büyüme sürerken; montaj, lojistik ve müşteri hizmetleri gibi otomasyona uygun işler gözden geçirme gerektirecek. Özetle, düşük vasıflı ve tekrarlı işlerde risk yüksek, yüksek teknoloji ve yaratıcı işlerde ise yeni fırsatlar öne çıkıyor.</p><h3>Türkiye ve Avrupa Birliği Perspektifi: Dönüşüm Başlıyor!</h3><p>Türkiye özelinde, Google destekli bir çalışma önümüzdeki 10 yılda YZ'nin ulusal GSYH'ye %5&#39;e yakın katkı sağlayabileceğini ve mevcut iş pozisyonlarının %59&#39;unun YZ'den etkilenebileceğini öngörüyor. Yaklaşık 17 milyon iş YZ ile üretkenlik kazanırken, 13 milyon iş otomasyondan fazla etkilenmeyip sabit kalacak; geriye kalan %4 ise tamamen dönüşüme uğrayacak. Bu tablo, Türkiye'de net bir iş kaybı beklenmediğini gösteriyor. Ancak, YZ'nin işyerlerine entegrasyonunda <strong>şeffaflık, işçi hakları ve yeniden eğitim</strong> öncelikli konular arasında.</p><p>Avrupa Birliği genelinde de benzer bir iyimserlik hakim; ECB anketinde çalışanların %41&#39;i YZ'nin işlerini iyileştireceğini düşünürken, yalnızca %20&#39;si olumsuz etkiler bekliyor. Önemli olan, bu değişime hazırlanmak ve yaşam boyu öğrenme yaklaşımını benimsemek.</p><h3>Geleceğe Nasıl Hazırlanmalıyız?</h3><p>Yapay zekânın gelişimi, yazılım sektörü ve diğer meslek grupları için hem fırsatlar hem de meydan okumalar getiriyor. Mevcut veriler ışığında, genel kanı yeni iş yaratma eğilimlerinin ağır bastığı yönünde; ancak dönüşümden en çok etkilenecek alanlarda <strong>beceri ve yeniden eğitim ihtiyacı</strong> artacak. Bir yazılımcı olarak aşağıdaki çıkarımları öncelikli görüyorum:</p><ul><li><strong>Sürekli Öğrenme:</strong> Yapay zekâ ve makine öğrenimi temellerini, yeni YZ araçlarını öğrenmek şart. Kurslar, sertifikalar ve proje çalışmalarıyla becerimizi güncel tutmalıyız.</li><li><strong>YZ Araçlarına Uyum Sağlama:</strong> Kod tamamlama, veri analizi ve otomasyon araçlarını aktif kullanmak, verimliliğimizi artırır. Deneme atölyeleri veya hackathon'lar düzenleyerek bilgi paylaşabiliriz.</li><li><strong>Esneklik ve İletişim:</strong> İş dünyasında YZ uygulamalarını benimserken işverenlerle yakın işbirliği yapmalı, belirsizliklere karşı şeffaflık talep etmeliyiz. Diyalog kanalları bu süreçte kritik önemde.</li><li><strong>Yeni Uzmanlıklara Yönelim:</strong> Veri bilimi, yapay zekâ mühendisliği ve YZ uygulama geliştirme gibi alanlara yatırım yapmak gelecek için avantaj sağlayacak.</li><li><strong>Değer Oluşturmaya Odaklanma:</strong> Tekrarlı ve kolay otomatikleşebilir işler yerine yaratıcı, problem çözmeye yönelik görevlerde uzmanlaşmak önemli. Mimari tasarım, kullanıcı deneyimi, stratejik planlama gibi insan becerisi gerektiren konularda kendimizi geliştirmeliyiz.</li></ul><p>Sonuç olarak, kısa vadede üretkenlik artışı öne çıkarken uzun vadede iş dünyası dönüştükçe rolleri uyarlamak kaçınılmaz olacak. Yazılım geliştiricileri, YZ çağında yeni araçlara ayak uydurarak katma değer yaratmayı sürdürecekler. Doğru eğitim ve politika adımlarıyla, Türkiye ve AB'de de bu dönüşümün yeni iş fırsatlarına dönüşmesi hedefleniyor. Ancak herkesin bu değişime hazırlanması, <strong>yaşam boyu öğrenme</strong> yaklaşımını benimsemesi şart. Unutmayın, yapay zekâ büyük ihtimalle işleri yok etmeyecek, sadece dönüştürecek; önemli olan bu dönüşümden en kârlı çıkan taraf olmaktır.</p><p><strong>Peki siz bu dönüşümün neresinde yer almayı hedefliyorsunuz?</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4235efc6f12b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot'u Quarkus ile Değiştirdim: Daha Hızlı, Daha Hafif Java Uygulamalarına Geliştirici… ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-bootu-quarkus-ile-de%C4%9Fi%C5%9Ftirdim-daha-h%C4%B1zl%C4%B1-daha-hafif-java-uygulamalar%C4%B1na-geli%C5%9Ftirici-3d7a41a19117?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/3d7a41a19117</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 27 May 2025 21:25:19 GMT</pubDate>
<atom:updated>2025-05-27T21:30:04.497Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jePivlT6_mBMahzWD2TCQQ.png" /></figure><h3>Spring Boot’u Quarkus ile Değiştirdim: Daha Hızlı, Daha Hafif Java Uygulamalarına Geliştirici Yolculuğum 🚀</h3><p><strong>Tanıdık bir dosttan yeni bir yarışmacıya geçiş deneyimimi paylaştığım, içgörülerim ve kod örnekleriyle dolu bir yazı kaleme aldım.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*41fzbNVSA4wcJZiJaDlYLA.png" /></figure><p>Yıllardır <strong>Spring Boot</strong>, Java uygulamaları geliştirmek için vazgeçilmez framework’üm oldu. Sağlam, devasa bir topluluğa ve akla gelebilecek neredeyse her ihtiyacı karşılayan bir ekosisteme sahip. Ancak son zamanlarda, sık sık “Süpersonik Atomaltı Java” olarak lanse edilen <strong>Quarkus</strong> etrafındaki heyecanı duyuyordum. İnanılmaz hızlı açılış süreleri, düşük bellek kullanımı ve GraalVM ile sorunsuz native derleme vaatleri görmezden gelinemeyecek kadar cazipti.</p><p>Bu yüzden bir denemeye karar verdim: Mevcut Spring Boot mikroservislerimden birini seçtim ve Quarkus’a taşıdım. Bu makale benim hikayem — nedenleri, nasılları, zorlukları ve sonuçları. Amacım, benzer bir geçiş yapmayı merak eden junior ve orta seviye geliştirici arkadaşlarıma pratik bir yol haritası sunmak. Quarkus’un gerçekten de söylendiği kadar iyi olup olmadığını ve geliştirme iş akışınız için ne anlama geldiğini keşfedeceğiz.</p><p>Bu yazıda şunları ele alacağız:</p><ul><li>Spring Boot dünyasında neden Quarkus’u düşünmelisiniz?</li><li>Başlangıçtaki Spring Boot uygulamamıza hızlı bir bakış.</li><li>Kod örnekleriyle Quarkus’a adım adım geçiş süreci.</li><li>Proje kurulumu, REST denetleyicileri ve bağımlılık enjeksiyonundaki temel farklar.</li><li>Performans gözlemleri (kavramsal).</li><li>Karşılaşılan zorluklar ve bunların üstesinden gelmek için ipuçları.</li></ul><h3>🤔 Neden Spring Boot’un Konfor Alanından Çıkıp Quarkus’a Yönelmeli?</h3><p>Spring Boot harika, ancak özellikle mikroservislerin, sunucusuz (serverless) yapıların ve konteynerleştirmenin yaygınlaştığı, açılış süresi ve bellek kullanımının kritik olduğu bir dünyada her zaman mükemmel bir seçim olmayabilir. Junior ve orta seviye geliştiriciler, daha fazla uygulama dağıtmaya başladıkça bu zorluklarla sıkça karşılaşırlar.</p><p>Quarkus’ta ilgimi çekenler şunlar oldu:</p><ul><li><strong>Işık Hızında Açılış Süreleri:</strong> Quarkus uygulamaları milisaniyeler içinde başlayabilir. Bu, geliştirme (daha hızlı geri bildirim döngüleri!) ve konteynerleştirilmiş ortamlarda ölçeklendirme için oyunun kurallarını değiştiriyor.</li><li><strong>Azaltılmış Bellek Kullanımı:</strong> Quarkus, inanılmaz derecede bellek verimli olacak şekilde tasarlanmıştır; bu da daha düşük altyapı maliyetleri ve daha yüksek yoğunluklu dağıtımlar anlamına gelir.</li><li><strong>GraalVM ile Native Derleme:</strong> Bu, Java kodunuzu native bir yürütülebilir dosyaya derlemenizi sağlar, bu da daha da hızlı açılış ve daha küçük çalışma zamanı boyutuyla sonuçlanır. Bu bazı karmaşıklıklar getirse de (bunlara değineceğiz), faydaları çok büyük olabilir.</li><li><strong>Geliştirici Mutluluğu (Developer Joy):</strong> Quarkus, canlı kodlama (live coding), birleşik yapılandırma ve popüler Java kütüphaneleri ile standartları için kapsamlı destek gibi özelliklerle harika bir geliştirici deneyimi sunmayı amaçlar. Bu, junior geliştiricilerin yeni sistemleri hızla anlamalarına ve oluşturmalarına yardımcı olur.</li><li><strong>İmperatif ve Reaktif Arasında Köprü:</strong> Quarkus, hem geleneksel imperatif programlamayı (Spring Boot geliştiricilerine tanıdık) hem de reaktif programlama modellerini destekler.</li></ul><p>Quarkus’un arkasındaki temel fikir, çalışma zamanı yerine <strong>derleme zamanında</strong> mümkün olduğunca fazla iş yapmaktır. Bu, bağımlılık enjeksiyonunu, yapılandırma işlemeyi ve framework başlatmayı içerir, bu da daha yalın ve daha hızlı uygulamalara yol açar. Bu yaklaşım, sadece “hızlı çözümler” yerine, temel kavramların sağlam bir şekilde anlaşılmasını teşvik ederek daha derin bir anlayış gerektirir.</p><h3>🏁 Başlangıç Noktamız: Basit Bir Spring Boot REST Servisi</h3><p>İşleri odaklı tutmak için çok basit bir Spring Boot uygulaması hayal edelim. Bir selamlama mesajı döndüren tek bir REST endpoint’i var.</p><p><strong>pom.xml (Spring Boot — Temel Bağımlılıklar):</strong></p><p>Bunun bir GitHub Gist’ten gömüldüğünü veya Medium’un kod bloğu özelliğini kullandığınızı hayal edin.</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;/dependencies&gt;</pre><p><strong>GreetingController.java (Spring Boot):</strong></p><pre>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class GreetingController {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Kodda sabit değerlerden kaçının, sabitler kullanın [cite: 187]<br> @GetMapping(&quot;/hello-spring&quot;)<br> public String greet(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;Dünya&quot;) String name) {<br> return String.format(template, name);<br> }<br>}</pre><p>Bu standart bir Spring Boot kurulumu. Şimdi, Quarkus’ta aynısını nasıl başarabileceğimize bakalım.</p><h3>🛠️ Geçiş: Spring Boot’tan Quarkus’a Adım Adım</h3><p>Geçiş, Quarkus’un kurallarını ve REST, CDI ve yapılandırma gibi yaygın görevleri nasıl ele aldığını anlamayı içerir. Bunu parça parça oluşturacak ve değişikliklerin ardındaki “neden”i açıklayacağız.</p><h4><strong>1. Yeni Bir Quarkus Projesi Oluşturma</strong></h4><p>Quarkus CLI, Maven eklentisi veya <a href="https://code.quarkus.io/">code.quarkus.io</a> adresinden bir Quarkus projesi oluşturabilirsiniz. Bu örnek için Maven pom.xml değişikliklerine odaklanacağız.</p><p><strong>pom.xml (Quarkus — Temel Bağımlılıklar):</strong></p><pre>&lt;dependencyManagement&gt;<br> &lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;<br> &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;<br> &lt;version&gt;&lt;span class=&quot;math-inline&quot;&gt;\{quarkus\.platform\.version\}&lt;/version\&gt;&lt;/31\&gt; &lt;type\&gt;pom&lt;/type\&gt;<br>&lt;scope\&gt;import&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;&lt;/32\&gt;<br>&lt;/dependencyManagement\&gt;<br>&lt;dependencies\&gt;<br>&lt;&lt;34\&gt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive\-jackson&lt;/artifactId\&gt; &lt;/dependency\&gt;&lt;/34\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-arc&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-junit5&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.rest\-assured&lt;/groupId\&gt;<br>&lt;artifactId\&gt;rest\-assured&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;<br>&lt;build\&gt;<br>&lt;plugins\&gt;<br>&lt;&lt;33\&gt;plugin\&gt;<br>&lt;groupId\&gt;io\.quarkus\.platform&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-maven\-plugin&lt;/artifactId\&gt;<br>&lt;version\&gt;&lt;/span&gt;{quarkus.platform.version}&lt;/version&gt;<br> &lt;executions&gt;<br> &lt;execution&gt;<br> &lt;goals&gt;<br> &lt;goal&gt;build&lt;/goal&gt;<br> &lt;goal&gt;generate-code&lt;/goal&gt;<br> &lt;goal&gt;generate-code-tests&lt;/goal&gt;<br> &lt;/goals&gt;<br> &lt;/execution&gt;<br> &lt;/executions&gt;<br> &lt;/plugin&gt;<br> &lt;/plugins&gt;<br>&lt;/build&gt;</pre><ul><li><strong>Temel değişiklikler:</strong> Bağımlılık yönetimi için quarkus-bom&#39;u import ediyoruz.</li><li>Spring Web MVC yerine JAX-RS (Quarkus’un kullandığı Java EE/Jakarta EE’deki REST standardı) için quarkus-resteasy-reactive kullanılır.</li><li>quarkus-arc, Quarkus&#39;un CDI (Contexts and Dependency Injection) üzerine kurulu ArC DI çözümüdür.</li></ul><h4>2. Quarkus’ta REST Endpoint’i Oluşturma</h4><p>Quarkus, REST endpoint’lerini tanımlamak için JAX-RS anotasyonlarını kullanır. Bunlar standart Java EE anotasyonlarıdır, bu nedenle Spring dışında çalıştıysanız tanıdık gelebilirler.</p><p><strong>GreetingResource.java (Quarkus):</strong></p><p>(Not: JAX-RS’te denetleyicilere genellikle “Resource” denir)</p><pre>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus&quot;) // Bu kaynak için temel yol<br>public class GreetingResource {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Sabit kodlanmış dizelerden kaçının, sabitler kullanın [cite: 187]<br> @GET // HTTP GET metodu<br> @Produces(MediaType.TEXT_PLAIN) // Yanıtın içerik türü<br> public String greet(@QueryParam(&quot;name&quot;) String name) { // @RequestParam yerine @QueryParam<br> // name null veya boşsa varsayılan bir değer kullanın<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Dünyası&quot;;<br> return String.format(template, displayName);<br> }<br>}</pre><ul><li>@Path: Bu kaynak için temel URI yolunu tanımlar.</li><li>@GET: Bu metodun HTTP GET isteklerini işlediğini belirtir.</li><li>@Produces(MediaType.TEXT_PLAIN): Yanıt içerik türünü gösterir.</li><li>@QueryParam(&quot;name&quot;): &quot;name&quot; adlı sorgu parametresinin değerini enjekte eder. Bu, Spring&#39;in @RequestParam&#39;ına benzer.</li></ul><p>Bu yapı açıktır ve tek bir sorumluluğa odaklanır, temiz kod ilkelerine uyar.</p><h4>3. Bağımlılık Enjeksiyonu (CDI)</h4><p>Quarkus, CDI implementasyonu olan ArC’yi kullanır. Bunun gibi basit durumlar için hemen çok fazla fark görmeyebilirsiniz, ancak uygulamanız büyüdükçe @ApplicationScoped, @Inject vb. CDI anotasyonlarını kullanacaksınız.</p><p>GreetingResource&#39;umuzun bir servise ihtiyacı olsaydı şöyle görünürdü:</p><p><strong>GreetingService.java (Quarkus):</strong></p><pre>import jakarta.enterprise.context.ApplicationScoped; // CDI anotasyonu<br>@ApplicationScoped // Bu bean, uygulamanın ömrü boyunca yaşayacaktır<br>public class GreetingService {<br> public String getGreetingMessage(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Servisi&quot;;<br> return String.format(&quot;Servisten merhaba, %s!&quot;, displayName);<br> }<br>}</pre><p><strong>GreetingResource.java (Quarkus — enjekte edilmiş servisle):</strong></p><pre>import jakarta.inject.Inject; // Enjeksiyon için CDI anotasyonu<br>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus-service&quot;)<br>public class GreetingResource {<br> @Inject // GreetingService&#39;i enjekte et<br> GreetingService service;<br> @GET<br> @Produces(MediaType.TEXT_PLAIN)<br> public String greet(@QueryParam(&quot;name&quot;) String name) {<br> return service.getGreetingMessage(name);<br> }<br>}</pre><p>Bu, Spring’in @Autowired ve @Service/@Component&#39;ına çok benzer. Servisler ve metotlar için anlamlı isimler kullanmak açıklık için önemlidir.</p><h4>4. Yapılandırma</h4><p>Quarkus’ta yapılandırma, Spring Boot’ta olduğu gibi src/main/resources içindeki application.properties aracılığıyla yapılır.</p><p>Örnek src/main/resources/application.properties:</p><pre>quarkus.application.name=my-quarkus-app<br>quarkus.application.version=1.0.0<br># HTTP portunu değiştirmek için (varsayılan 8080&#39;dir)<br>quarkus.http.port=8081<br># Özel özellikler<br>greeting.message.prefix=Aloha</pre><p>Bu özellikleri @ConfigProperty kullanarak enjekte edebilirsiniz:</p><pre>import org.eclipse.microprofile.config.inject.ConfigProperty;<br>import jakarta.enterprise.context.ApplicationScoped;<br>@ApplicationScoped<br>public class ConfigurableGreetingService {<br> @ConfigProperty(name = &quot;greeting.message.prefix&quot;, defaultValue = &quot;Merhaba&quot;)<br> String prefix;<br> public String greetWithConfig(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Config Dünyası&quot;;<br> return String.format(&quot;%s, %s!&quot;, prefix, displayName);<br> }<br>}</pre><p>Bu isimler birden fazla yerde kullanılıyorsa, özellik adları için isimlendirilmiş sabitler kullanmak iyi bir uygulamadır.</p><h4>5. Geliştirme Modunda Çalıştırma</h4><p>Quarkus’un en havalı özelliklerinden biri geliştirme modudur:</p><pre>./mvnw quarkus:dev</pre><p>Veya Gradle kullanıyorsanız:</p><pre>./gradlew quarkusDev</pre><p>Bu, uygulamayı başlatır ve kodunuzda yaptığınız herhangi bir değişiklik neredeyse anında otomatik olarak yeniden yüklenir. Bu, geliştirme döngüsünü önemli ölçüde hızlandırır.</p><h4>6. Üretim için Derleme</h4><p>Standart bir JAR oluşturabilirsiniz:</p><pre>./mvnw package</pre><p>Bu, target/quarkus-app/ dizininde çalıştırılabilir bir JAR oluşturur.</p><p><strong>Native yürütülebilir dosya</strong> oluşturmak için (GraalVM’in kurulu ve yapılandırılmış olmasını gerektirir):</p><pre>./mvnw package -Pnative</pre><p>Bu, target/ dizininde native bir yürütülebilir dosya üretecektir. Bu dosya kendi kendine yeterlidir ve inanılmaz hızlı başlar. Native yürütülebilir dosyalar oluşturma süreci, özellikle bazı kütüphaneler için yansıma (reflection) ihtiyaçlarını anlamak açısından kendi başına bir öğrenme eğrisi olabilir.</p><h3>📊 Performans:</h3><h4><em>Kavramsal Grafik 1: Başlangıç Süresi</em></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zaD-sBfXUd3f-iFYMjXvLQ.png" /></figure><h4><strong>Kavramsal Grafik 2: Bellek Kullanımı (Yerleşik Küme Boyutu — RSS)</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sVt2Wf45BvPtgeeijhH8Eg.png" /></figure><h3>⚠️ Zorluklar ve Öğrenimler</h3><p>Geçiş genellikle olumluydu, ancak öğrenmek bazen zorlayıcı oldu.</p><ul><li><strong>Farklı Ekosistem ve API’ler:</strong> Birçok kavram benzer olsa da, belirli API’ler ve kütüphaneler (örneğin, REST için JAX-RS, yapılandırma için MicroProfile Config) Spring’inkinden farklıdır. Bu, bazı şeyleri unutmayı ve yeniden öğrenmeyi gerektirir. Bu, yeni kod tabanları veya framework’lerle karşılaşan junior geliştiriciler için yaygın bir engeldir.</li><li><strong>Native Derleme İncelikleri:</strong> Uygulamanız çok fazla yansıma (reflection) veya dinamik sınıf yükleme kullanıyorsa native yürütülebilir dosyalar oluşturmak bazen zor olabilir, çünkü GraalVM’in derleme zamanında bunları bilmesi gerekir. Quarkus çok yardımcı olur, ancak zaman zaman ipuçları vermeniz gerekebilir. Bu, sadece yüzeysel kodlamanın ötesinde daha derin bir anlayışa duyulan ihtiyacı pekiştirir.</li><li><strong>Daha Küçük (ama Büyüyen) Topluluk:</strong> Quarkus’un topluluğu aktif ve hızla büyüyor olsa da, henüz Spring kadar geniş değil. Bu, çok özel sorunlara çözüm bulmanın bazen biraz daha fazla araştırma gerektirebileceği anlamına gelir.</li><li><strong>“Derleme Zamanında” Düşünmek:</strong> Daha fazlasını derleme zamanında yapmaya geçiş güçlüdür ancak hafif bir zihinsel uyum gerektirir. Spring’de çalışma zamanında “sadece çalışan” bazı şeyler, Quarkus’ta derleme zamanı dostu olmak için açık yapılandırma veya eklentiler gerektirebilir.</li></ul><p>Bu karmaşık fikirleri basitleştirmek ve bunları, temel bilgilerini hala geliştirmekte olan geliştiriciler için sindirilebilir parçalara ayırmak çok önemlidir. Burada analojiler yardımcı olabilir; örneğin, Quarkus’un derleme zamanı işlemesini, bir şefin pişirmeden önce tüm malzemeleri hazırlaması (mise en place) gibi düşünmek, Spring Boot’un ise daha fazla hazırlığı gerçek pişirme işlemi sırasında yapmasına karşılık gelir.</p><h3>✅ Karar: Spring Boot vs. Quarkus — Benim Çıkarımım</h3><p>Peki, Spring Boot’u Quarkus ile değiştirmek buna değer miydi? <strong>Bu özel mikroservis için kesinlikle evet.</strong></p><p>Başlangıç süresi ve bellek azaltımındaki performans kazanımları, JVM modunda bile önemliydi. Canlı yeniden yükleme ile geliştirici deneyimi harika. Quarkus modern, yalın ve bulut tabanlı uygulamalar için mükemmel bir şekilde uygun hissettiriyor.</p><p><strong>Quarkus’u ne zaman düşünmelisiniz:</strong></p><ul><li>Yeni mikroservisler veya sunucusuz işlevler oluştururken.</li><li>Düşük bellek ayak izi ve hızlı başlangıç kritik olduğunda.</li><li>GraalVM native derlemesinden yararlanmakla ilgileniyorsanız.</li><li>Kaynak verimliliğinin maliyet tasarrufuna dönüştüğü uygulamalar için.</li></ul><p><strong>Spring Boot ne zaman hala daha iyi bir seçim olabilir:</strong></p><ul><li>Tam bir yeniden yazımın mümkün olmadığı büyük, mevcut monolitik uygulamalar.</li><li>Henüz doğrudan Quarkus eşdeğerleri olmayan belirli Spring’e özgü kütüphanelere veya modüllere büyük ölçüde bağımlı projeler.</li><li>Mevcut derin Spring uzmanlığının, acil proje hedefleri için yeni bir framework’ün öğrenme eğrisinden daha ağır bastığı ekipler.</li></ul><p>Bu geçiş, geliştiriciler olarak sürekli olarak yeni araçları ve paradigmaları keşfetmemiz gerektiği fikrini pekiştiren değerli bir öğrenme deneyimi oldu. Mesele “X her zaman Y’den iyidir” değil, ödünleşimleri anlamak ve iş için doğru aracı seçmektir. Bu yolculuk aynı zamanda, özellikle yapay zeka gibi araçların derinlemesine anlamadan hızlı çözümler sunabileceği bir dönemde, sadece framework sihrine güvenmek yerine temel Java kavramlarını anlamanın önemini de vurguladı.</p><h3>🚀 Sıra Sizde! Sonraki Adımlar ve Daha Fazla Keşif</h3><p>Quarkus ilginizi çektiyse, başlamanıza yardımcı olacak bazı kaynaklar şunlardır:</p><ul><li><strong>Quarkus Kılavuzları:</strong> <a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a> — Resmi belgeler mükemmeldir ve neredeyse her şey için adım adım kılavuzlar sunar.</li><li><strong>Quarkus YouTube Kanalı:</strong> Harika eğitimler ve konuşmalar sunar.</li><li>Daha büyük projelere girişmeden önce framework’e alışmak için küçük bir <strong>“oyuncak uygulama”</strong> oluşturmayı deneyin.</li></ul><h4>💬 Sizin Düşünceleriniz Neler?</h4><p>Deneyimlerinizi duymak isterim!</p><ul><li>Quarkus’u denediniz mi? İzleniminiz neydi?</li><li>Spring Boot’tan veya başka bir framework’ten geçmeyi düşünüyor musunuz?</li><li>Öngördüğünüz en büyük zorluklar veya faydalar nelerdir?</li></ul><p>Yorumlarınızı aşağıya bırakın! Birlikte öğrenelim. Ve bu makaleyi faydalı bulduysanız, alkışlamayı unutmayın 👏! Etkileşiminiz, Medium algoritmasına bu içeriğin değerli olduğu sinyalini vermeye yardımcı olur.</p><p>Java, Quarkus, Spring Boot, Mikroservisler, Yazılım Geliştirme, Programlama</p><p><em>(Sorumluluk Reddi: Performans rakamları kavramsal olup açıklama amaçlıdır. Gerçek sonuçlar uygulamaya, iş yüküne ve ortama göre değişiklik gösterecektir.)</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d7a41a19117" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile E-posta Gönderimi ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-e-posta-g%C3%B6nderimi-d6715e02cefa?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/d6715e02cefa</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 06:12:35 GMT</pubDate>
<atom:updated>2025-05-09T06:12:35.054Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/737/1*JB9KkS2Ay2msUHwKXxCljw.png" /></figure><p>Günümüz uygulamalarının vazgeçilmez bir parçası olan e-posta iletişimi, kullanıcı kaydından bildirimlere, şifre sıfırlamadan pazarlama kampanyalarına kadar geniş bir yelpazede kullanılıyor. Spring Boot, spring-boot-starter-mail paketi ile bu süreci oldukça basitleştiriyor. Ancak, sadece basit bir metin e-postası göndermenin ötesine geçmek, HTML içerikler, ekler, şablonlar kullanmak ve asenkron gönderim gibi konular, uygulamanızın profesyonelliğini ve kullanıcı deneyimini doğrudan etkiler.</p><p>Bu kapsamlı rehberde, Spring Boot ile e-posta göndermenin temellerinden başlayarak, daha karmaşık senaryolara ve en iyi uygulamalara kadar derinlemesine bir yolculuğa çıkacağız. Amacımız, sadece e-posta göndermenizi sağlamak değil, aynı zamanda bu konuda ufkunuzu açarak daha sağlam ve esnek çözümler üretebilmenize yardımcı olmak.</p><p><strong>Makale İçeriği:</strong></p><p><strong>Temel Kurulum ve Bağımlılıklar</strong></p><p><strong>application.properties ile Yapılandırma: Sırları ve İncelikleri</strong></p><ul><li>Gmail ile Hızlı Başlangıç (Uygulama Şifresi Oluşturma)</li><li>Diğer SMTP Sağlayıcıları İçin Genel Ayarlar</li></ul><p><strong>JavaMailSender Arayüzü ve Spring Boot Auto-Configuration Sihri</strong></p><p><strong>İlk E-postamız: </strong><strong>SimpleMailMessage ile Basit Metin Gönderimi</strong></p><p><strong>Ufukları Genişletelim: </strong><strong>MimeMessage ile Gelişmiş E-posta İşlevleri</strong></p><ul><li>HTML İçerikli E-postalar Gönderme</li><li>Dosya Eki (Attachment) Ekleme</li><li>Satır İçi Görseller (Inline Images) Kullanma</li></ul><p><strong>E-posta Şablonları ile Dinamik İçerikler: Thymeleaf Entegrasyonu</strong></p><p><strong>Asenkron E-posta Gönderimi: Performansı Artırma (</strong><strong>@Async)</strong></p><p><strong>Yapılandırma ve Güvenlik İpuçları</strong></p><ul><li>Hassas Bilgilerin (Şifreler) Güvenli Yönetimi</li><li>Birden Fazla JavaMailSender Yapılandırması</li></ul><p><strong>Test Stratejileri: E-postaları Gerçekten Göndermeden Test Etme</strong></p><p><strong>En İyi Uygulamalar ve Ek Hususlar</strong></p><ul><li>Hata Yönetimi ve Yeniden Deneme Mekanizmaları</li><li>Uluslararasılaştırma (i18n)</li><li>Profesyonel E-posta Servisleri (SendGrid, Mailgun vb.) Ne Zaman Düşünülmeli?</li></ul><p><strong>Sonuç</strong></p><p>Hazırsanız, Spring Boot ile e-posta göndermenin derinliklerine dalalım!</p><h3>1. Temel Kurulum ve Bağımlılıklar</h3><p>Her Spring Boot projesinde olduğu gibi, işe pom.xml (Maven kullanıyorsanız) veya build.gradle (Gradle kullanıyorsanız) dosyamıza gerekli bağımlılığı ekleyerek başlıyoruz.</p><p><strong>Maven (</strong><strong>pom.xml):</strong></p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Bu “starter” paket, JavaMail API’sini ve Spring Framework’ün e-posta gönderimi için sunduğu soyutlama katmanlarını projenize dahil eder.</p><h3>2. application.properties ile Yapılandırma: Sırları ve İncelikleri</h3><p>Spring Boot, application.properties (veya application.yml) dosyasındaki belirli anahtarları okuyarak JavaMailSender&#39;ı otomatik olarak yapılandırır.</p><p><strong>Gmail ile Hızlı Başlangıç:</strong></p><p>En yaygın kullanılan senaryolardan biri Gmail SMTP sunucusunu kullanmaktır.</p><ul><li><strong>Adım 2.1: Google Hesabınızda Uygulama Şifresi Oluşturma (ÇOK ÖNEMLİ!)</strong> Google, güvenlik nedeniyle standart hesap şifrenizin uygulamalar tarafından doğrudan kullanılmasını kısıtlar. Bu nedenle bir “Uygulama Şifresi” oluşturmanız gerekir.</li></ul><ol><li><a href="https://myaccount.google.com/">Google Hesabınıza</a> gidin.</li><li>Sol menüden “Güvenlik” sekmesine tıklayın.</li><li>“Google’da oturum açma” bölümünde “2 Adımlı Doğrulama”nın <strong>etkin olduğundan emin olun</strong>. Değilse, etkinleştirin.</li><li>2 Adımlı Doğrulama etkinse, aynı bölümde “Uygulama şifreleri” seçeneğini göreceksiniz. (Eğer göremiyorsanız, arama çubuğuna “Uygulama şifreleri” yazın.)</li><li>“Uygulama seçin” altında “Diğer (Özel ad)” seçeneğini seçin, uygulamanıza bir isim verin (örn: “SpringBootMailApp”) ve “OLUŞTUR” butonuna tıklayın.</li><li>Google size 16 karakterlik bir uygulama şifresi verecektir. <strong>Bu şifreyi kopyalayın ve güvenli bir yere not edin.</strong> Bu pencereyi kapattıktan sonra tekrar göremezsiniz.</li></ol><ul><li><strong>Adım 2.2: </strong><strong>application.properties Dosyasını Ayarlama</strong> Aşağıdaki ayarları src/main/resources/application.properties dosyanıza ekleyin:</li></ul><pre>spring.mail.username=youremail@gmail.com # Gmail kullanıcı adınız (e-posta adresiniz) <br>spring.mail.password=BU_ALANA_KOPYALADIGINIZ_UYGULAMA_SIFRESINI_YAPISTIRIN <br># Gmail SMTP Sunucu Ayarları <br>spring.mail.host=smtp.gmail.com <br>spring.mail.port=587 # TLS için önerilen port <br># Ek JavaMail Özellikleri <br>spring.mail.properties.mail.smtp.auth=true <br>spring.mail.properties.mail.smtp.starttls.enable=true <br># TLS&#39;yi etkinleştirir <br>spring.mail.properties.mail.smtp.starttls.required=true <br># TLS zorunlu <br>spring.mail.transport.protocol=smtp <br># Kullanılacak protokol <br># İsteğe Bağlı: Hata ayıklama için loglamayı açar (üretimde kapatın) <br>spring.mail.properties.mail.debug=true</pre><ul><li><strong>Ufuk Açan Not:</strong> spring.mail.properties.* ile başlayan ayarlar, doğrudan JavaMail API&#39;sine geçirilen özelliklerdir. Bu, Spring Boot&#39;un soyutlamasının ötesinde, JavaMail&#39;in tüm gücünü kullanabileceğiniz anlamına gelir. Örneğin, bağlantı zaman aşımı (mail.smtp.connectiontimeout), yazma zaman aşımı (mail.smtp.writetimeout) gibi daha ince ayarları buradan yapabilirsiniz.</li></ul><p><strong>Diğer SMTP Sağlayıcıları İçin Genel Ayarlar:</strong></p><p>Eğer Gmail dışında bir SMTP sunucusu (örneğin, şirketinizin kendi sunucusu veya SendGrid, Mailgun gibi bir servis) kullanacaksanız, host, port, username, password ve properties ayarlarını sağlayıcınızın belgelerine göre düzenlemeniz yeterlidir.</p><h3>3. JavaMailSender Arayüzü ve Spring Boot Auto-Configuration Sihri</h3><p>Spring Boot, yukarıdaki application.properties ayarlarını kullanarak otomatik olarak bir JavaMailSender bean&#39;i oluşturur ve yönetir. Bu sayede, çoğu zaman sizin manuel bir JavaMailSender bean&#39;i tanımlamanıza gerek kalmaz.</p><p>Ancak, kaynakta belirtilen @Configuration sınıfı ile manuel bean tanımı:</p><pre>@Configuration<br>public class MailConfiguration {<br> @Bean<br> public JavaMailSender getJavaMailSender() {<br> JavaMailSenderImpl mailSender = new JavaMailSenderImpl();<br> mailSender.setHost(&quot;smtp.gmail.com&quot;);<br> // ... diğer ayarlar<br> return mailSender;<br> }<br> }</pre><p>Bu yaklaşım, eğer application.properties dosyasında zaten tüm ayarları yaptıysanız <strong>genellikle gereksizdir</strong>. Spring Boot sizin için bunu zaten yapar.</p><p><strong>Peki ne zaman manuel bean tanımına ihtiyaç duyulur?</strong></p><ul><li>Birden fazla, farklı ayarlara sahip JavaMailSender bean&#39;ine ihtiyacınız varsa (örn: biri Gmail, diğeri başka bir SMTP için).</li><li>JavaMailSenderImpl üzerinde application.properties ile ayarlanamayan çok özel programatik yapılandırmalar yapmak istiyorsanız.</li><li>Spring Boot’un otomatik yapılandırmasını devre dışı bırakıp tam kontrol sahibi olmak istiyorsanız (spring.mail.host ayarını boş bırakmak otomatik yapılandırmayı devre dışı bırakabilir).</li></ul><p>Çoğu senaryoda, Spring Boot’un otomatik yapılandırması yeterli ve tercih edilen yoldur.</p><h3>4. İlk E-postamız: SimpleMailMessage ile Basit Metin Gönderimi</h3><p>Şimdi basit bir metin e-postası gönderecek servisi oluşturalım.</p><p><strong>MailSenderService.java:</strong></p><pre>package com.example.demo.mail; // Kendi paket yapınıza göre düzenleyin<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.mail.SimpleMailMessage;<br>import org.springframework.mail.javamail.JavaMailSender;<br>import org.springframework.stereotype.Service;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // Spring Boot, application.properties&#39;teki ayarlara göre<br> // JavaMailSender bean&#39;ini otomatik olarak enjekte edecektir.<br> // @Value(&quot;${spring.mail.username}&quot;) // Gönderici adresini properties&#39;ten almak için<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> public void sendSimpleMail(String to, String subject, String body) {<br> SimpleMailMessage message = new SimpleMailMessage();<br> // message.setFrom(fromEmail); // Gönderici adresi (genellikle properties&#39;te ayarlanır ve otomatik kullanılır)<br> message.setTo(to);<br> message.setSubject(subject);<br> message.setText(body);<br> try {<br> mailSender.send(message);<br> System.out.println(&quot;Mail sent successfully to &quot; + to);<br> } catch (Exception e) {<br> System.err.println(&quot;Error while sending mail to &quot; + to + &quot;: &quot; + e.getMessage());<br> // Burada daha gelişmiş hata yönetimi yapılabilir (logging, retry vb.)<br> }<br> }<br>}</pre><pre><strong>Not:</strong> SimpleMailMessage sınıfı, adından da anlaşılacağı gibi sadece basit metin tabanlı e-postalar için uygundur. HTML, ek dosya veya satır içi görsel desteklemez.</pre><p><strong>E-postayı Tetikleme (Örnek bir Controller veya başka bir Servis):</strong></p><pre>package com.example.demo.controller; // Kendi paket yapınıza göre düzenleyin<br>import com.example.demo.mail.MailSenderService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class MailController {<br> private final MailSenderService mailService;<br> @Autowired<br> public MailController(MailSenderService mailService) {<br> this.mailService = mailService;<br> }<br> @GetMapping(&quot;/send-test-email&quot;)<br> public String sendTestEmail(@RequestParam String to) {<br> mailService.sendSimpleMail(to, &quot;Spring Boot Test E-postası&quot;, &quot;Merhaba,\n\nBu Spring Boot uygulamasından gönderilmiş bir test e-postasıdır.&quot;);<br> return &quot;Test e-postası gönderildi: &quot; + to;<br> }<br>}</pre><p>Uygulamanızı çalıştırıp tarayıcıdan http://localhost:8080/send-test-email?to=alici_email@example.com adresine giderek test edebilirsiniz.</p><h3>5. Ufukları Genişletelim: MimeMessage ile Gelişmiş E-posta İşlevleri</h3><p>Daha zengin içerikli e-postalar için JavaMailSender&#39;ın createMimeMessage() metodunu ve MimeMessageHelper sınıfını kullanırız.</p><p><strong>Gelişmiş </strong><strong>MailSenderService.java:</strong></p><pre>// ... (önceki importlar)<br>import org.springframework.mail.javamail.MimeMessageHelper;<br>import jakarta.mail.MessagingException; // javax.mail yerine jakarta.mail (Spring Boot 3+)<br>import jakarta.mail.internet.MimeMessage;<br>import org.springframework.core.io.FileSystemResource; // Dosya ekleri için<br>import java.io.File;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // @Value(&quot;${spring.mail.username}&quot;)<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> // ... sendSimpleMail metodu ...<br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> // &#39;true&#39; parametresi multipart message oluşturulacağını belirtir.<br> // İkinci &#39;true&#39; ise UTF-8 encoding için.<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(htmlBody, true); // &#39;true&#39; HTML içeriği olduğunu belirtir.<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;HTML mail sent successfully to &quot; + to);<br> }<br> public void sendMailWithAttachment(String to, String subject, String body, String attachmentPath) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); // &#39;true&#39; for multipart message<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(body);<br> FileSystemResource file = new FileSystemResource(new File(attachmentPath));<br> if (file.exists()) {<br> helper.addAttachment(file.getFilename(), file); // İkinci parametre dosya kaynağı<br> System.out.println(&quot;Attachment added: &quot; + file.getFilename());<br> } else {<br> System.err.println(&quot;Attachment file not found: &quot; + attachmentPath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with attachment sent successfully to &quot; + to);<br> }<br> public void sendMailWithInlineImage(String to, String subject, String htmlBody, String imagePath, String imageContentId) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> // HTML içeriğinde &lt;img src=&#39;cid:imageContentId&#39;&gt; şeklinde referans verilir.<br> helper.setText(htmlBody, true);<br> FileSystemResource res = new FileSystemResource(new File(imagePath));<br> if (res.exists()) {<br> // &#39;imageContentId&#39; HTML içindeki cid ile aynı olmalı<br> helper.addInline(imageContentId, res);<br> System.out.println(&quot;Inline image added: &quot; + imageContentId);<br> } else {<br> System.err.println(&quot;Inline image file not found: &quot; + imagePath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with inline image sent successfully to &quot; + to);<br> }<br>}</pre><ul><li><strong>Not (HTML):</strong> helper.setText(htmlBody, true); satırındaki ikinci true parametresi, gönderilen metnin HTML olarak yorumlanmasını sağlar.</li><li><strong>Not (Ek):</strong> MimeMessageHelper(mimeMessage, true) constructor&#39;ındaki true parametresi, mesajın &quot;multipart&quot; olacağını belirtir, bu da ek dosya ve satır içi görseller için gereklidir. addAttachment ile dosya adı ve kaynağını belirtirsiniz.</li><li><strong>Not (Satır İçi Görsel):</strong> addInline metodu kullanılır. HTML içinde &lt;img src=&#39;cid:myImageIdentifier&#39;&gt; şeklinde bir referans verilir ve addInline(&quot;myImageIdentifier&quot;, resource) çağrısıyla bu ID&#39;ye karşılık gelen görsel eklenir. Bu, görselin e-postanın içine gömülmesini sağlar, kırık link sorununu azaltır. E-posta istemcisinin multipart/related içeriği desteklemesi gerekir.</li></ul><h3>6. E-posta Şablonları ile Dinamik İçerikler: Thymeleaf Entegrasyonu</h3><p>Sabit HTML string’leri yerine dinamik içerikler oluşturmak için Thymeleaf gibi bir şablon motoru kullanmak çok daha pratiktir.</p><ul><li><strong>Adım 6.1: Thymeleaf Bağımlılığını Ekleme (</strong><strong>pom.xml)</strong></li></ul><pre>&lt;dependency&gt; <br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; <br>&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; <br>&lt;/dependency&gt;</pre><ul><li><strong>Adım 6.2: E-posta Şablonu Oluşturma (</strong><strong>src/main/resources/templates/email/my-template.html)</strong></li></ul><pre>&lt;!DOCTYPE html&gt; <br>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; <br>&lt;head&gt; <br>&lt;meta charset=&quot;UTF-8&quot;&gt; <br>&lt;title th:text=&quot;${subject}&quot;&gt;E-posta Başlığı&lt;/title&gt; <br>&lt;style&gt; <br>body { font-family: Arial, sans-serif; } <br>.container { padding: 20px; border: 1px solid #ddd; } <br>&lt;/style&gt; <br>&lt;/head&gt; <br>&lt;body&gt; <br>&lt;div class=&quot;container&quot;&gt; <br>&lt;h1 th:text=&quot;${title}&quot;&gt;Merhaba!&lt;/h1&gt; <br>&lt;p&gt;Sevgili &lt;strong th:text=&quot;${name}&quot;&gt;Kullanıcı&lt;/strong&gt;,&lt;/p&gt; <br>&lt;p th:text=&quot;${messageContent}&quot;&gt;Bu dinamik bir e-posta içeriğidir.&lt;/p&gt; &lt;hr&gt; &lt;p&gt;Teşekkürler,&lt;br&gt;Spring Boot Uygulamanız&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</pre><ul><li><strong>Adım 6.3: </strong><strong>MailSenderService&#39;i Güncelleme</strong></li></ul><pre>// ... (önceki importlar) <br>import org.thymeleaf.context.Context; <br>import org.thymeleaf.spring6.SpringTemplateEngine; <br>// Spring Boot 3 için spring6 <br>@Service <br>public class MailSenderService { <br>private final JavaMailSender mailSender; <br>private final SpringTemplateEngine templateEngine; <br>Thymeleaf motorunu enjekte et <br>@Value(&quot;${spring.mail.username}&quot;) <br>private String fromEmail; <br>@Autowired <br>public MailSenderService(JavaMailSender mailSender, SpringTemplateEngine templateEngine) { <br> this.mailSender = mailSender; <br> this.templateEngine = templateEngine; <br>} <br>// ... diğer metotlar ... <br>public void sendMailWithTemplate(String to, String subject, String templateName, Context context) throws MessagingException { <br> MimeMessage mimeMessage = mailSender.createMimeMessage(); <br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;); <br> // Thymeleaf context&#39;inden HTML içeriğini işle <br> String htmlContent = templateEngine.process(&quot;email/&quot; + templateName, context); <br> // &quot;email/&quot; templates altındaki klasör <br> // helper.setFrom(fromEmail); <br> helper.setTo(to); <br> helper.setSubject(subject); <br> helper.setText(htmlContent, true); <br> mailSender.send(mimeMessage); <br> System.out.println(&quot;Templated mail sent successfully to &quot; + to); <br> } <br>}</pre><ul><li><strong>Kullanımı:</strong></li></ul><pre>// Bir controller veya başka bir serviste <br>// Context context = new Context(); <br>// context.setVariable(&quot;subject&quot;, &quot;Thymeleaf ile Merhaba!&quot;); <br>// context.setVariable(&quot;title&quot;, &quot;Hoş Geldiniz!&quot;); <br>// context.setVariable(&quot;name&quot;, &quot;Ahmet Yılmaz&quot;); <br>// context.setVariable(&quot;messageContent&quot;, &quot;Thymeleaf kullanarak dinamik bir e-posta gönderdiniz.&quot;); <br>// mailService.sendMailWithTemplate(&quot;alici@example.com&quot;, &quot;Thymeleaf Test&quot;, &quot;my-template.html&quot;, context);</pre><ul><li><strong>Not:</strong> Context nesnesi, şablona geçirilecek dinamik verileri içerir. templateEngine.process metodu, şablon adını ve context&#39;i alarak sonuç HTML&#39;i üretir. Bu yaklaşım, e-posta içeriği ile sunumunu ayırarak bakımı kolaylaştırır.</li></ul><h3>7. Asenkron E-posta Gönderimi: Performansı Artırma (@Async)</h3><p>E-posta gönderme işlemi, SMTP sunucusunun yanıt verme süresine bağlı olarak zaman alabilir. Kullanıcı etkileşimli bir işlem sırasında (örneğin, kayıt sonrası hoş geldin e-postası) senkron e-posta gönderimi, kullanıcıya yavaş bir deneyim sunabilir. @Async kullanarak e-posta gönderimini arka planda çalışacak ayrı bir thread&#39;e devredebiliriz.</p><ul><li><strong>Adım 7.1: Asenkron Desteği Etkinleştirme</strong> Ana uygulama sınıfınıza veya bir @Configuration sınıfına @EnableAsync ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.EnableAsync; <br>@SpringBootApplication <br>@EnableAsync // Asenkron metodları etkinleştirir <br>public class DemoApplication { <br> public static void main(String[] args) { <br> SpringApplication.run(DemoApplication.class, args); <br> } <br>}</pre><ul><li><strong>Adım 7.2: Servis Metodunu </strong><strong>@Async ile İşaretleme</strong> MailSenderService içindeki e-posta gönderim metotlarınıza @Async ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.Async; <br>// ... @Service <br>public class MailSenderService { <br>// ... @Async <br> // Bu metod asenkron çalışacak <br> public void sendSimpleMail(String to, String subject, String body) { <br> // ... (içerik aynı) } <br> @Async <br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException { <br> // ... (içerik aynı) } <br> // Diğer metotlar için de @Async eklenebilir. <br>}</pre><ul><li><strong>Not:</strong> @Async metodların public olması ve aynı sınıf içinden çağrılmaması gerekir (proxy mekanizması nedeniyle). Eğer aynı sınıf içinden çağırmanız gerekiyorsa, kendinize enjekte ederek (self-injection) çözebilirsiniz veya e-posta gönderimini ayrı bir bean&#39;e taşıyabilirsiniz. Ayrıca, @Async için özel bir TaskExecutor yapılandırarak thread havuzu boyutunu vb. yönetebilirsiniz.</li></ul><pre> // TaskExecutor konfigürasyonu (isteğe bağlı) <br> import org.springframework.context.annotation.Bean; <br> import org.springframework.context.annotation.Configuration; <br> import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; <br> import java.util.concurrent.Executor; <br> <br> @Configuration <br> public class AsyncConfig { <br> @Bean(name = &quot;mailTaskExecutor&quot;) <br> public Executor mailTaskExecutor() { <br> ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); <br> executor.setCorePoolSize(5); <br>// Aynı anda çalışacak min thread <br> executor.setMaxPoolSize(10); <br> Max thread <br> executor.setQueueCapacity(25); <br>// Kuyruk kapasitesi <br><br> executor.setThreadNamePrefix(&quot;MailAsync-&quot;); <br> executor.initialize(); <br> return executor; <br> } <br> } <br> @Async(&quot;mailTaskExecutor&quot;) <br> Belirli bir executor kullanmak için</pre><h3>8. Yapılandırma ve Güvenlik İpuçları</h3><ul><li><strong>Hassas Bilgilerin Güvenli Yönetimi:</strong> spring.mail.password gibi hassas bilgileri doğrudan application.properties dosyasına yazmak ve bunu Git gibi versiyon kontrol sistemlerine göndermek <strong>GÜVENLİK AÇIĞIDIR.</strong></li><li><strong>Çözüm 1: Ortam Değişkenleri (Environment Variables):</strong> application.properties dosyasında: spring.mail.password=${MAIL_APP_PASSWORD} Uygulamanızı çalıştırdığınız ortamda MAIL_APP_PASSWORD adında bir ortam değişkeni tanımlayın.</li><li><strong>Çözüm 2: Spring Cloud Config Server:</strong> Merkezi ve güvenli yapılandırma yönetimi için.</li><li><strong>Çözüm 3: HashiCorp Vault:</strong> Sırların (secrets) güvenli depolanması ve erişimi için.</li><li><strong>Birden Fazla </strong><strong>JavaMailSender Yapılandırması:</strong> Farklı amaçlar için (örn: işlem e-postaları için bir SMTP, pazarlama için başka bir SMTP) farklı JavaMailSender bean&#39;leri tanımlayabilirsiniz. Bu durumda, her bir bean&#39;i @Primary ile varsayılan olarak işaretleyebilir veya @Qualifier ile belirli bir bean&#39;i enjekte edebilirsiniz.</li></ul><pre> @Configuration <br> public class MultipleMailConfig { <br> @Bean <br> @Primary <br> public JavaMailSender primaryMailSender() { <br> /* ... ayarlar ... */ <br> } <br> <br> @Bean <br> @Qualifier(&quot;marketingMailSender&quot;) <br> public JavaMailSender marketingMailSender() { <br> /* ... farklı ayarlar ... */ <br> } <br> } <br> <br> <br>// Kullanım <br> @Autowired <br> @Qualifier(&quot;marketingMailSender&quot;) <br> private JavaMailSender marketingSender;</pre><h3>9. Test Stratejileri: E-postaları Gerçekten Göndermeden Test Etme</h3><p>Entegrasyon testleri sırasında sürekli gerçek e-posta göndermek pratik değildir ve SMTP sunucunuzu gereksiz yere yorabilir.</p><ul><li><strong>Çözüm 1: Wiser (SubEthaSMTP üzerinden Spring Boot Test Desteği):</strong> Spring Boot, testler için gömülü bir SMTP sunucusu başlatmanıza olanak tanır. spring-boot-starter-test ile birlikte gelir. application-test.properties dosyasına (genellikle src/test/resources altında):</li></ul><pre>spring.mail.host=localhost spring.mail.port=2525 # Wiser için varsayılan veya testte ayarlanan port spring.mail.username=testuser spring.mail.password=testpass spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.transport.protocol=smtp</pre><ul><li>Test sınıfınızda:</li></ul><pre> import com.icegreen.greenmail.configuration.GreenMailConfiguration; <br> import com.icegreen.greenmail.junit5.GreenMailExtension; <br> import com.icegreen.greenmail.util.ServerSetupTest; <br> import jakarta.mail.internet.MimeMessage; <br> import org.junit.jupiter.api.Test; <br> import org.junit.jupiter.api.extension.RegisterExtension; <br> import org.springframework.beans.factory.annotation.Autowired; <br> import org.springframework.boot.test.context.SpringBootTest; <br> import static org.assertj.core.api.Assertions.assertThat; <br> <br> @SpringBootTest <br> public class MailServiceIntegrationTest { <br> <br> @RegisterExtension <br>// JUnit 5 için <br> static GreenMailExtension greenMail = new GreenMailExtension(ServerSetupTest.SMTP) <br> .withConfiguration(GreenMailConfiguration.aConfig().withUser(&quot;testuser&quot;, &quot;testpass&quot;)) <br> .withPerMethodLifecycle(false); // Tüm test metotları için tek bir GreenMail instance <br> <br> @Autowired <br> private MailSenderService mailService; <br> <br> @Test <br> void testSendSimpleMail() throws Exception { <br> String to = &quot;recipient@example.com&quot;; <br> String subject = &quot;Test Subject&quot;; <br> String body = &quot;Test Body&quot;; <br> <br> mailService.sendSimpleMail(to, subject, body); <br> <br> MimeMessage[] receivedMessages = greenMail.getReceivedMessages(); <br> assertThat(receivedMessages.length).isEqualTo(1); <br> MimeMessage receivedMessage = receivedMessages[0]; <br> assertThat(receivedMessage.getSubject()).isEqualTo(subject); <br> assertThat(receivedMessage.getAllRecipients()[0].toString()).isEqualTo(to); <br> <br>// İçeriği de kontrol edebilirsiniz. <br> } <br> }</pre><ul><li><em>GreenMail gibi kütüphaneler (Wiser da SubEthaSMTP’yi temel alır) gelen e-postaları yakalayıp içeriğini doğrulamanızı sağlar.</em></li><li><strong>Çözüm 2: Mocking </strong><strong>JavaMailSender:</strong> Birim testlerinde JavaMailSender&#39;ı mocklayarak send() metodunun çağrılıp çağrılmadığını ve doğru parametrelerle çağrıldığını doğrulayabilirsiniz.</li></ul><h3>10. En İyi Uygulamalar ve Ek Hususlar</h3><ul><li><strong>Logging:</strong> E-posta gönderim başarılarını ve hatalarını detaylı loglayın.</li><li><strong>Hata Yönetimi ve Yeniden Deneme:</strong> Geçici SMTP hataları (bağlantı sorunları vb.) için Spring Retry gibi mekanizmalarla yeniden deneme stratejileri uygulayabilirsiniz.</li><li><strong>Uluslararasılaştırma (i18n):</strong> E-posta içeriklerini ve başlıklarını farklı dillerde sunmak için Spring’in i18n desteğini (ResourceBundleMessageSource) Thymeleaf ile birlikte kullanın.</li><li><strong>Abonelikten Çıkma (Unsubscribe) Linkleri:</strong> Özellikle pazarlama e-postaları için yasal bir zorunluluktur ve kullanıcı deneyimi için önemlidir.</li><li><strong>Rate Limiting:</strong> SMTP sunucularının genellikle gönderim limitleri vardır. Toplu e-posta gönderimlerinde bu limitlere dikkat edin.</li><li><strong>Profesyonel E-posta Servisleri (SendGrid, Amazon SES, Mailgun vb.):</strong> Yüksek hacimli e-posta gönderimi, gelişmiş analizler, teslim edilebilirlik (deliverability) takibi, IP itibarı yönetimi gibi ihtiyaçlarınız varsa, bu tür harici servisleri kullanmayı düşünün. Genellikle kendi API’leri ve Spring Boot entegrasyon kütüphaneleri bulunur.</li></ul><h3>11. Sonuç</h3><p>Spring Boot ile e-posta göndermek, spring-boot-starter-mail sayesinde oldukça kolaylaşmıştır. Ancak, bu rehberde gördüğümüz gibi, basit bir metin e-postasından çok daha fazlasını yapabiliriz. HTML içerikler, ekler, şablonlar, asenkron gönderim ve doğru test stratejileri ile uygulamalarınızda profesyonel ve etkili bir e-posta iletişim altyapısı kurabilirsiniz.</p><p>Unutmayın, e-posta gönderimi sadece teknik bir işlem değil, aynı zamanda kullanıcı deneyiminin ve uygulamanızın imajının önemli bir parçasıdır. Bu nedenle, bu süreçlere özen göstermek ve en iyi uygulamaları takip etmek, projenizin başarısına katkı sağlayacaktır.</p><p>Umarım bu kapsamlı rehber, Spring Boot ile e-posta gönderimi konusunda ufkunuzu açmış ve size değerli bilgiler sunmuştur. Yorumlarda sorularınızı ve deneyimlerinizi paylaşmaktan çekinmeyin!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d6715e02cefa" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Reaktif Programlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-reaktif-programlamaya-ad%C4%B1m-ad%C4%B1m-yeni-ba%C5%9Flayanlar-i%CC%87%C3%A7in-kapsaml%C4%B1-bir-rehber-ve-5815c96be738?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/5815c96be738</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 05:03:44 GMT</pubDate>
<atom:updated>2025-05-09T06:15:07.786Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vOd2FBimvVRwHFflS44SNg.png" /></figure><p>Günümüzün yüksek trafikli ve anlık veri akışı gerektiren uygulamalarında performans ve ölçeklenebilirlik hayati önem taşıyor. İşte tam da bu noktada <strong>Reaktif Programlama</strong> devreye giriyor. Spring Boot’un <strong>Spring WebFlux</strong> ile sunduğu mükemmel destek sayesinde, geliştiriciler olarak engellemeyen (non-blocking), olay güdümlü (event-driven) uygulamalar geliştirebiliyoruz.</p><p>Bu yazıda, Spring Boot kullanarak reaktif programlamanın temellerini adım adım keşfedecek, pratik örneklerle pekiştirecek ve bu dünyaya ilk adımını atanlar için önemli ipuçları ve “ince trikler” paylaşacağım. Hadi, başlayalım!</p><h3>1. Reaktif Programlama Nedir? Neden Gerekli?</h3><p>En basit tanımıyla reaktif programlama, <strong>asenkron veri akışları</strong> ve <strong>olay güdümlü mimari</strong> üzerine kurulu bir programlama paradigmasıdır. Geleneksel (imperative) programlamada bir işlem bitmeden diğerine geçemezken (blocking), reaktif yaklaşımda işlemler birbirini beklemez. Bu sayede, özellikle I/O (Input/Output) işlemleri gibi zaman alıcı operasyonlarda kaynaklarımızı çok daha verimli kullanırız.</p><p><strong>Peki, bu ne anlama geliyor?</strong></p><p>Düşünün ki bir restoranda tek bir garson var ve her siparişi alıp, mutfağa iletip, yemek piştikten sonra servis edip, ancak ondan sonra yeni bir sipariş alabiliyor. Bu, geleneksel programlamadaki “blocking” mantığına benzer. Reaktif programlamada ise garson siparişi alır almaz mutfağa iletir ve hemen bir sonraki müşteriden sipariş almaya devam eder. Mutfak yemeği hazırladığında garsona haber verir ve garson da servisi yapar. Bu sayede çok daha fazla müşteriye aynı anda hizmet verilebilir.</p><p><strong>Reaktif Programlamanın Anahtar Kavramları:</strong></p><ul><li><strong>Reactive Streams:</strong> Asenkron veri işlemeyi “backpressure” (geri basınç) ile yönetmek için bir şartnamedir.</li><li><strong>Backpressure</strong>, <em>yayıncının (Publisher) tüketiciyi (Subscriber) veriyle boğmasını engeller. Tüketici, ne kadar veri alabileceğini yayıncıya bildirir. Bu, sistemin çökmesini önleyen kritik bir mekanizmadır.</em></li><li><strong>Publisher (Yayıncı):</strong> Bir veri akışı yayar. (Örn: Veritabanından gelen kullanıcı listesi)</li><li><strong>Subscriber (Abone):</strong> Publisher tarafından yayılan akışı tüketir. (Örn: Kullanıcı listesini alıp işleyen bir servis)</li><li><strong>Subscription (Abonelik):</strong> Publisher ve Subscriber arasındaki etkileşimi yönetir. Subscriber’ın ne kadar veri talep ettiğini ve aboneliği iptal etme gibi işlemleri kontrol eder.</li><li><strong>Processor (İşlemci):</strong> Hem Publisher hem de Subscriber özelliklerini taşır. Veriyi alıp, işleyip, farklı bir formatta tekrar yayınlayabilir.</li></ul><h3>2. Reaktif Spring Boot Projesi Kurulumu: İlk Adımlar</h3><p>Spring Boot ile reaktif programlamaya başlamak için projemize bazı temel bağımlılıkları eklememiz gerekiyor.</p><p><strong>Adım 1: Bağımlılıkları </strong><strong>pom.xml Dosyasına Ekleyelim</strong></p><p>Eğer bir Maven projesi kullanıyorsanız, pom.xml dosyanıza aşağıdaki bağımlılıkları ekleyin:</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br> &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br> &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br> &lt;optional&gt;true&lt;/optional&gt;<br> &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><ul><li><em>spring-boot-starter-webflux bağımlılığı, Netty gibi gömülü reaktif sunucuları ve reaktif HTTP istemcisi olan </em><em>WebClient&#39;ı projenize dahil eder. Geleneksel Spring MVC&#39;deki </em><em>spring-boot-starter-web ile aynı anda kullanılmamalıdır, çünkü farklı iş parçacığı modellerine dayanırlar.</em></li></ul><h3>3. Reaktif Veri Tipleri: Mono ve Flux ile Tanışma</h3><p>Spring WebFlux, Project Reactor kütüphanesini temel alır ve iki ana reaktif veri tipi sunar: Mono ve Flux.</p><ul><li><strong>Mono&lt;T&gt;:</strong> <strong>0 ya da 1</strong> eleman içeren bir akışı temsil eder. Genellikle tek bir nesne döndüreceğiniz (örneğin, ID ile bir kullanıcı getirme) veya bir işlemin tamamlandığını (void) belirten durumlarda kullanılır.</li><li><strong><em>Örnek:</em> </strong>Mono&lt;User&gt; (bir kullanıcı), Mono&lt;Void&gt; (bir işlem tamamlandı).</li><li><strong>Flux&lt;T&gt;:</strong> <strong>0&#39;dan N&#39;e kadar</strong> (yani birden fazla) eleman içeren bir akışı temsil eder. Veri akışları, listeler veya sonsuz akışlar için idealdir.</li><li><strong><em>Örnek:</em> </strong>Flux&lt;Product&gt; (tüm ürünler), Flux&lt;String&gt; (bir olay akışı).</li></ul><p><strong>Mono ve </strong><strong>Flux Örneği:</strong></p><pre>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>public class ReactiveExample {<br> public static void main(String[] args) {<br> // Tek bir değer içeren Mono<br> Mono&lt;String&gt; monoExample = Mono.just(&quot;Merhaba Reaktif Dünya!&quot;)<br> .log(); // Akıştaki olayları görmek için log() ekleyebiliriz.<br> // Mono&#39;ya abone olunduğunda veri işlenir.<br> monoExample.subscribe(<br> data -&gt; System.out.println(&quot;Mono&#39;dan gelen: &quot; + data), // onNext: Veri geldiğinde<br> error -&gt; System.err.println(&quot;Mono&#39;da hata: &quot; + error), // onError: Hata oluştuğunda<br> () -&gt; System.out.println(&quot;Mono tamamlandı!&quot;) // onComplete: Akış bittiğinde<br> );<br> System.out.println(&quot;---&quot;); // Çıktıları ayırmak için<br> // Birden fazla değer içeren Flux<br> Flux&lt;String&gt; fluxExample = Flux.just(&quot;Elma&quot;, &quot;Armut&quot;, &quot;Çilek&quot;, &quot;Muz&quot;)<br> .map(String::toUpperCase) // Her elemanı büyük harfe çevir<br> .log(); // Akıştaki olayları görmek için<br> // Flux&#39;a abone olunduğunda veri akışı başlar.<br> fluxExample.subscribe(<br> data -&gt; System.out.println(&quot;Flux&#39;tan gelen: &quot; + data),<br> error -&gt; System.err.println(&quot;Flux&#39;ta hata: &quot; + error),<br> () -&gt; System.out.println(&quot;Flux tamamlandı!&quot;)<br> );<br> }<br>}</pre><ul><li><em>Mono ve </em><em>Flux &quot;tembel&quot; (lazy) yapıdadır. Yani, onlara </em><em>subscribe() metoduyla abone olunana kadar hiçbir işlem yapmazlar. </em><em>subscribe() çağrısı, veri akışını tetikler. Bu, reaktif programlamaya yeni başlayanların sıkça gözden kaçırdığı bir noktadır. Eğer </em><em>subscribe() yapmazsanız, </em><em>map, </em><em>filter gibi operatörleriniz çalışmayacaktır!</em></li><li><em>.log() operatörü, akışın içindeki olayları (istek, yayınlama, tamamlama, iptal vb.) konsola yazdırmak için geliştirme aşamasında çok faydalıdır.</em></li></ul><h3>4. Reaktif Bir REST API İnşa Edelim: CRUD Örneği</h3><p>Şimdi Spring WebFlux ve Reaktif MongoDB kullanarak basit bir Ürün (Product) yönetimi için CRUD (Create, Read, Update, Delete) API’si oluşturalım.</p><p><strong>Adım 1: Entity Sınıfını Tanımlayalım (</strong><strong>Product.java)</strong></p><p>MongoDB’deki products koleksiyonumuza karşılık gelecek bir model sınıfı oluşturalım.</p><pre>import lombok.Data; // Getter, Setter, toString vb. için<br>import lombok.AllArgsConstructor;<br>import lombok.NoArgsConstructor;<br>import org.springframework.data.annotation.Id;<br>import org.springframework.data.mongodb.core.mapping.Document;<br>@Data // Lombok: Getter, Setter, equals, hashCode, toString metodlarını otomatik oluşturur.<br>@NoArgsConstructor // Lombok: Argümansız constructor oluşturur.<br>@AllArgsConstructor // Lombok: Tüm argümanları içeren constructor oluşturur.<br>@Document(collection = &quot;products&quot;) // Bu sınıfın MongoDB&#39;de &#39;products&#39; adlı bir koleksiyona karşılık geldiğini belirtir.<br>public class Product {<br> @Id // Bu alanın MongoDB&#39;deki _id alanı olduğunu belirtir.<br> private String id;<br> private String name;<br> private double price;<br> // Reaktif programlamada entity&#39;ler genellikle değişmez (immutable) olarak tasarlanır,<br> // ancak bu örnekte basitlik için Lombok @Data kullandık.<br>}</pre><p><strong>Adım 2: Reaktif Repository Oluşturalım (</strong><strong>ProductRepository.java)</strong></p><p>Spring Data, ReactiveMongoRepository arayüzü ile MongoDB için engellemeyen operasyonları destekler.</p><pre>import org.springframework.data.mongodb.repository.ReactiveMongoRepository;<br>import reactor.core.publisher.Flux; <br>import org.springframework.stereotype.Repository;<br>@Repository // Bu arayüzün bir Spring bileşeni (repository) olduğunu belirtir.<br>public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {<br> // ReactiveMongoRepository bize temel CRUD operasyonlarını (findAll, findById, save, deleteById vb.)<br> // Mono ve Flux dönecek şekilde hazır olarak sunar.<br> // İhtiyaç duyarsak özel sorgu metotları da tanımlayabiliriz.<br> // Spring Data, metot isminden sorguyu otomatik türetir.<br> Flux&lt;Product&gt; findByName(String name); // İsme göre ürünleri reaktif olarak getirir.<br>}</pre><ul><li><em>ReactiveMongoRepository&lt;Product, String&gt; ifadesindeki </em><em>Product entity tipini, </em><em>String ise </em><em>@Id ile işaretlediğimiz alanın tipini (yani </em><em>id alanının tipi) temsil eder.</em></li></ul><p><strong>Adım 3: Reaktif Servis Katmanını Oluşturalım (</strong><strong>ProductService.java)</strong></p><p>İş mantığımızı yöneteceğimiz servis sınıfını oluşturalım.</p><pre>import org.springframework.stereotype.Service;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired; // Alternatif olarak constructor injection<br>@Service // Bu sınıfın bir Spring bileşeni (servis) olduğunu belirtir.<br>public class ProductService {<br> private final ProductRepository productRepository;<br> // Bağımlılıkları constructor üzerinden enjekte etmek best practice&#39;dir.<br> @Autowired // Spring 4.3 ve sonrası için constructor injection&#39;da @Autowired zorunlu değil,<br> // eğer sınıfta tek bir constructor varsa.<br> public ProductService(ProductRepository productRepository) {<br> this.productRepository = productRepository;<br> }<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productRepository.findAll();<br> }<br> public Mono&lt;Product&gt; getProductById(String id) {<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Ürün bulunamadı: &quot; + id))); // Ürün yoksa özel hata fırlat<br> }<br> public Mono&lt;Product&gt; createProduct(Product product) {<br> // Gelen ürünün ID&#39;si varsa (güncelleme gibi), bunu engellemek veya farklı yönetmek isteyebilirsiniz.<br> // Bu örnekte basitçe save() çağırıyoruz. MongoDB yeni bir ID atayacaktır eğer null ise.<br> return productRepository.save(product);<br> }<br> public Mono&lt;Product&gt; updateProduct(String id, Product product) {<br> return productRepository.findById(id)<br> .flatMap(existingProduct -&gt; { // flatMap, Mono&lt;Mono&lt;Product&gt;&gt; yerine Mono&lt;Product&gt; dönmek için kullanılır.<br> existingProduct.setName(product.getName());<br> existingProduct.setPrice(product.getPrice());<br> return productRepository.save(existingProduct);<br> })<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Güncellenecek ürün bulunamadı: &quot; + id)));<br> }<br> public Mono&lt;Void&gt; deleteProduct(String id) {<br> // Önce var olup olmadığını kontrol edip sonra silmek daha güvenli olabilir.<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Silinecek ürün bulunamadı: &quot; + id)))<br> .flatMap(productRepository::delete); // product -&gt; productRepository.delete(product) ile aynı.<br> // deleteById de kullanılabilir: productRepository.deleteById(id)<br> }<br>}<br>// Basit bir custom exception sınıfı<br>class ProductNotFoundException extends RuntimeException {<br> public ProductNotFoundException(String message) {<br> super(message);<br> }<br>}</pre><ul><li><em>switchIfEmpty() operatörü, bir </em><em>Mono veya </em><em>Flux boş geldiğinde (yani hiç eleman yayınlamadığında) alternatif bir </em><em>Mono veya </em><em>Flux sağlamak ya. da bir hata fırlatmak için kullanılır. </em><em>getProductById örneğinde, ürün bulunamazsa </em><em>ProductNotFoundException fırlatıyoruz.</em></li><li><em>flatMap() operatörü, bir </em><em>Mono veya </em><em>Flux içindeki elemanı alıp, bu elemanla başka bir asenkron işlem (başka bir </em><em>Mono veya </em><em>Flux döndüren) yapmak istediğinizde kullanılır. Sonucu &quot;düzleştirir&quot;. Eğer </em><em>map() kullansaydık </em><em>Mono&lt;Mono&lt;Product&gt;&gt; gibi bir sonuç alırdık, </em><em>flatMap ise bunu </em><em>Mono&lt;Product&gt;&#39;a çevirir.</em></li></ul><p><strong>Adım 4: Reaktif REST Controller Oluşturalım (</strong><strong>ProductController.java)</strong></p><p>API endpoint’lerimizi dış dünyaya açacağımız controller sınıfını yazalım.</p><pre>import org.springframework.web.bind.annotation.*;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.http.HttpStatus;<br>import org.springframework.http.ResponseEntity; // ResponseEntity ile daha detaylı yanıtlar<br>@RestController // Bu sınıfın bir RESTful controller olduğunu belirtir.<br> // Gelen istekleri işler ve HTTP yanıtları döner.<br>@RequestMapping(&quot;/api/v1/products&quot;) // Bu controller&#39;daki tüm endpoint&#39;ler &quot;/api/v1/products&quot; altında olacak.<br>public class ProductController {<br> private final ProductService productService;<br> @Autowired<br> public ProductController(ProductService productService) {<br> this.productService = productService;<br> }<br> @GetMapping<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productService.getAllProducts();<br> }<br> @GetMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {<br> return productService.getProductById(id)<br> .map(ResponseEntity::ok) // Product -&gt; ResponseEntity.ok(product)<br> .defaultIfEmpty(ResponseEntity.notFound().build()); // Mono boşsa 404 Not Found<br> }<br> @PostMapping<br> @ResponseStatus(HttpStatus.CREATED) // Başarılı POST isteği için 201 Created durumu döner.<br> public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {<br> // @RequestBody: Gelen JSON verisini Product nesnesine mapler.<br> return productService.createProduct(product);<br> }<br> @PutMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(@PathVariable String id, @RequestBody Product product) {<br> return productService.updateProduct(id, product)<br> .map(ResponseEntity::ok)<br> .defaultIfEmpty(ResponseEntity.notFound().build());<br> }<br> @DeleteMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteProduct(@PathVariable String id) {<br> return productService.deleteProduct(id)<br> .map(ResponseEntity.noContent()::build) // Başarılı silme sonrası 204 No Content<br> .onErrorResume(ProductNotFoundException.class, e -&gt; Mono.just(ResponseEntity.notFound().build())); // Ürün yoksa 404<br> }<br> // Hata yönetimi için merkezi bir @ExceptionHandler da eklenebilir.<br> @ExceptionHandler(ProductNotFoundException.class)<br> public ResponseEntity&lt;String&gt; handleProductNotFound(ProductNotFoundException ex) {<br> return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());<br> }<br>}</pre><ul><li><em>Controller metotlarımız artık </em><em>Mono&lt;Product&gt;, </em><em>Flux&lt;Product&gt; veya </em><em>Mono&lt;ResponseEntity&lt;T&gt;&gt; gibi reaktif tipler dönüyor. Spring WebFlux, bu reaktif tiplere abone olup, sonuçlar geldikçe HTTP yanıtını asenkron olarak yazar.</em></li><li><em>@ResponseStatus(HttpStatus.CREATED) gibi anotasyonlarla veya </em><em>ResponseEntity kullanarak HTTP durum kodlarını daha detaylı yönetebilirsiniz. </em><em>defaultIfEmpty ve </em><em>onErrorResume gibi operatörler, controller seviyesinde de hata durumlarını ve boş sonuçları yönetmek için kullanışlıdır.</em></li></ul><h3>5. Reaktif API’mizi Test Edelim</h3><p>API’nizi test etmek için Postman, Insomnia gibi araçları veya cURL komut satırı aracını kullanabilirsiniz. Spring Boot uygulamanız varsayılan olarak 8080 portunda çalışacaktır.</p><p><strong>Yeni Bir Ürün Oluşturma (POST):</strong></p><pre>curl -X POST http://localhost:8080/api/v1/products \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Akıllı Saat&quot;,&quot;price&quot;:2500.75}&#39;</pre><p><strong>Tüm Ürünleri Getirme (GET):</strong></p><pre>curl -X GET http://localhost:8080/api/v1/products</pre><p><em>Bu komut, bir JSON dizisi olarak ürünleri listeler. Eğer </em><em>text/event-stream olarak isterseniz, sunucu tarafında bunu desteklemeniz gerekir ve istemci de buna göre istek yapmalıdır.</em></p><p><strong>ID ile Ürün Getirme (GET):</strong> Önce bir ürün oluşturup ID’sini alın, sonra o ID ile sorgulayın.</p><pre># ID&#39;yi bir önceki POST isteğinin yanıtından veya GET All Products&#39;tan alın<br>curl -X GET http://localhost:8080/api/v1/products/{id}</pre><p><strong>Ürün Güncelleme (PUT):</strong></p><pre>curl -X PUT http://localhost:8080/api/v1/products/{id} \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Yeni Akıllı Saat Model X&quot;,&quot;price&quot;:2750.00}&#39;</pre><p><strong>Ürün Silme (DELETE):</strong></p><pre>curl -X DELETE http://localhost:8080/api/v1/products/{id}</pre><ul><li><em>Spring WebFlux ile </em><em>WebClient kullanarak reaktif API&#39;lerinizi programatik olarak test edebilirsiniz. Bu, özellikle entegrasyon testleri yazarken çok kullanışlıdır.</em></li></ul><pre>// Örnek WebClient kullanımı (test sınıfı içinde)<br>// @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br>// class ProductControllerIntegrationTests {<br>//<br>// @Autowired<br>// private WebTestClient webTestClient;<br>//<br>// @Test<br>// void testGetAllProducts() {<br>// webTestClient.get().uri(&quot;/api/v1/products&quot;)<br>// .exchange() // İsteği gönder ve yanıtı al<br>// .expectStatus().isOk() // HTTP durumunun 200 OK olmasını bekle<br>// .expectHeader().contentType(MediaType.APPLICATION_JSON) // İçerik tipinin JSON olmasını bekle<br>// .expectBodyList(Product.class).hasSize(expectedSize); // Beklenen sayıda ürün olmasını kontrol et<br>// }<br>// }</pre><h3>6. Reaktif Programlamanın Faydaları (Kısaca)</h3><ul><li><strong>Engellemeyen I/O (Non-blocking I/O):</strong> Daha az kaynakla daha fazla isteği işleyebilir. Her istek için ayrı bir thread oluşturmak yerine, az sayıda thread ile (event loop) çok sayıda isteği yönetir.</li><li><strong>Daha İyi Ölçeklenebilirlik:</strong> Özellikle mikroservis mimarilerinde ve gerçek zamanlı uygulamalarda yatay ölçeklenmeyi kolaylaştırır.</li><li><strong>Verimli Kaynak Kullanımı:</strong> Thread’lerin bloke olmasını azaltarak CPU ve bellek kullanımını optimize eder.</li><li><strong>Akış (Streaming) Yetenekleri:</strong> Büyük veri kümelerini veya sonsuz veri akışlarını (örneğin, sensör verileri, sosyal medya akışları) verimli bir şekilde işleyebilir.</li></ul><h3>7. Reaktif Programlama Ne Zaman Kullanılmalı? (Altın Kural!)</h3><p>✅ <strong>Gerçek zamanlı uygulamalar</strong> için idealdir: Sohbet uygulamaları, canlı borsa verileri, IoT (Nesnelerin İnterneti) uygulamaları, bildirim servisleri.</p><p>✅ <strong>Yüksek trafikli (high-throughput)</strong> ve ölçeklenebilirlik gerektiren servisler için çok faydalıdır. Özellikle I/O bağımlı (veritabanı, harici API çağrıları) işlemleri yoğun olan servisler.</p><p>✅ <strong>Veri akışlarının (data streams)</strong> işlenmesi gereken durumlar.</p><p>❌ <strong>Düşük eşzamanlılık (concurrency)</strong> ihtiyacı olan, basit CRUD (Create, Read, Update, Delete) tabanlı geleneksel uygulamalar için <strong>gereksiz karmaşıklık</strong> getirebilir. Eğer uygulamanızın darboğazı I/O değilse veya trafik çok düşükse, reaktif programlamanın faydalarını göremeyebilirsiniz.</p><ul><li><em>Reaktif programlama bir “gümüş kurşun” değildir. Her probleme çözüm sunmaz. Projenizin ihtiyaçlarını iyi analiz edip, reaktif mimarinin getireceği faydaların, öğrenme eğrisi ve potansiyel karmaşıklığa değip değmeyeceğine karar vermelisiniz.</em></li></ul><h3>Yeni Başlayanlar İçin Ekstra İpuçları ve Dikkat Edilmesi Gerekenler</h3><ol><li><strong>Farklı Düşünme Biçimi:</strong> Reaktif programlama, geleneksel imperative programlamadan farklı bir düşünme biçimi gerektirir. Akışları ve olayları düşünmeye alışmak zaman alabilir.</li><li><strong>subscribe() Hayati Önem Taşır:</strong> Unutmayın, Mono ve Flux tembeldir. subscribe() çağrılmadıkça hiçbir şey olmaz.</li><li><strong>Hata Yönetimi:</strong> Reaktif akışlarda hata yönetimi farklıdır. onErrorMap, onErrorResume, onErrorReturn gibi operatörlerle hataları yakalayıp yönetebilirsiniz. Merkezi hata yönetimi için @ControllerAdvice ve ExceptionHandler kullanabilirsiniz.</li><li><strong>Debugging (Hata Ayıklama):</strong> Reaktif akışları debug etmek, geleneksel kodlara göre biraz daha zorlayıcı olabilir. .log(), doOnNext(), doOnError() gibi operatörler ve Reactor&#39;un BlockHound gibi araçları yardımcı olabilir. IDE&#39;nizin reaktif debug yeteneklerini de keşfedin.</li><li><strong>Thread Yönetimi:</strong> Spring WebFlux, varsayılan olarak Netty’nin event loop’larını kullanır. Uzun süren CPU-yoğun işlemleriniz varsa, bunları Schedulers.boundedElastic() gibi farklı bir thread havuzunda çalıştırmayı düşünmelisiniz ki event loop&#39;ları bloke etmeyin.</li><li><strong>Engellemeyen Kütüphaneler:</strong> Reaktif bir sistemde, tüm çağrıların (veritabanı, harici servisler vb.) engellemeyen (non-blocking) olması önemlidir. Eğer reaktif bir akış içinde engelleme yapan bir kütüphane çağrısı yaparsanız, reaktifliğin tüm faydalarını kaybedebilirsiniz. Spring Data Reactive Repositories (MongoDB, R2DBC vs.) ve WebClient bu yüzden önemlidir.</li></ol><h3>Sonuç</h3><p>Bu yazıda, Spring Boot ve WebFlux ile reaktif programlamaya kapsamlı bir giriş yaptık. Temel kavramları, Mono ve Flux&#39;ı, reaktif bir REST API&#39;nin nasıl oluşturulacağını ve test edileceğini adım adım inceledik. Ayrıca, yeni başlayanlar için önemli ipuçları ve dikkat edilmesi gereken noktaları paylaştım.</p><p>Reaktif programlama, modern uygulama geliştirmenin güçlü bir aracıdır, ancak doğru yerde ve doğru şekilde kullanıldığında en iyi sonuçları verir. Eğer uygulamanız asenkron ve engellemeyen bir yapıya gerçekten ihtiyaç duyuyorsa, Spring WebFlux sizin için harika bir seçenektir.</p><p>Umarım bu yazı, reaktif programlama yolculuğunuzda size iyi bir başlangıç noktası sunmuştur. Yorumlarda sorularınızı ve deneyimlerinizi paylaşmaktan çekinmeyin! Mutlu kodlamalar!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5815c96be738" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Apache Kafka Entegrasyonu: Adım Adım Rehber ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-apache-kafka-entegrasyonu-ad%C4%B1m-ad%C4%B1m-rehber-8f2d4416f987?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/8f2d4416f987</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:21:57 GMT</pubDate>
<atom:updated>2025-05-07T22:21:57.509Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*4TWM0sbXF0b8oxc2EPkomg.png" /></figure><p>Apache Kafka, yüksek hacimli veri akışlarını işlemek için kullanılan güçlü bir dağıtık mesajlaşma sistemidir. Spring Boot ise mikroservis mimarilerinde ve modern uygulamalarda hızlı geliştirme için ideal bir framework’tür. Bu yazıda Spring Boot uygulaması ile Apache Kafka’yı nasıl entegre edeceğimizi adım adım öğreneceğiz.</p><h3>🔧 1. Gerekli Araçlar ve Kurulumlar</h3><h3>Kullandığımız Teknolojiler:</h3><ul><li><strong>Java 17+</strong></li><li><strong>Spring Boot 3.x</strong></li><li><strong>Apache Kafka (2.8+)</strong></li><li><strong>Spring Tool Suite (STS) veya IntelliJ IDEA</strong></li><li><strong>Maven (Dependency Management)</strong></li><li><strong>Postman (API Testi)</strong></li></ul><h3>Kafka Kurulumu:</h3><ol><li>Apache Kafka’yı <a href="https://kafka.apache.org/downloads">resmi sitesinden</a> indirin.</li><li>config/server.properties dosyasını açın ve gerekirse listeners ve port ayarlarını düzenleyin (varsayılan port: 9092).</li><li>Kafka’yı başlatın:</li></ol><pre># Zookeeper&#39;ı başlat bin/zookeeper-server-start.sh config/zookeeper.properties <br># Kafka broker&#39;ı başlat bin/kafka-server-start.sh config/server.properties</pre><h3>📦 2. Spring Boot Projesi Oluşturma</h3><p>STS veya IntelliJ üzerinden yeni bir Spring Boot projesi oluşturun. Gerekli bağımlılıklar:</p><pre>&lt;!-- Spring for Apache Kafka --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Web (REST API için) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Boot DevTools (Geliştirme Kolaylığı) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>🔁 3. Ana Sınıf: Kafka Entegrasyonunu Aktif Hale Getirme</h3><p>Ana uygulama sınıfınıza @EnableKafka ekleyerek Kafka desteği aktif edilir:</p><pre>@SpringBootApplication<br>@EnableKafka<br>public class SpringBootKafkaApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(SpringBootKafkaApplication.class, args);<br> }<br>}</pre><h3>🗄️ 4. Mesajları Saklamak İçin Repository Oluşturma</h3><p>Basit bir MessageRepository, alınan Kafka mesajlarını geçici olarak saklamak için kullanılır.</p><pre>@Component<br>public class MessageRepository {<br> private List&lt;String&gt; messages = new ArrayList&lt;&gt;();<br>public void addMessage(String message) {<br> messages.add(message);<br> }<br> public String getAllMessages() {<br> return messages.toString();<br> }<br>}</pre><blockquote><em>💡 Bu repository, sadece demo amaçlıdır. Gerçek senaryolarda Redis, MongoDB gibi veri tabanları kullanılabilir.</em></blockquote><h3>🚚 5. Mesaj Üretici (Producer): Kafka’ya Veri Gönderimi</h3><p>MessageProducer, Kafka topic’ine mesaj göndermek için kullanılır:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageProducer {<br><br> private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br><br> @Value(&quot;${myapp.kafka.topic}&quot;)<br> private String topic;<br><br> public void sendMessage(String message) {<br> log.info(&quot;MESAJ ÜRETİCİDEN GÖNDERİLİYOR -&gt; {}&quot;, message);<br> kafkaTemplate.send(topic, message);<br> }<br>}</pre><h3>KafkaTemplate Nedir?</h3><ul><li>Kafka ile etkileşim kurmak için kullanılan Spring’in yüksek seviye API’sidir.</li><li>KafkaTemplate sayesinde mesaj gönderimi (send) kolaylaştırılır.</li></ul><h3>📥 6. Mesaj Tüketici (Consumer): Kafka’dan Veri Alma</h3><p>@KafkaListener, belirtilen topic’teki mesajları dinler ve işler:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageConsumer {<br><br> private final MessageRepository messageRepo;<br><br> @KafkaListener(topics = &quot;${myapp.kafka.topic}&quot;, groupId = &quot;kafka-group&quot;)<br> public void consume(String message) {<br> log.info(&quot;MESAJ TÜKETİCİYE ULAŞTI -&gt; {}&quot;, message);<br> messageRepo.addMessage(message);<br> }<br>}</pre><h3>Anahtar Özellikler:</h3><ul><li><strong>topics</strong>: Dinlenen Kafka topic’i.</li><li><strong>groupId</strong>: Tüketici grubunu tanımlar. Aynı gruptaki tüketiciler mesajları paylaşır.</li></ul><h3>🌐 7. REST API ile Etkileşim: KafkaRestController</h3><p>REST istemcileri için basit bir arayüz sağlar:</p><pre>@Slf4j<br>@RestController<br>@RequestMapping(&quot;/api/kafka&quot;)<br>@RequiredArgsConstructor<br>public class KafkaRestController {<br><br> private final MessageProducer producer;<br> private final MessageRepository messageRepo;<br><br> // Kafka topic&#39;ine mesaj gönder<br> @GetMapping(&quot;/send&quot;)<br> public ResponseEntity&lt;String&gt; sendMsg(@RequestParam(&quot;msg&quot;) String message) {<br> log.info(&quot;REST API ÜZERİNDEN MESAJ ALINDI -&gt; {}&quot;, message);<br> producer.sendMessage(message);<br> return ResponseEntity.ok(&quot;&#39;&quot; + message + &quot;&#39; mesajı başarıyla gönderildi!&quot;);<br> }<br><br> // Alınan tüm mesajları listele<br> @GetMapping(&quot;/messages&quot;)<br> public ResponseEntity&lt;String&gt; getAllMessages() {<br> return ResponseEntity.ok(messageRepo.getAllMessages());<br> }<br>}</pre><h3>API Kullanımı:</h3><p>GET /send?msg=... Kafka topic&#39;ine mesaj gönder</p><p>GET /getAllTüm alınan mesajları listele</p><h3>⚙️ 8. Uygulama Yapılandırması: application.yml</h3><pre>server:<br> port: 9090<br>spring:<br> kafka:<br> producer:<br> bootstrap-servers: localhost:9092<br> key-serializer: org.apache.kafka.common.serialization.StringSerializer<br> value-serializer: org.apache.kafka.common.serialization.StringSerializer<br> consumer:<br> bootstrap-servers: localhost:9092<br> key-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br> value-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br>myapp:<br> kafka:<br> topic: myKafkaTest</pre><h3>Yapılandırma Açıklamaları:</h3><ul><li><strong>bootstrap-servers</strong>: Kafka broker’ın adresi.</li><li><strong>key-serializer/deserializer</strong>: Anahtarların nasıl serileştirileceği.</li><li><strong>value-serializer/deserializer</strong>: Mesaj içeriğinin serileştirme biçimi.</li><li><strong>topic</strong>: Dinlenen veya yazılan Kafka topic’i.</li></ul><h3>🧠 9. Kafka Entegrasyonu İçin İpuçları ve En İyi Uygulamalar</h3><h3>1. Hata Yönetimi ve Retry Mekanizmaları</h3><ul><li>@Retryable anotasyonu ile otomatik tekrar deneme yapılabilir.</li><li>Kafka Consumer içinde Acknowledgment ile manuel commit yapılabilir.</li></ul><pre>@KafkaListener(topics = &quot;myTopic&quot;)<br>public void listen(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack) {<br> try {<br> // İşlemler<br> ack.acknowledge(); // Başarılıysa commit<br> } catch (Exception e) {<br> // Hata yönetimi<br> }<br>}</pre><h3>2. Dead Letter Queue (DLQ)</h3><ul><li>Başarısız mesajları başka bir topic’e yönlendirmek için DLQ kullanılabilir.</li></ul><h3>3. Serialization</h3><ul><li>JSON formatında mesaj göndermek için JsonSerializer kullanılabilir.</li><li>@KafkaListener metotlarında ConsumerRecord ile header bilgileri de alınabilir.</li></ul><h3>4. Partitions ve Offset Yönetimi</h3><ul><li>Topic partition sayısı artırılarak paralel tüketim sağlanabilir.</li><li>auto.offset.reset ayarı ile tüketici başlangıçta hangi offset’ten başlayacak belirlenir (örnek: earliest, latest).</li></ul><h3>🧪 10. Test Süreci</h3><h3>1. Kafka Topic Oluşturma</h3><pre>bin/kafka-topics.sh --create --topic myKafkaTest --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1</pre><h3>2. Kafka Consumer CLI ile Mesaj Dinleme</h3><pre>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic myKafkaTest --from-beginning</pre><h3>3. API ile Mesaj Gönderme</h3><pre>curl http://localhost:9090/send?msg=MerhabaKafka</pre><h3>4. Alınan Mesajları Görüntüleme</h3><pre>curl http://localhost:9090/getAll</pre><h3>📌 11. Güvenlik ve Performans İpuçları</h3><h3>1. SSL/TLS ile Güvenli Bağlantı</h3><ul><li>Kafka bağlantısı için SSL ayarları yapılabilir.</li><li>ssl.truststore.location ve ssl.keystore.location gibi parametreler application.yml’de tanımlanır.</li></ul><h3>2. Mesaj Sıkıştırması</h3><ul><li>compression.type ile mesajlar sıkıştırılabilir (gzip, snappy, lz4).</li></ul><h3>3. Mesaj Doğrulama</h3><ul><li>@Validated ve @KafkaListener ile gelen mesajlar doğrulanabilir.</li></ul><h3>🧭 12. Sonuç</h3><p>Spring Boot ile Apache Kafka entegrasyonu, mikroservislerde asenkron mesajlaşma, olay tabanlı mimariler, log toplama ve gerçek zamanlı veri işleme gibi birçok senaryoda güçlü çözümler sunar. Bu yazıda, temel yapılandırmalarla birlikte Kafka topic’ine mesaj gönderme ve alma işlemlerini basitçe adım adım öğrendik.</p><h3>✅ Öğrendiklerimiz:</h3><ul><li>Kafka ile Spring Boot entegrasyonu</li><li>Producer ve Consumer sınıfları</li><li>REST API ile Kafka etkileşimi</li><li>Yapılandırma ve hata yönetimi</li><li>Güvenlik ve performans optimizasyonları</li></ul><p>Bu temel yapıyı alarak Kafka ile daha karmaşık senaryolar (örneğin event sourcing, stream processing) da geliştirebilirsiniz.</p><h3>📘 Ekstra Kaynaklar</h3><ul><li><a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/">Spring Kafka Documentation</a></li><li><a href="https://kafka.apache.org/documentation/">Apache Kafka Official Docs</a></li><li><a href="https://kafka.apache.org/documentation/streams/">Kafka Streams ile Gerçek Zamanlı Veri İşleme</a></li><li><a href="https://www.baeldung.com/spring-kafka">Kafka ile Mikroservis Mimari Tasarımı — Baeldung</a></li></ul><p>Eğer bu yazı hoşunuza gittiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı ya da önerilerinizi yorumlarda bekliyorum. 😊</p><p>#springboot #kafka #messaging #microservices #java #backend</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8f2d4416f987" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Java’da Serileştirme (Serialization) ve En İyi Uygulamalar ]]>
</title>
<link>https://pehlivanmert.medium.com/javada-serile%C5%9Ftirme-serialization-ve-en-i%CC%87yi-uygulamalar-4fd05ec48a4a?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4fd05ec48a4a</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:05:31 GMT</pubDate>
<atom:updated>2025-05-09T06:13:07.941Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/629/1*pwMbKl8czO8lGyLut1HDZQ.png" /></figure><p>Java’da serileştirme (<strong>serialization</strong>), bir nesnenin durumunun (state) bayt dizisine dönüştürülmesi sürecidir. Bu işlem sayesinde nesneler kalıcı olarak saklanabilir (örneğin dosya ya da veritabanında), ağ üzerinden aktarılabilir veya geçici olarak önbellekte tutulabilir. Serileştirme sürecinin tersi olan <strong>deserileştirme (deserialization)</strong> ise bu bayt dizisinin tekrar orijinal nesneye dönüştürülmesini sağlar.</p><p>Bu yazıda Java’daki serileştirme mekanizmasını ele alacak, ne zaman kullanılması gerektiğini ve en iyi uygulama yöntemlerini adım adım inceleyeceğiz.</p><h3>📌 Serileştirme Nedir?</h3><p>Serileştirme, bir nesnenin içeriğini (durumunu) bayt dizisine çevirerek farklı ortamlarda taşınabilir hale getiren bir tekniktir. Özetle:</p><ul><li>Nesneler kalıcı olarak saklanabilir.</li><li>Ağ üzerinden gönderilip alınabilir.</li><li>Hızlıca geri yüklenebilir (deserialize edilebilir).</li></ul><p>Bir sınıfın serileştirilebilmesi için java.io.Serializable arayüzünü uygulaması gerekir. Bu, sadece bir işaretleme arayüzüdür (marker interface), herhangi bir metot içermez.</p><pre>public class Employee implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private String name;<br> private int age;</pre><pre> // constructor, getters and setters<br>}</pre><blockquote><em>⚠️ </em><em>Serializable uygulamak, sınıfınızın otomatik olarak güvenli ya da optimize edilmiş bir serileştirme sürecinden geçeceği anlamına gelmez. Dikkatli kullanım şarttır.</em></blockquote><h3>✅ Serileştirme Ne Zaman Kullanılır?</h3><h3>1. Kalıcılık (Persistence):</h3><p>Nesneleri dosyalarda veya veritabanlarında saklamak için kullanılır.</p><h3>2. İletişim (Communication):</h3><p>Ağ üzerinden nesnelerin gönderilmesi gerektiğinde (örneğin RMI — Remote Method Invocation) serileştirme devreye girer.</p><h3>3. Önbellekleme (Caching):</h3><p>Geçici olarak nesnelerin bellekte saklanması ve daha sonra hızlıca erişilmesi için kullanılır.</p><h3>🧠 Java Serileştirme İçin En İyi Uygulamalar</h3><h3>1. Gerektiği Zaman Kullanın</h3><p>Her sınıfın serileştirilebilir olması gerekmez. Sadece gerçekten ihtiyaç duyduğunuz sınıflara Serializable uygulayın. Gereksiz serileştirme, güvenlik açıklarına ve performans kayıplarına yol açabilir.</p><pre>public class Employee implements Serializable { ... }</pre><h3>2. Saklanması Gereken Alanları transient ile Gizleyin</h3><p>Bazı alanlar serileştirilmemelidir. Örneğin şifre, API anahtarı gibi hassas bilgileri transient anahtar kelimesiyle işaretleyin.</p><pre>public class User implements Serializable {<br> private String username;<br> private transient String password; // Şifre serileştirilmez<br>}</pre><h3>3. serialVersionUID Tanımlayın</h3><p>Her serileştirilebilir sınıf için private static final long serialVersionUID = 1L; tanımlanmalıdır. Bu, sınıfın sürüm numarasını temsil eder ve farklı sürümler arasında uyumluluğu sağlar.</p><blockquote><em>Eğer </em><em>serialVersionUID tanımlanmazsa, JVM otomatik olarak üretir ama bu, küçük değişikliklerde bile </em><em>InvalidClassException hatasına neden olabilir.</em></blockquote><h3>4. Özel Serileştirme Mantığı Ekleyin (İsteğe Bağlı)</h3><p>Eğer varsayılan serileştirme yeterli değilse, writeObject() ve readObject() metodlarını override ederek özel mantık ekleyebilirsiniz.</p><pre>private void writeObject(ObjectOutputStream oos) throws IOException {<br> oos.defaultWriteObject();<br> // Özel serileştirme işlemleri burada yapılabilir<br>}</pre><pre>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<br> ois.defaultReadObject();<br> // Özel deserileştirme işlemleri burada yapılabilir<br>}</pre><h3>5. Hassas Verilerin Serileştirilmesinden Kaçının</h3><p>Şifre, kimlik bilgileri, kredi kartı bilgileri gibi veriler asla serileştirilmemelidir. Bunu önlemek için yukarıda bahsedilen transient kullanımı oldukça önemlidir.</p><h3>6. Serileştirme Proxy’leri Kullanın (Gelişmiş Seviye)</h3><p>Daha fazla kontrol ve güvenlik istiyorsanız, serileştirme proxy desenini kullanabilirsiniz. Bu yöntem, sınıfın doğrudan serileştirilmesini engeller ve özel bir yapıyla koruma sağlar.</p><pre>private Object writeReplace() {<br> return new SerializationProxy(this);<br>}</pre><pre>private static class SerializationProxy implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private final String username;</pre><pre> SerializationProxy(User user) {<br> this.username = user.username;<br> }</pre><pre> private Object readResolve() {<br> return new User(username);<br> }<br>}</pre><p>Bu yaklaşım, nesne oluşturma sürecini kontrol altına alır ve güvenlik açıklarını azaltır.</p><h3>7. Alternatif Serileştirme Kütüphaneleri Kullanın</h3><p>Java’nın yerel serileştirme mekanizması, her zaman en verimli çözüm olmayabilir. Özellikle büyük sistemlerde, yüksek performans gerektiren senaryolarda şu alternatifler düşünülebilir:</p><ul><li><strong>Google Protocol Buffers (protobuf)</strong></li><li><strong>Apache Avro</strong></li><li><strong>Jackson (JSON formatında serileştirme)</strong></li><li><strong>Kryo (hızlı, kompakt serileştirme)</strong></li><li><strong>MessagePack</strong></li></ul><p>Bu kütüphaneler genellikle daha az yer kaplar, daha hızlı çalışır ve platformlar arası uyumluluk sağlar.</p><h3>🧪 Basit Bir Serileştirme &amp; Deserileştirme Örneği</h3><h3>1. Nesneyi Serileştirme</h3><pre>Employee emp = new Employee(&quot;John Doe&quot;, 30);</pre><pre>try (FileOutputStream fileOut = new FileOutputStream(&quot;employee.ser&quot;);<br> ObjectOutputStream out = new ObjectOutputStream(fileOut)) {<br> out.writeObject(emp);<br>} catch (IOException e) {<br> e.printStackTrace();<br>}</pre><h3>2. Nesneyi Deserileştirme</h3><pre>Employee emp = null;</pre><pre>try (FileInputStream fileIn = new FileInputStream(&quot;employee.ser&quot;);<br> ObjectInputStream in = new ObjectInputStream(fileIn)) {<br> emp = (Employee) in.readObject();<br>} catch (IOException | ClassNotFoundException e) {<br> e.printStackTrace();<br>}</pre><pre>System.out.println(&quot;Name: &quot; + emp.getName() + &quot;, Age: &quot; + emp.getAge());</pre><h3>🎯 Sonuç Olarak</h3><p>Java’nın serileştirme mekanizması güçlüdür ama doğru ve dikkatli kullanılması gereken bir özelliktir. Yukarıdaki en iyi uygulamalara uyarak:</p><ul><li>Performansı artırabilir,</li><li>Güvenliği güçlendirebilir,</li><li>Sürüm uyumsuzluklarından kaçınabilir,</li><li>Uygun yerlerde alternatif çözümler tercih ederek sisteminizi optimize edebilirsiniz.</li></ul><p>Unutmayın: Her nesne serileştirilmeye müsait değildir. Dikkatli planlama yapmak, hem kod kalitenizi hem de sisteminizin güvenliğini artıracaktır.</p><h3>📘 Ekstra Kaynaklar</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html">Oracle Java Documentation — Serialization</a></li><li><a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Effective Java by Joshua Bloch — Item 74–78 on Serialization</a></li><li><a href="https://www.baeldung.com/java-serialization">Baeldung — Java Serialization Guide</a></li></ul><p>Eğer bu yazı faydalı geldiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı veya deneyimlerinizi yorumlarda paylaşmaktan çekinmeyin. 😊</p><p>#java #serialization #deserialization #bestpractices #softwaredevelopment #backend #mediumtürkçe</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fd05ec48a4a" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot + Redis: Uygulamanızın Performansını Artırmak İçin Başlangıç Düzeyinden İleri… ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-redis-uygulaman%C4%B1z%C4%B1n-performans%C4%B1n%C4%B1-art%C4%B1rmak-i%CC%87%C3%A7in-ba%C5%9Flang%C4%B1%C3%A7-d%C3%BCzeyinden-i%CC%87leri-76b70fd9f3a4?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/76b70fd9f3a4</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 06 May 2025 20:48:18 GMT</pubDate>
<atom:updated>2025-05-09T06:14:02.224Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZOpeAqUVyZM8UkjvOXmTXg.png" /></figure><h3>🚀 Spring Boot + Redis: Uygulamanızın Performansını Artırmak İçin Başlangıç Düzeyinden İleri Seviyeye Rehber</h3><p>Yazılım dünyasında hız, her şey demektir. Kullanıcıların beklemesini istemiyorsanız, uygulamanızın hızlı yanıt vermesi gerekir. İşte bu noktada <strong>Redis</strong>, Spring Boot uygulamalarınızda ciddi performans artışları sağlayabileceğiniz güçlü bir yardımcıdır.</p><p>Bu yazıda:</p><ul><li>Redis nedir?</li><li>Neden cache kullanmalıyız?</li><li>Spring Boot ile Redis nasıl entegre edilir?</li><li>REST API üzerinden Redis işlemleri nasıl yapılır?</li><li>@Cacheable, @CacheEvict, @CachePut gibi Spring Cache anotasyonlarını nasıl kullanılır?</li><li>Mikroservis mimarilerinde dağıtık caching nasıl yapılır?</li></ul><p>gibi konulara değineceğiz. Hazır mısınız? Başlayalım!</p><h3>💡 Cache Nedir? Neden Önemlidir?</h3><p><strong>Cache (önbellek)</strong>, sıklıkla erişilen verilerin geçici olarak saklandığı bir mekanizmadır. Veriler genellikle <strong>anahtar-değer (key-value)</strong> formatında tutulur.</p><h3>✅ Cache’in Avantajları:</h3><ul><li>Veritabanına yapılan sorgu sayısını azaltır.</li><li>Uygulama yanıt süresini kısaltır.</li><li>Sistem kaynaklarını daha verimli kullanmanızı sağlar.</li><li>Özellikle yüksek trafikli uygulamalarda performans kazancı sağlar.</li></ul><p>Veritabanı çağrıları zaman alıcı ve pahalı işlemlerdir. İşte bu yüzden, sık kullanılan verileri önbellekte tutmak, uygulamanızın daha hızlı çalışmasını sağlar.</p><h3>🧠 Redis Nedir?</h3><p><strong>Redis</strong>, açık kaynaklı, bellek tabanlı (in-memory) bir veri deposudur. Hem cache olarak hem de veri saklama ve mesajlaşma amaçlı kullanılabilir.</p><h3>🔥 Redis’in Özellikleri:</h3><ul><li>Hızlı okuma/yazma işlemi çünkü tüm veriler RAM’de tutulur.</li><li>Basit ve güçlü komut seti.</li><li>String’lerden Hash’lara kadar çeşitli veri yapılarını destekler.</li><li>Dağıtık sistemlerde kolayca entegre edilebilir.</li></ul><h3>🛠️ Spring Boot ile Redis Entegrasyonu</h3><p>Spring Boot, Redis ile çalışmayı oldukça kolaylaştırır. spring-boot-starter-data-redis sayesinde Redis bağlantısı kurmak, veri işlemek ve yönetmek çok basittir.</p><h3>1. Gerekli Bağımlılıkları Ekleyin</h3><p>Maven kullanıyorsanız pom.xml dosyanıza aşağıdaki bağımlılıkları ekleyin:</p><pre>&lt;!-- Spring Boot Redis Starter --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Jedis Client --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br> &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Spring Cache Abstraction --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>2. Redis Sunucusunu Yapılandırın</h3><p>application.properties dosyanıza Redis bağlantı bilgilerini ekleyin:</p><pre>spring.redis.host=localhost<br>spring.redis.port=6379<br>spring.redis.password=</pre><p>Eğer Redis farklı bir sunucuda çalışıyor ise buraya IP adresini ve portu yazabilirsiniz.</p><h3>3. Caching’i Aktif Hale Getirin</h3><p>Ana uygulama sınıfınıza @EnableCaching anotasyonunu ekleyin:</p><pre>@SpringBootApplication<br>@EnableCaching<br>public class RedisApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(RedisApplication.class, args);<br> }<br>}</pre><h3>📦 Örnek Proje: Ülke Bilgilerini Redis Üzerinde Yönetmek</h3><p>Ufak bir örnek projesiyle Redis üzerinde CRUD işlemleri yapacağız. Amacımız ülke verilerini Redis’te hash olarak saklamak.</p><h3>1. Model Sınıfı: Country.java</h3><pre>public class Country implements Serializable {<br> private Integer sno;<br> private String name;<br> private String countryCode;</pre><pre> // Getters and Setters<br>}</pre><p>Serializable olması, Redis’e nesne olarak saklanabilmesi için gereklidir.</p><h3>2. Redis Yapılandırma Sınıfı: RedisConfig.java</h3><pre>@Configuration<br>public class RedisConfig {</pre><pre> @Bean<br> public JedisConnectionFactory jedisConnectionFactory() {<br> return new JedisConnectionFactory();<br> }</pre><pre> @Bean<br> public RedisTemplate&lt;String, Object&gt; redisTemplate() {<br> RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();<br> template.setConnectionFactory(jedisConnectionFactory());<br> template.setKeySerializer(new StringRedisSerializer());<br> template.setValueSerializer(new GenericJackson2JsonRedisSerializer());<br> return template;<br> }<br>}</pre><p>JSON formatında veri saklamak için Jackson serializer kullandık.</p><h3>🧠 Spring Cache Abstraction: @Cacheable, @CachePut, @CacheEvict</h3><p>Spring, cache işlemlerini kolaylaştırmak için bir soyutlama katmanı sunar. En yaygın kullanılan anotasyonlar şunlardır:</p><h3>🟢 @Cacheable</h3><p>Bir metodun sonucunu cache’e koyar. Aynı parametreyle tekrar çağrılırsa DB’ye gitmeden cache’den döner.</p><pre>@Cacheable(value = &quot;countries&quot;, key = &quot;#sno&quot;)<br>public Country getCountryById(Integer sno) {<br> return countryRepository.findById(sno).orElse(null);<br>}</pre><h3>🟡 @CachePut</h3><p>Cache’i güncellemek için kullanılır. Metod çalıştırılır ve sonuç cache’e yazılır.</p><pre>@CachePut(value = &quot;countries&quot;, key = &quot;#country.sno&quot;)<br>public Country updateCountry(Country country) {<br> return countryRepository.save(country);<br>}</pre><h3>🔴 @CacheEvict</h3><p>Cache’teki belirli bir veriyi veya tamamını silmek için kullanılır.</p><pre>@CacheEvict(value = &quot;countries&quot;, key = &quot;#sno&quot;)<br>public void deleteCountry(Integer sno) {<br> countryRepository.deleteById(sno);<br>}</pre><h3>Tümünü Silme:</h3><pre>@CacheEvict(value = &quot;countries&quot;, allEntries = true)<br>public void clearAllCountries() {<br> countryRepository.deleteAll();<br>}</pre><h3>🧪 Test Etme: Postman veya curl ile</h3><p>Aşağıdaki işlemleri test etmek için Postman veya benzeri bir araç kullanabilirsiniz:</p><p>POST /api/country — Yeni ülke bilgisi ekler.<br>GET /api/countries — Tüm ülke kayıtlarını listeler.<br>GET /api/country/1 — ID’si 1 olan ülkeyi getirir.<br>PUT /api/country — Ülke bilgisini günceller.<br>DELETE /api/country/1 — ID’si 1 olan ülkeyi siler.</p><p>Redis tarafında verileri doğrulamak için redis-cli kullanabilirsiniz:</p><pre>KEYS *<br>HGETALL countries::1</pre><h3>⚙️ Redis ile Daha İleri Gitmek: Dağıtık Caching</h3><p>Modern mikroservis mimarilerinde, birden fazla servis aynı verilere erişmek zorunda kalabilir. Her servisin kendi lokal cache’ini yönetmesi yerine, ortak bir <strong>dağıtık cache sunucusu</strong> kullanmak daha mantıklıdır.</p><h3>🌐 Dağıtık Caching Nedir?</h3><p>Birden fazla mikroservisin aynı merkezi cache sunucusuna (örneğin Redis) erişmesiyle oluşan yapıya denir. Böylece:</p><ul><li>Tüm servisler aynı veriye ulaşabilir.</li><li>Veri tutarlılığı sağlanır.</li><li>Performans artar, gecikmeler azalır.</li></ul><h3>🎯 Redis Entegrasyonunun Avantajları</h3><p><strong>Yüksek Performans:</strong> Redis bellek tabanlı (in-memory) çalıştığı için veri erişimi çok hızlıdır.</p><p><strong>Kolay Entegrasyon: </strong>Spring Boot ile kolayca entegre edilebilir; otomatik yapılandırma desteği sunar.</p><p><strong>Çeşitli Veri Yapılarını Destekler:</strong> String, Hash, List, Set gibi birçok veri yapısını destekler.</p><p><strong>Caching Amaçlı Kullanım:</strong> Sık erişilen verilerin hızlı bir şekilde alınması için ideal bir çözüm sağlar.</p><p><strong>Ölçeklenebilirlik:</strong> Dağıtık sistemlerde kolayca kullanılabilir ve yüksek ölçeklenebilirlik sunar.</p><h3>🧭 Sonuç</h3><p>Redis, Spring Boot uygulamalarınızın performansını artırmak için harika bir çözümdür. Hem basit cache senaryoları hem de karmaşık dağıtık sistemlerde kullanılmaya uygundur.</p><p>Bu yazıda adım adım Redis ile Spring Boot entegrasyonunu gerçekleştirdik, REST API üzerinden veri işlemlerini yaptık ve Spring’in cache mekanizmalarını (@Cacheable, @CacheEvict, @CachePut) detaylıca inceledik.</p><p>İsterseniz Redis ile session yönetimi, rate limiting, pub/sub mesajlaşma gibi gelişmiş konuları da araştırabilirsiniz.</p><p>🎯 <strong>Bonus Tip:</strong><br>Redis CLI ile alıştırmalar yaparak komut satırından da Redis’i tanımaya başlayabilirsiniz. Komutlar basit ama çok güçlüdür.</p><p>🔍 <strong>Kaynaklar:</strong></p><ul><li><a href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis Documentation</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html">Spring Cache Abstraction</a></li><li><a href="https://redis.io/documentation">Redis Official Documentation</a></li><li><a href="https://www.baeldung.com/spring-data-redis-tutorial">Spring Boot + Redis Guide — Baeldung</a></li></ul><p>Eğer bu yazı hoşunuza gittiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı ya da önerilerinizi yorumlarda bekliyorum. 😊</p><p>#springboot #redis #caching #microservices #java #backend #mediumtürkçe #cacheable #cacheevict #cacheput</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=76b70fd9f3a4" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot Uygulamanızda Görevleri Profesyonelce Zamanlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-uygulaman%C4%B1zda-g%C3%B6revleri-profesyonelce-zamanlama-b4f36acb4713?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/b4f36acb4713</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 06 May 2025 20:35:11 GMT</pubDate>
<atom:updated>2025-05-09T06:14:24.874Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/592/1*sUY-l0YENGLN7ogVR3VGmw.png" /></figure><p>Yazılım dünyasında otomasyon, işlerin düzgün işlemesini sağlamak için kritik öneme sahiptir. Günlük raporların gönderilmesi, geçici dosyaların temizlenmesi ya da verilerin güncellenmesi gibi görevler, çoğu uygulama için hayati öneme sahip süreçlerdir.</p><p>Eğer <strong>Spring Boot</strong> kullanıyorsanız, bu tür görevleri yönetmek için güçlü ve esnek bir araç setine sahipsiniz demektir. Bu yazıda, Spring Boot’ta görev zamanlamayı (task scheduling) detaylıca inceleyecek, yaygın kullanım senaryolarını örneklerle gösterecek ve bulut tabanlı alternatif çözümlerle karşılaştırma yapacağız.</p><h3>🔍 Spring Scheduling Nedir?</h3><p>Spring Scheduling, Spring Framework’ün içinde yer alan bir modüldür ve görevlerin belirli aralıklarla veya belli zamanlarda çalıştırılmasını sağlar. Hem basit hem de karmaşık senaryolara uygun şekilde kullanılabilen bu modül, anotasyonlar ve API üzerinden programlanabilir.</p><p>Örneğin:</p><ul><li>Belirli saniye/saat/dakika aralıklarıyla çalışan metodlar</li><li>Cron ifadeleri ile gelişmiş zamanlamalar</li><li>Sabit gecikmelerle tekrar eden işlemler</li></ul><p>gibi birçok senaryoyu destekler.</p><h3>🛠️ Spring Boot Projenize Scheduling Eklemek</h3><p>Spring Boot ile ilk görev zamanlamasını kurmak oldukça kolaydır. Gerekli adımlar şu şekildedir:</p><h3>1. Bağımlılık Ekleme</h3><p>Maven kullanıyorsanız pom.xml dosyanıza aşağıdaki bağımlılığı ekleyin:</p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><blockquote><em>💡 Web starter zaten projede varsa eklemenize gerek yoktur.</em></blockquote><h3>2. Scheduling’i Aktif Hale Getirme</h3><p>Ana uygulama sınıfınıza @EnableScheduling anotasyonunu ekleyin:</p><pre>@SpringBootApplication<br>@EnableScheduling<br>public class MyApplication {</pre><pre> public static void main(String[] args) {<br> SpringApplication.run(MyApplication.class, args);<br> }<br>}</pre><p>Bu adım sayesinde Spring Boot, projedeki zamanlanmış görevleri tanır ve planlayıcıyı başlatır.</p><h3>⏱️ İlk Zamanlanmış Görevinizi Oluşturun</h3><p>Basit bir örnek olarak her 5 saniyede bir konsola mesaj yazan bir görev tanımlayalım:</p><pre>@Component<br>public class MyScheduledTasks {</pre><pre> @Scheduled(fixedRate = 5000)<br> public void logMessage() {<br> System.out.println(&quot;Bu mesaj 5 saniyede bir yazılır!&quot;);<br> }<br>}</pre><ul><li>@Component: Spring’in bu sınıfı bir bean olarak tanıması için gereklidir.</li><li>@Scheduled(fixedRate = 5000): Metodun 5000 milisaniyede (5 saniye) bir çalışacağını belirtir.</li></ul><h3>📌 Yaygın Kullanım Senaryoları</h3><h3>📧 E-posta Bildirimleri Gönderme</h3><p>Bir e-ticaret uygulamasında, günlük sipariş özetlerini yöneticiye göndermek istiyorsanız:</p><pre>@Scheduled(cron = &quot;0 0 0 * * *&quot;)<br>public void sendDailyOrderSummary() {<br> List&lt;Order&gt; yesterdayOrders = orderRepository.findYesterdayOrders();<br> emailService.sendOrderSummary(yesterdayOrders);<br>}</pre><blockquote><em>cron = &quot;0 0 0 * * *&quot; ifadesi her gün gece yarısı çalıştır anlamına gelir. Cron ifadeleri hakkında daha fazla bilgi için </em><a href="https://crontab.guru/"><em>crontab.guru</em></a><em> adresini ziyaret edebilirsiniz.</em></blockquote><h3>🗃️ Veri Yedekleme</h3><p>Veri güvenliğiniz için gece yarısı bir veritabanı yedeği almak istiyorsanız:</p><pre>@Scheduled(cron = &quot;0 0 2 * * *&quot;) // Her gün saat 02:00&#39;de çalışır<br>public void performDatabaseBackup() {<br> backupService.createBackup();<br>}</pre><h3>🧹 Cache Temizleme</h3><p>Cache performansını artırmak için düzenli olarak eski verileri temizleyebilirsiniz:</p><pre>@Scheduled(fixedRate = 3600000) // Her saat başı<br>public void evictCache() {<br> cacheManager.getCache(&quot;myCache&quot;).clear();<br>}</pre><h3>🚚 Arka Plan İşleri (Task Queue)</h3><p>Görev kuyruklarını periyodik olarak kontrol etmek için:</p><pre>@Scheduled(fixedDelay = 10000)<br>public void processTasks() {<br> while (taskQueue.hasTasks()) {<br> Task task = taskQueue.dequeue();<br> taskProcessor.process(task);<br> }<br>}</pre><h3>🩺 Sistem Sağlığı Kontrolü</h3><p>Uygulamanızdaki sistem sağlığını düzenli olarak denetlemek için:</p><pre>@Scheduled(fixedRate = 60000)<br>public void checkSystemHealth() {<br> if (!healthCheckService.isHealthy()) {<br> alertService.sendAlert(&quot;Sistemde bir hata tespit edildi!&quot;);<br> }<br>}</pre><h3>☁️ Spring Scheduling vs Bulut Çözümleri</h3><blockquote><em>📌 Eğer mikroservis tabanlı, yüksek ölçeklenebilirlik gerektiren bir mimariniz varsa, AWS Lambda veya Azure Functions gibi bulut çözümleri daha mantıklı olabilir.</em></blockquote><h3>🧠 İleri Seviye Kullanım: Dağıtık Ortamda Görev Zamanlama</h3><p>Diyelim ki mikroservis tabanlı bir yapı kuruyorsunuz ve birden fazla servis örneğinde görevleri koordine etmeniz gerekiyor. İşte bu noktada Spring Boot’u AWS hizmetleriyle birleştirerek güçlü bir çözüm oluşturabilirsiniz.</p><h3>🎯 Problem Tanımı</h3><ul><li>Birden fazla servis örneğinde görevlerin eş zamanlı çalıştırılması</li><li>Hata toleransı (bir servis çakarsa diğerinin devralması)</li><li>Merkezi izleme ve yönetim</li></ul><h3>✅ Çözüm</h3><h4>1. Görev Tanımı — Spring @Scheduled + @Component</h4><p>Her serviste görevler standart Spring anotasyonlarıyla tanımlanır:</p><pre>@Scheduled(cron = &quot;0 */5 * * * *&quot;)<br>public void myDistributedTask() {<br> if (lockService.acquireLock(&quot;myDistributedTask&quot;)) { <br> try {<br> // Gerçek görev işlemleri<br> } finally {<br> lockService.releaseLock(&quot;myDistributedTask&quot;); <br> }<br> }<br>}</pre><h4>2. Dağıtık Kilitleme — DynamoDB</h4><p>Amazon DynamoDB’nin atomic counter özelliğini kullanarak dağıtık kilit mekanizması uygulanabilir. Böylece aynı anda sadece bir instance görevi çalıştırır.</p><h4>3. Görev Kuyruğu — Amazon SQS</h4><p>Görevler doğrudan değil, bir kuyruğa gönderilir. Bu sayede görev zamanlama ile yürütme ayrılmış olur:</p><pre>@Scheduled(cron = &quot;0 */5 * * * *&quot;)<br>public void scheduleMyTask() {<br> taskQueue.enqueue(&quot;myDistributedTask&quot;, taskData); <br>}</pre><h4>4. Worker Process — Mikroservis Örneklerinde Çalıştırıcı</h4><p>Her mikroservis örneği, SQS kuyruğundan görev alıp işler:</p><pre>@Component<br>public class TaskWorker {</pre><pre> @Autowired<br> private TaskProcessor taskProcessor;</pre><pre> @Scheduled(fixedDelay = 5000)<br> public void processTasks() {<br> Message message = taskQueue.receiveMessage(); <br> if (message != null) {<br> String taskType = message.getAttribute(&quot;taskType&quot;);<br> String taskData = message.getBody(); <br> taskProcessor.process(taskType, taskData);<br> taskQueue.deleteMessage(message); <br> }<br> }<br>}</pre><h4>5. İzleme — Amazon CloudWatch</h4><p>SQS kuyruğu uzunluğu, görev süresi ve hatalar merkezi olarak CloudWatch ile izlenebilir.</p><h3>✅ Bu Yaklaşımın Avantajları</h3><ul><li><strong>Yatay Ölçeklenebilirlik:</strong> Servis örnekleri artırıldıkça sistem aksamadan çalışmaya devam eder.</li><li><strong>Yüksek Kullanılabilirlik:</strong> Bir servis düşerse diğeri görevi devralır.</li><li><strong>Kolay Yönetim:</strong> Görevler merkezi olarak takip edilir ve yönetilir.</li></ul><h3>🧭 Sonuç</h3><p>Spring Boot’un @Scheduled anotasyonu ve @EnableScheduling desteği, uygulamanızdaki görevleri zamanlamak için güçlü ve esnek bir yöntem sunar. Basit senaryolardan ileri düzey dağıtık yapılara kadar geniş bir yelpazede kullanılabilir.</p><p>Ancak, özellikle mikroservis tabanlı, yüksek ölçeklenebilirlik gerektiren sistemlerde AWS Lambda, Azure Functions gibi bulut tabanlı çözümler tercih edilebilir.</p><p>İleri seviye bir mimaride Spring Boot + AWS entegrasyonu ile sağlam, ölçeklenebilir ve izlenebilir bir görev zamanlama sistemi kurmak mümkündür. Bu yaklaşımları projelerinize adapte ederek hem performans hem de bakım kolaylığı sağlayabilirsiniz.</p><p>🎯 <strong>Bonus Tip:</strong><br>Cron ifadeleri karmaşık olabilir. Test etmeden önce mutlaka <a href="https://crontab.guru/">crontab.guru</a> gibi araçlarla doğrulayın!</p><p>🔍 <strong>Daha Fazlası İçin:</strong></p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html">Spring Documentation — Scheduling Tasks</a></li><li><a href="https://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html">AWS Lambda with Scheduled Events</a></li><li><a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer">Azure Timer Triggered Functions</a></li></ul><p>Eğer bu yazı hoşunuza gittiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı ya da önerilerinizi yorumlarda bekliyorum. 😊</p><p>#springboot #scheduling #microservices #aws #java #backend</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b4f36acb4713" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
</channel>
</rss>