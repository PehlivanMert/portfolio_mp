<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html" version="2.0" class="hidden">
<link type="text/css" id="dark-mode" rel="stylesheet" href=""/>
<style type="text/css" id="dark-mode-сustom-style"/>
<style type="text/css" id="dark-mode-theme-changer-style"/>
<channel>
<title>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</title>
<description>
<![CDATA[ Stories by Mert Pehlivan on Medium ]]>
</description>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
<image>
<url>https://cdn-images-1.medium.com/fit/c/150/150/0*B8-_pQzPr4S4bxYR</url>
<title>Stories by Mert Pehlivan on Medium</title>
<link>https://medium.com/@pehlivanmert?source=rss-83e9f53f33c4------2</link>
</image>
<generator>Medium</generator>
<lastBuildDate>Fri, 11 Jul 2025 11:16:14 GMT</lastBuildDate>
<atom:link href="https://medium.com/@pehlivanmert/feed" rel="self" type="application/rss+xml"/>
<webMaster>
<![CDATA[ yourfriends@medium.com ]]>
</webMaster>
<atom:link href="http://medium.superfeedr.com" rel="hub"/>
<item>
<title>
<![CDATA[ Evrenin Kalbine Yolculuk Şimdi Başlıyor! ]]>
</title>
<link>https://pehlivanmert.medium.com/evrenin-kalbine-yolculuk-%C5%9Fimdi-ba%C5%9Fl%C4%B1yor-f2e72e00b43b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/f2e72e00b43b</guid>
<category>
<![CDATA[ astronomy ]]>
</category>
<category>
<![CDATA[ technology ]]>
</category>
<category>
<![CDATA[ cosmos ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 11 Jul 2025 11:14:05 GMT</pubDate>
<atom:updated>2025-07-11T11:14:05.015Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M7tL7VAJP2FrlB9xCOS1WQ.jpeg" /></figure><p>Çocukluğumdan beri, içimde hiç susturamadığım, <em>The Big Bang Theory</em>’deki Sheldon Cooper’ı aratmayan bir ses var. Her şeye “Neden?” diye soran, evrenin en temelinden en karmaşığına her detayı merak eden bir ses. O ses, özellikle geceleri gökyüzüyle baş başa kaldığımda daha da yükselir. O pırıl pırıl noktaların her biri, aklımın sınırlarını zorlayan mesafelerin ve olasılıkların birer temsilcisi gibi gelir. Zihnimde hep aynı temel sorular yankılanır: “Biz kimiz? Bu akıl almaz büyüklükteki kozmik okyanusta bir anlamımız var mı?”</p><p>İşte bu soruların tam ortasında, insanlık tarihine yeni bir sayfa ekleniyor ve ben bu anın bir şahidi olmaktan dolayı iliklerime kadar heyecanlıyım. Vera C. Rubin Gözlemevi faaliyete geçti. Bu, sadece cam ve metalden oluşmuş bir teleskop değil; insanlığın bitmek bilmeyen merakının, azminin ve bilme arzusunun Şili’nin And Dağları’na dikilmiş devasa bir anıtı.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*k3xTQSn7jJa-4-MY5VOHcw.jpeg" /></figure><p>Ve beklenen an geldi. 23 Haziran 2025&#39;te gelen ilk test görüntüleri… “Vay be” demekten başka bir kelime bulamadım. Uzak bir nebulanın ipliksi gaz bulutlarından, iki galaksinin birbirinin içine girdiği o şiddetli kozmik dansa kadar her şey, daha önce hiç görmediğimiz bir netlikteydi. Bu görüntüler, sadece bilim camiasında değil, benim gibi dünyanın dört bir yanındaki sayısız meraklı ruhta da evrensel bir coşku yarattı. Bu, 10 yıllık büyük filmin sadece fragmanıydı ama şimdiden milyonlarca galaksiyi, binlerce asteroidi ve kendi galaksimizdeki sayısız yıldızı bizlere sundu. Bu, basit bir teknik başarıdan çok öte; hepimizi birbirimize bağlayan o ortak merakın, bilginin peşindeki kolektif yolculuğun somut bir başlangıcı.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DmJrhxP3XpQfRxPo-M1ARg.jpeg" /></figure><h4>Evrenin Perdesini Aralamak, Rubin Neyi Değiştirecek?</h4><p>Bu ilk etkileyici anlar, aslında çok daha büyük bir hikayenin sadece ilk cümlesi. Rubin’in asıl devrimi, bize statik fotoğraflar sunması değil; evrenin yaşayan, nefes alan, dinamik hikayesini anlatacak olması. Bize evrenin sandığımızdan çok daha aktif ve canlı olduğunu gösterecek on yıllık bir maraton başlıyor.</p><p><strong>Gerçeğin Dokusunu Anlamaya Çalışacağız:</strong> En büyük hedef, evrenin yaklaşık %95&#39;ini oluşturan ama hakkında neredeyse hiçbir şey bilmediğimiz o gizemli karanlık madde ve karanlık enerji. Isaac Asimov’un <em>Vakıf</em> serisinde, bir galaktik imparatorluğun geleceğini matematiksel olarak öngören “Psikotarih” bilimini okuduğumda hayran kalmıştım. Şimdi Rubin, sanki gerçek bir Vakıf projesinin ilk adımlarını atıyor. Evrenin görünmez güçlerini haritalayarak, kozmosun nihai kaderini anlamaya çalışacak. Bu, sadece bir katalog oluşturmak değil; gerçeğin temel dokusunu, belki de henüz bilmediğimiz fizik yasalarını anlama yolunda felsefi bir sıçrama.</p><p><strong>Kozmik Komşularımızı Tanıyacağız:</strong> Gözlemevi, kendi Güneş Sistemi’mizin de detaylı bir envanterini çıkaracak. Tıpkı <em>Star Wars</em>’ta gemilerin güvenli rotalar için detaylı yıldız haritalarına ihtiyaç duyması gibi, biz de kendi mahallemizdeki tehlikeli asteroitleri ve buzlu cisimleri tanımak zorundayız. Bu, gezegenimizin güvenliği için bir erken uyarı sistemi kurmak anlamına geliyor ve gökbilimin soyut merakının ötesinde, insanlık için ne kadar somut faydalar sağlayabileceğinin en güzel kanıtı.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F7gGltfcBUtQ%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D7gGltfcBUtQ&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F7gGltfcBUtQ%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/c179c2fc59b9191d03c343ea80b4ec7d/href">https://medium.com/media/c179c2fc59b9191d03c343ea80b4ec7d/href</a></iframe><p><strong>Evrenin Canlı Yayını:</strong> Evren sürekli değişiyor. Yıldızlar patlıyor (süpernovalar), devasa enerji patlamaları yaşanıyor. Rubin’in en sevdiğim yanlarından biri de bu anlık olayları inanılmaz bir hızla tespit edecek olması. Her gece değişen veya yeni beliren nesneler için yaklaşık 10 milyon uyarı yayınlayacak. Bu, dünyanın dört bir yanındaki diğer teleskopların o noktaya dönüp olayı detaylı incelemesi için bir “kozmik alarm” sistemi demek. Bu sayede, yıldızların nasıl öldüğünü, ağır elementlerin evrene nasıl yayıldığını ve fiziğin en uç koşullarını canlı canlı izleyebileceğiz.</p><p><strong>Kendi Kozmik Kökenimiz:</strong> Ve tabii ki evimiz, Samanyolu… Milyarlarca yıldızı tek tek gözlemleyerek galaksimizin nasıl oluştuğunu, hangi kadim galaksileri yutarak büyüdüğünü ve bugünkü yapısına nasıl ulaştığını bir arkeolog gibi katman katman ortaya çıkaracak. Asimov’un Robot serilerinden galaksi tarihine uzanan o büyük anlatıları gibi, biz de kendi kozmik soy ağacımızı, nereden geldiğimizin hikayesini anlama fırsatı bulacağız.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eXtV-V8of2Si33X4n3Fa9A.jpeg" /></figure><h4>Zamanın Ötesinde Bir Film, Evrenin Canlı Portresi</h4><p>Rubin’in çalışma prensibi, benim gibi teknolojiyle iç içe olan birini ayrıca heyecanlandırıyor. Projenin kalbinde, 3.2 gigapiksel çözünürlüğüyle dünyanın en büyük dijital kamerası olan LSST Kamerası var. Tek bir görüntüsünü tam çözünürlükte görebilmek için 400 tane 4K televizyon ekranını bir araya getirmeniz gerekiyor! Bu canavar, her 40 saniyede bir gökyüzünün devasa bir bölümünü çekerek, her üç gecede bir aynı noktayı tekrar ziyaret edecek. On yıl boyunca bunu yaptığında, elimizde evrenin daha önce hiç çekilmemiş, zaman atlamalı bir filmi olacak.</p><p>Bunu, gökyüzüne bakan bir “araç kamerası” gibi düşünün. Eğer bir yıldız aniden patlarsa veya tuhaf bir nesne belirip kaybolursa, kaydı geri sarıp o olaya neyin sebep olduğunu, öncesinde neler yaşandığını görebileceğiz. Bu, gökbilimi adeta bir tür “kozmik adli bilime” dönüştürüyor.</p><p>Tabii bu görevin getirdiği veri yükü de akıl almaz boyutlarda. Her gece 20 terabayt, on yılın sonunda ise işlenmiş haliyle 500 petabaytlık bir veri arşivi… Bu, insanlık tarihi boyunca yazılmış tüm metinlerin toplamından katbekat fazla. Bu veri selini yönetmek, işlemek ve anlamlandırmak için geliştirilen algoritmalar, yapay zeka çözümleri ve hesaplama altyapıları, sadece astronomiyi değil, veri biliminin geleceğini de şekillendiriyor.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9z7DiT5mMSHkGbpcYyfSZg.jpeg" /></figure><h4>Görmediğimiz Ne Varsa, Bilinmeyene Atılan Adım</h4><p>Belki de tüm bunların en heyecan verici yanı, ne bulmayı umduğumuz değil, ne bulacağımızı hayal bile edemediğimiz şeyler. Bilim tarihi, en büyük devrimlerin beklenmedik keşiflerle yapıldığını gösterir. Benim her şeye olan bitmez tükenmez merakım da buradan geliyor. Doğada bir ağacın dallanmasından bir nehrin yatağına, teknolojide bir otomasyon sisteminden kadim bilgilerin içerdiği desenlere kadar her yerde bir düzen, bir mantık ararım. Rubin, işte bu arayışı evrensel boyuta taşıyor. ‘Oumuamua gibi yıldızlararası sistemimizden geçen o gizemli ziyaretçileri hatırlayın. Rubin, bu türden yüzlerce, belki de binlerce nesne bulabilir. Belki de bazıları, evren hakkındaki en temel varsayımlarımızı sorgulamamıza neden olacak.</p><p>Bu proje, sadece teknik soruları değil, en derin felsefi sorularımızı da besliyor. Nereden geldik? Nereye gidiyoruz? Bu sonsuzlukta yalnız mıyız? Rubin bu sorulara kesin cevaplar vermeyebilir, ama bize öyle veriler sunacak ki, bu sorulara vereceğimiz cevaplar hiç olmadığı kadar temellendirilmiş olacak.</p><h4>Bu Yolculuk Hepimizin</h4><p>Bu projenin en takdir ettiğim yönlerinden biri de şeffaflığı. Elde edilen tüm bu devasa veri hazinesi, dünyanın dört bir yanındaki bilim insanlarına ve hatta meraklı amatörlere açık olacak. Bu, sanki <em>Star Wars</em>’taki Jedi Arşivleri’nin kapılarını tüm galaksiye açmak gibi bir şey. Keşif, artık küçük bir elit zümrenin tekelinde olmayacak. Bu, keşfin demokratikleşmesi demek. Kim bilir, belki de bir sonraki büyük keşif, hiç beklenmedik bir ülkeden, genç bir öğrencinin bu verileri incelerken fark edeceği bir anomali sayesinde gelir.</p><p><a href="https://rubinobservatory.org/gallery/collections/first-look-gallery/cprq3ebjj15brf1ueomd1brb5q">The Cosmic Treasure Chest (Video-EN)</a></p><p>Bir bilim insanının dediği gibi, “Bu veri seti, muhtemelen ben öldükten sonra bile hala geçerli olacak.” Bu cümle, projenin büyüklüğünü özetliyor. Bizler, gelecek nesillerin üzerinde sayısız keşif inşa edeceği bir kozmik kütüphanenin, bir evren atlasının yaratılışına tanıklık ediyoruz.</p><p>Bu yüzden gözlerimi gökyüzüne diktim. Çünkü artık oraya baktığımda sadece parlayan noktalar değil, kapıları ardına kadar açılan bir olasılıklar evreni görüyorum. <strong>Ve bu yolculukta hep birlikteyiz. Bu, benim için en büyük heyecan kaynağı.</strong></p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f2e72e00b43b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Kariyer Yolculuğunda Zaman ve Yön Algısı: Türkiye, Avrupa ve Amerika Kıyaslaması ]]>
</title>
<link>https://pehlivanmert.medium.com/kariyer-yolculu%C4%9Funda-zaman-ve-y%C3%B6n-alg%C4%B1s%C4%B1-t%C3%BCrkiye-avrupa-ve-amerika-k%C4%B1yaslamas%C4%B1-9a80d2966556?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/9a80d2966556</guid>
<category>
<![CDATA[ careers ]]>
</category>
<category>
<![CDATA[ development ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 24 Jun 2025 11:50:48 GMT</pubDate>
<atom:updated>2025-06-25T06:25:49.737Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bS7237XkM9wBG19exPV0Xg.jpeg" /><figcaption>Photo by Javier Allegue Barros on Unsplash</figcaption></figure><p>Kariyer, bireylerin yaşam boyu süren bir yolculuğu olarak kabul edilir; ancak bu yolculuğun hızı ve yönü, içinde bulunulan kültürel ve ekonomik koşullara göre büyük farklılıklar gösterir. Türkiye’de gözlemlenen “hemen üniversiteye git, hemen iş bul ya da hemen master yap, hemen iş bul” gibi bir “koşturmaca” hali, birçok genç profesyonelin deneyimlediği yaygın bir baskıdır. Bu durum, özellikle 30&#39;lu yaşlara gelindiğinde kariyerde “geç kalmışlık” hissi yaratabilir, sektör değişimleri garip karşılanabilir ve alaylı (otodidakt) kişilere yetersiz gözüyle bakılabilir. Oysa Avrupa ve Amerika’da durumun daha farklı olduğu, insanların bu kadar acele etmediği ve kariyer yollarının daha esnek olduğu gözlemlenmektedir. Bu rapor, söz konusu kültürel farklılıkları, kariyer algısındaki zihniyet yapılarını derinlemesine inceleyerek, gençlere ve 30&#39;lu yaşlardaki profesyonellere ilham ve cesaret vermeyi amaçlamaktadır.</p><h3>Türkiye’deki Kariyer Koşturmacası: Neden Bu Kadar Acele Ediyoruz?</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uzW9SPfwtrlE3PDcXzY1ag.png" /></figure><p>Türkiye’deki kariyer yolculuğunun hızlı ve baskıcı doğası, köklü sosyo-ekonomik ve kültürel faktörlerden beslenmektedir. Bu durum, bireyler üzerinde erken yaşta başarıya ulaşma ve geleneksel kariyer yollarından sapmama yönünde yoğun bir baskı oluşturur.</p><p>Ülkedeki genç işsizliği oranları, bu koşturmacanın temel nedenlerinden biridir. Türkiye’de 15–24 yaş arası genç işsizlik oranı, 2019&#39;da %25,4 iken, 2020&#39;de %25,3 olarak kaydedilmiştir. Bu oran, dünya ortalamasının yaklaşık iki katıdır ve uzun süreli, yapısal nedenlere dayanmaktadır. Özellikle yükseköğretim mezunları arasında işsizlik oranı daha da yüksektir; 2020 yılında bu oran %35,8&#39;e ulaşmıştır. Bu veriler, eğitim sisteminin çıktısı ile işgücü piyasasının talepleri arasında önemli bir uyumsuzluk olduğunu göstermektedir.</p><p>Bu uyumsuzluk ve yüksek işsizlik, bireyleri bir an önce herhangi bir işe girme konusunda savunmacı bir strateji benimsemeye iter. İşgücü piyasası doygunlaştığında ve fırsatlar kısıtlı olduğunda, erken istihdam güvencesi hayati bir önem kazanır. Bu durum, kariyer keşfi için zaman ayırmanın veya geç yaşta sektör değiştirmenin lüks, hatta bir risk olarak algılanmasına yol açar ve “geç kalmışlık” hissine katkıda bulunur.</p><p>Türkiye’deki kültürel yapı da bu durumu pekiştirmektedir. Doğu kültürlerinde yaygın olan “kadercilik” anlayışı , bireylerin kariyer planlamasına ve risk alma eğilimlerine etki edebilir. “Her şey olacağına varır” gibi bir düşünce, proaktif kariyer değişimlerini veya geleneksel olmayan öğrenme yollarını, önceden belirlenmiş bir akışa karşı gelmek olarak yorumlanmasına neden olabilir. Bu, özellikle toplumsal onay ve grup istikrarının ön planda olduğu kolektivist değerlerle birleştiğinde , kariyer değişikliklerinin “garip karşılanması” veya alaylı kişilerin “yetersiz gözüyle bakılması” gibi algıları güçlendirebilir. Toplumun ve ailenin beklentileri, bireyin geleneksel “güvenli” yolu (üniversite, istikrarlı bir iş) takip etmesini teşvik eder.</p><p>30&#39;lu yaşlarda hissedilen “geç kalmışlık sendromu” da bu bağlamda ortaya çıkar. Toplumsal baskı, başarısızlık korkusu ve belirli yaşlara kadar belirli kariyer ve kişisel hedeflere (evlilik, çocuk sahibi olma gibi) ulaşma beklentisi, bu yaş grubundaki bireylerde yoğun bir kaygıya neden olabilir. Ülkenin ekonomik performansına yönelik olumsuz algılar da bu kariyer kaygısını artırarak, bireyleri daha da hızlı hareket etmeye itebilir.</p><p>Aşağıdaki tablo, Türkiye’deki genç işsizliği ve NEET oranlarının (Ne Eğitimde Ne İstihdamda Olan Gençler) bu baskının somut göstergelerini sunmaktadır:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PYMWLdeUuokbqcivcXMDsw.png" /></figure><p>Bu veriler, Türkiye’de kariyer başlangıcındaki hız beklentisinin ve erken kariyer baskısının, yüksek genç işsizliği ve eğitim-istihdam uyumsuzluğu gibi yapısal sorunlardan kaynaklandığını açıkça ortaya koymaktadır.</p><h3>Avrupa ve Amerika’da Kariyer Yolu: Esneklik ve Uzun Vadeli Bakış</h3><p>Avrupa ve Amerika’daki kariyer kültürü, Türkiye’deki “koşturmaca” algısının aksine, genellikle daha esnek ve uzun vadeli bir perspektif sunmaktadır. Bu bölgelerde, kariyer yolları daha az katı çizgilere sahiptir ve bireylerin yaşam boyu öğrenme, kariyer molaları veya orta yaşta sektör değişiklikleri yapmaları daha fazla kabul görmektedir.</p><p>Bu esnekliğin arkasında yatan önemli bir faktör, demografik değişimlerdir. Avrupa’da 55–64 yaş arası Avrupalıların istihdam oranı 2010&#39;dan 2023&#39;e kadar yaklaşık 20 puan artarak %45&#39;ten %64,5&#39;e yükselmiştir. AB işgücünde 55 yaş ve üzeri kişilerin payı 2004&#39;te %12 iken 2019&#39;da %20&#39;ye çıkmıştır. Bu durum, yaşlanan işgücünün ekonomiler için giderek daha önemli hale geldiğini ve deneyimli profesyonellerin işgücünde kalmasının bir zorunluluk haline geldiğini göstermektedir. Bu demografik gerçeklik, yaşa bağlı kariyer kısıtlamalarının azalmasına ve daha kapsayıcı istihdam politikalarının benimsenmesine yol açmaktadır.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HYEzC8y0n2UsU-dgDBCzsA.png" /></figure><p>Batı toplumlarında kariyer tercihlerini şekillendiren bir diğer önemli etken, iş-yaşam dengesine verilen artan değerdir. Yapılan araştırmalar, iş-yaşam dengesinin birçok Avrupalı için maaştan daha önemli bir motivasyon kaynağı haline geldiğini göstermektedir. Avrupalıların %51&#39;i iş-yaşam dengelerinden çok memnun olduğunu belirtirken, Amerikalıların %33&#39;ü tatile çıktığında suçluluk hissettiğini, Avrupalıların ise sadece %18&#39;i bu duyguyu paylaştığını ifade etmektedir. Bu, bireylerin kariyerlerini sadece finansal kazanç veya erken istikrar arayışıyla değil, aynı zamanda kişisel tatmin, esneklik ve yaşam tarzı uyumu doğrultusunda şekillendirme eğiliminde olduğunu ortaya koymaktadır.</p><p>Kariyer molaları ve orta kariyer değişiklikleri de bu kültürlerde daha fazla kabul görmektedir. Araştırmalar, iş değiştiren orta kariyerli ve daha yaşlı çalışanların işlerinin tüm boyutlarından önemli ölçüde daha memnun olduklarını göstermektedir. Ancak, bu algının tamamen sorunsuz olduğu söylenemez. Uluslararası bir ankete göre, insanların %42&#39;sinden azı kariyer molası vermeyi göze alabildiğini hissederken, yaklaşık %80&#39;i böyle bir molanın kariyer ilerlemeleri üzerindeki etkisinden endişe duymaktadır. İşverenler arasında da 45 yaş üstü adaylara karşı bir “stereotip” ve “yaş ayrımcılığı” hala mevcuttur; genellikle 30–44 yaş arası adaylar tercih edilmektedir. Ancak bu durumun bir paradoksu bulunmaktadır: işverenlerin %89&#39;u, işe aldıkları orta yaş ve üzeri çalışanların genç çalışanlar kadar iyi veya daha iyi performans gösterdiğini belirtmiştir. Bu, yaşa bağlı önyargıların, gerçek performansla çeliştiğini ve deneyimli profesyoneller için fırsatların aslında mevcut olduğunu ortaya koymaktadır.</p><p>Bu durum, Batı kariyer kültüründeki esnekliğin mükemmel bir idealden ziyade, demografik zorunluluklar ve değişen değerler ışığında sürekli gelişen bir gerçeklik olduğunu göstermektedir. Bireycilik, kişisel özerklik ve kendini gerçekleştirme vurgusu , kariyer yollarının daha az doğrusal ve daha fazla kişisel tercihlere dayalı olmasına olanak tanımaktadır.</p><h3>30&#39;lu Yaşlar: Geç Kalmışlık Değil, Yeni Başlangıçların Eşiği</h3><p>Türkiye’de 30&#39;lu yaşlarda kariyer değişikliği yapmanın “geç kalmışlık” olarak algılanması yaygın olsa da, bu yaşlar aslında kariyerde yeniden yapılanma ve büyüme için güçlü bir dönemdir. 30&#39;lu yaşlardaki bireyler, kariyer değişikliğine paha biçilmez avantajlar getirirler: önceki deneyimler (alakası olmadığı düşünülen alanlardan bile olsa), olgunluk, daha net bir amaç duygusu ve genellikle daha geniş bir profesyonel ağ.</p><p>Kariyer değiştiren orta yaş ve üzeri çalışanların, yeni işlerinden çok daha memnun oldukları gözlemlenmektedir. Bu durum, 30&#39;lu yaşlarda alınan bilinçli kararların, daha önceki gençlik dönemlerinde yapılan ve belki de tam olarak tatmin etmeyen seçimlere kıyasla, daha fazla kişisel tatmin ve başarı getirebileceğini göstermektedir.</p><p>Teknoloji sektörüne bakıldığında, kodlama bootcamp’lerine katılanların %70&#39;inden fazlasının 2023 yılında 25 ila 40 yaşları arasında olduğu ve kariyer değiştirmek veya becerilerini geliştirmek amacıyla katıldıkları belirtilmiştir. Bu, 30&#39;lu yaşların, yeni beceriler edinmek ve kariyerde önemli bir dönüşüm yapmak için ideal bir dönem olduğunu gösteren somut bir kanıttır.</p><p>Tarih, 30&#39;lu yaşlardan sonra kariyerinde büyük atılımlar yapmış veya tamamen yeni bir alana geçerek zirveye ulaşmış ilham verici isimlerle doludur:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RsxyhchTIEkj4OPvPAY_Ng.png" /></figure><p>Bu örnekler, yaşın kariyer başarısı için bir engel olmadığını, aksine birikmiş deneyim ve olgunluğun yeni başlangıçlar için güçlü bir zemin oluşturabileceğini kanıtlamaktadır. “Kendini keşfetmek, başarıya giden en büyük adımdır. Hayallerin peşinden gitmek, kendine yapabileceğin en büyük iyiliktir” sözleri, bu dönemdeki bireylerin kendi potansiyellerini fark etmeleri ve cesur adımlar atmaları için güçlü bir motivasyon kaynağıdır. Kariyer değişikliği, bireyin mevcut işindeki mutsuzluğundan kaynaklanabileceği gibi, başka bir alanda daha başarılı olabileceğine dair inançla da tetiklenebilir. Önemli olan, bu değişimin nedenlerini netleştirmek ve kendi becerilerini, ilgi alanlarını doğru bir şekilde analiz etmektir.</p><h3>Yazılım Sektöründe “Alaylı” Olmak: Diploma mı, Yetenek mi?</h3><p>Yazılım sektörü, dünya genelinde dinamik yapısıyla öne çıkan ve geleneksel kariyer yollarını sorgulatan bir alandır. Türkiye’de “alaylı” (kendi kendini yetiştirmiş) yazılımcılar ile üniversite mezunları arasındaki algı farklılıkları, bu sektörün önemli bir tartışma konusudur.</p><p>Türkiye’de, üniversite diplomasına verilen geleneksel önem, alaylı yazılımcılara karşı zaman zaman bir şüphecilik veya “yetersizlik” algısı yaratabilmektedir. Bazı görüşler, yazılımın basit bir iş olmadığını ve herkese iş verilmemesi gerektiğini savunarak, sektöre bir tür “kapı bekçiliği” yapılması gerektiğini ima edebilir. Ancak sektör uzmanları, alaylı yazılımcıların başarılı olabileceğini kabul etmekle birlikte, üniversite mezunlarının belirli avantajlara sahip olduğunu da belirtmektedir. Deneyimli bir yazılımcı, 20 yıllık tecrübesiyle, bilgisayar mühendisliği diplomasının “çok” avantajı olduğunu, ancak başarının asıl kriterlerinin “işini sevmek, sağlam temel bilgiye sahip olmak, bol pratik tecrübe edinmek ve sürekli öğrenmeye açık olmak” olduğunu vurgulamaktadır. Alaylı bireylerin de bilgisayar bilimlerinin temellerini öğrenmeleri halinde kapıların açılacağını belirtiyor. Temel bilgisayar bilimleri bilgisi (algoritmalar, veri tabanları, ağlar, işletim sistemleri gibi) sağlam, kaliteli ve hatasız sistemler geliştirmek için kritik öneme sahiptir.</p><p>Avrupa ve Amerika’daki teknoloji pazarları ise kendi kendini yetiştirmiş geliştiricilere karşı giderek daha açık hale gelmektedir. Almanya’da, 2025 yılı itibarıyla üç yıllık deneyime sahip BT profesyonelleri, üniversite diploması olmadan da iş bulma yeterliliğine sahip olabilmektedir; bu, alaylı geliştiriciler için büyük bir fırsat olarak nitelendirilmektedir. Bu durum, Batı’daki işgücü piyasasının beceri odaklı bir modele doğru kaydığını göstermektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iZXjoXN1WPig2sZxOu33hg.png" /></figure><p>Kodlama bootcamp’leri, bu değişimin önemli bir göstergesidir. 2023 yılında ABD’de 34.000&#39;den fazla bootcamp mezunu işgücü piyasasına girmiş ve bunlar, üniversite diploması olmayan yeni teknoloji işe alımlarının yaklaşık %18&#39;ini oluşturmuştur. Bootcamp mezunlarının %70&#39;inden fazlası altı ay içinde iş bulmuştur. Global ortalama işe yerleştirme oranları %71–79 arasında değişmekte olup, bu oranlar bilgisayar bilimleri lisans derecesi mezunlarının %68&#39;lik ortalama yerleştirme oranını geride bırakmaktadır. Avrupa’da da 2023&#39;te 28.000&#39;den fazla bootcamp mezunu bulunmakta ve Almanya ile Birleşik Krallık bu alanda lider konumdadır.</p><p>Ancak bu durumun bazı nüansları da bulunmaktadır. Avrupa’da, özellikle ABD dışındaki bölgelerde, beceriler genellikle resmi niteliklere veya sertifikalara daha sıkı bir şekilde bağlıdır ve kendi kendine öğrenmeye kıyasla uzun vadeli, resmi eğitim ve çıraklık programlarına daha fazla vurgu yapılabilir. Bu, alaylı geliştiricilerin Avrupa’da iş bulma süreçlerinde hala bazı endişeler taşıyabileceğini göstermektedir.</p><p>Sonuç olarak, yazılım sektöründe başarının anahtarı, öğrenme yolundan bağımsız olarak, temel bilgisayar bilimleri bilgisine hakim olmak ve pratik, projeye dayalı beceriler geliştirmektir. Kendi kendini öğrenme yeteneği, hem teknik hem de sosyal becerilerin güçlü bir göstergesi olarak kabul edilmektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1015/1*NHLCMVf01kHvOFFGkBXIWQ.png" /></figure><p>Bu karşılaştırma, Türkiye’deki yazılım sektörünün alaylı yetenekleri kabul etme konusunda bir ikilem yaşadığını, Batı pazarlarının ise beceri ve pratik deneyime daha fazla öncelik verdiğini ortaya koymaktadır.</p><h3>Kafa Yapıları ve Kültürel Farklar: Bireysellikten Kolektivizme Kariyer Algısı</h3><p>Kariyer algısındaki farklılıklar, Türkiye ile Avrupa ve Amerika arasındaki temel kültürel zihniyet farklılıklarından kaynaklanmaktadır. Bu farklılıklar, Hofstede’nin kültürel boyutları gibi teorilerle daha iyi anlaşılabilir; özellikle bireysellik-kolektivizm ve belirsizlikten kaçınma boyutları, kariyer seçimlerini, risk alma eğilimlerini ve başarı algısını derinden etkiler.</p><p>Türkiye gibi kolektivist kültürlerde , bireyler kendilerini sosyal ilişkilerin bir parçası olarak görür ve eylemleri ile düşünceleri, grup hedefleri ve önemli diğerlerinin beklentileri tarafından büyük ölçüde etkilenir. Bu bağlamda, kariyer seçimleri genellikle aile ve toplumsal beklentilerle uyumlu olmalı, istikrar ve erken başarıya odaklanmalıdır. Geleneksel yollardan sapmak (örneğin, 30&#39;lu yaşlarda kariyer değiştirmek veya alaylı olmak), belirsizliği artırır ve kolektifin (ailenin) itibarı veya finansal güvenliği için bir risk olarak algılanabilir. Doğu kültürlerinde yaygın olan “kadercilik” anlayışı , proaktif, kendi kendine yönelen kariyer planlamasını daha az teşvik edebilir, çünkü her şeyin “olacağına varacağı” inancı, bireyi belirlenmiş, “güvenli” rotalara daha fazla bağımlı kılabilir. Bu durum, kariyer değişikliklerinin “garip karşılanmasına” ve alaylı kişilere karşı şüpheciliğe yol açan toplumsal normları güçlendirebilir.</p><p>Öte yandan, Kuzey Amerika ve Avrupa gibi bireyselci kültürlerde , kişisel hedeflere ve özerkliğe öncelik verilir. Bireylerin kendi kendine yeterliliği ve bağımsızlığı vurgulanır. Bu kültürel yönelim, iş-yaşam dengesine ve yaşam tarzı uyumuna verilen artan değerle uyumludur. Bireyler, kariyer seçimlerini sadece dışsal baskılarla değil, aynı zamanda kişisel tatmin ve değerleriyle uyumlu olup olmadığına göre yapma özgürlüğüne sahiptir. Bu bireyselci yaklaşım, farklı kariyer yollarının, molaların ve değişikliklerin daha kolay kabul edildiği bir ortam yaratır, çünkü bunlar kişisel iradenin ve kendini keşfetmenin bir ifadesi olarak görülür. Başarı tanımı daha genişler ve sadece finansal veya statü odaklı olmaktan çıkarak, kişisel refahı ve değerlerle uyumu da içerir.</p><p>Bu kültürel farklılıklar, kariyer yolculuğunun algılanışını temelden etkiler. Türkiye’deki “koşturmaca,” büyük ölçüde yüksek genç işsizliği ve ekonomik istikrarsızlık gibi dışsal faktörlere karşı bir savunma mekanizması olarak ortaya çıkarken, aynı zamanda kolektivist değerlerin ve belirsizlikten kaçınma eğilimlerinin bir yansımasıdır. Batı’daki esneklik ise, bireyciliğin ve kişisel tatmine verilen önemin bir sonucudur; ancak bu da yaş ayrımcılığı gibi kendi zorluklarını barındırır.</p><p>Ancak bu derin kültürel farklılıklar durağan değildir. Küreselleşme ve modernleşme, toplumların evrimleşmesine yol açmaktadır. Kağıtçıbaşı’nın belirttiği gibi, modernleşme özerklik ve aidiyetin bir karışımına yol açabilir. Türkiye’nin Batı şehirlerinin Avrupa yaşamıyla daha fazla etkileşim içinde olması , zamanla kariyer kültürünün de daha esnek ve çeşitli yollara açık hale gelmesine katkıda bulunabilir. Bu, gelecekte Türkiye’deki kariyer algısının da küresel trendlere daha fazla uyum sağlayabileceği yönünde olumlu bir beklenti yaratmaktadır.</p><h3>Cesaret Veren Hikayeler ve Kendi Yolunu Çizme Rehberi</h3><p>Kendi kariyer yolculuğum, uluslararası ilişkilerden turizme, oradan da kendi kendini yetiştirmiş bir yazılımcılığa uzanan bu dönüşüm, cesaretin, uyum yeteneğinin ve kendi yolunu çizme gücünün bir kanıtıdır. Bu, modern iş dünyasında giderek daha fazla görülen, doğrusal olmayan kariyer yollarının ne kadar değerli olabileceğinin güçlü bir örneğidir.</p><p>Dünya genelinde, benim gibi kendi kendini yetiştirmiş ve farklı alanlardan teknolojiye geçiş yapmış birçok başarılı profesyonel bulunmaktadır. Örneğin, hemşirelik, inşaat mühendisliği, işletme, İngilizce öğretmenliği veya insan kaynakları gibi tamamen farklı geçmişlerden gelen kişiler, kendi çabalarıyla tam zamanlı yazılımcı olmuşlardır. Nadia Zhuk’un İngilizce öğretmenliğinden full-stack geliştiriciliğe geçişi ve Polonya ile Londra’da kariyerini inşa etmesi, aktarılabilir becerilerin ve kültürel engelleri aşmanın mümkün olduğunu göstermektedir. Bu başarı öyküleri, temel bilgisayar bilimleri bilgisine hakim olmanın, sürekli kod yazmanın, ağ kurmanın ve kişisel markayı inşa etmenin önemini vurgulamaktadır.</p><p>Kariyer dönüşümü elbette kolay bir süreç değildir; zaman, çaba ve dayanıklılık gerektirir. Ancak bu süreçte atılacak bilinçli adımlar, başarıya ulaşmada kritik rol oynar. İşte kendi yolunuzu çizerken size rehberlik edebilecek bazı pratik tavsiyeler:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rw5acNMdcIEk7fpFxG3e-w.png" /></figure><ol><li><strong>Kendinizi Keşfedin ve Nedenlerinizi Netleştirin:</strong> Kariyer değişikliği isteğinizin altında yatan temel motivasyonu anlayın. Mevcut işinizdeki mutsuzluk mu, yoksa yeni bir alanda daha büyük bir potansiyel mi görüyorsunuz? Turizmdeki 6 yıllık deneyimim gibi önceki deneyimlerinizden edindiğiniz aktarılabilir becerileri (problem çözme, müşteri ilişkileri, organizasyon yeteneği vb.) belirleyin. Bu farkındalık, süreci bilinçli ve amaç odaklı yönetmenizi sağlar. “Kendini keşfetmek, başarıya giden en büyük adımdır”.</li><li><strong>Stratejik Öğrenme ve Proje Odaklı Gelişim:</strong> Yazılım gibi dinamik bir alanda başarılı olmak için temel bilgisayar bilimleri bilgisine (algoritmalar, veri yapıları, ağlar gibi) sağlam bir şekilde hakim olmak hayati öneme sahiptir. Üniversite diploması olmadan da bu temelleri öğrenmek mümkündür; internette yüzlerce ücretsiz kaynak ve kurs bulunmaktadır. Kendi projelerinizi geliştirerek ve bir portföy oluşturarak pratik becerilerinizi sergileyin. Bu, özellikle Batı teknoloji pazarlarında oldukça değerlidir.</li><li><strong>Ağ Kurma ve Mentorluk:</strong> Hedeflediğiniz sektördeki profesyonellerle bağlantı kurun. LinkedIn gibi platformlar veya sektör etkinlikleri aracılığıyla ağınızı genişletin. Farklı geçmişlere sahip kişilere değer veren profesyonellerle iletişim kurmak, size yeni kapılar açabilir. Bir mentor bulmak, yolculuğunuzda size rehberlik edebilir ve bilgi boşluklarınızı doldurmanıza yardımcı olabilir.</li><li><strong>Sabır ve Gerçekçilik:</strong> Kariyer geçişleri zaman alır ve zorluklarla doludur. Yeni bir alanda uzmanlaşmak veya deneyim kazanmak hemen gerçekleşmeyebilir. Bu süreçte karşılaşacağınız engeller sizi yıldırmamalıdır. “Başarısızlığa uğrayabilirsiniz, ama yılmamalısınız”. Hedeflerinize ulaşmak için sabırlı olun ve sürekli öğrenmeye ve gelişmeye odaklanın.</li><li><strong>Küresel Fırsatları Değerlendirin:</strong> Uzaktan çalışma fırsatlarını veya uluslararası hareketliliği araştırın. Özellikle Avrupa ve Amerika’da kendi kendini yetiştirmiş profesyonellere ve esnek çalışma düzenlemelerine olan kabul artmaktadır. Bu, Türkiye’deki geleneksel algıların ötesine geçerek yeteneklerinizin daha geniş bir pazarda değer bulmasını sağlayabilir.</li></ol><p>Kendi kendini öğrenme yeteneği, hem teknik hem de sosyal becerilerin en güçlü göstergelerinden biridir. Sizin gibi bireylerin “projeler ve eğitimlerle” kendilerini geliştirmeleri, günümüzün hızla değişen iş dünyasında sadece geçerli değil, aynı zamanda geleceğe yönelik stratejik bir yaklaşımdır.</p><h3>Kendi Değerini Bilmek ve Geleceği Şekillendirmek</h3><p>Kariyer yolculuğu, günümüzde giderek daha akışkan ve kişiselleştirilmiş bir hal almaktadır. Geleneksel, yaşa bağlı ve doğrusal kariyer çizgileri, yerini daha esnek, çok yönlü ve bireysel tercihlere dayalı yollara bırakmaktadır. Türkiye’de hissedilen “koşturmaca” ve “geç kalmışlık” algısı, ülkenin kendine özgü sosyo-ekonomik ve kültürel dinamiklerinden kaynaklansa da, bu durum küresel eğilimlerle çelişmektedir.</p><p>Bu analiz, yaşın sadece bir sayı olduğunu ve 30&#39;lu yaşların, hatta daha ilerisinin, kariyerde yeni başlangıçlar için geç değil, aksine olgunluk, deneyim ve daha net bir amaç duygusuyla dolu güçlü bir dönem olduğunu açıkça ortaya koymaktadır. Jeff Bezos, Vera Wang ve Colonel Sanders gibi ikonik isimlerin hikayeleri, bu gerçeğin en somut kanıtlarıdır. Önceki deneyimleriniz, farklı bir alandan gelmiş olsanız bile, yeni kariyerinizde değerli birer varlık haline gelebilir.</p><p>Yazılım sektörü özelinde, Türkiye’de alaylı yeteneklere karşı hala bazı önyargılar bulunsa da, Avrupa ve Amerika’daki trendler, beceri ve pratik deneyimin resmi diplomaların önüne geçtiğini göstermektedir. Kodlama bootcamp’lerinin başarısı ve bazı ülkelerde diploma şartının kalkması, kendi kendini yetiştirmiş profesyoneller için uluslararası kapıları ardına kadar açmaktadır.</p><p>En nihayetinde, kariyer başarısının temelinde yatan en önemli faktörler, tutku, öğrenme arzusu ve sürekli kendini geliştirmedir. Değişim, bireyin kendi içinde başlar ve kendi değerini bilmek, dışsal toplumsal baskılara karşı en güçlü panzehirdir. Kendi yolunuzu çizmek, kendi başarı tanımınızı oluşturmak ve geleceği kendi koşullarınızla şekillendirmek, günümüz dünyasında sadece bir seçenek değil, aynı zamanda uzun vadeli kariyer dayanıklılığı ve kişisel tatmin için stratejik bir yaklaşımdır. Unutmayın, “hayallerin peşinden gitmek, kendine yapabileceğin en büyük iyiliktir”.</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9a80d2966556" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Kurumsal Java Uygulamalarına CUDA Entegrasyonu İle GPU Düzeyinde Performans Arttırma ]]>
</title>
<link>https://pehlivanmert.medium.com/kurumsal-java-uygulamalar%C4%B1na-cuda-entegrasyonu-i%CC%87le-gpu-d%C3%BCzeyinde-performans-getirmek-072e32246444?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/072e32246444</guid>
<category>
<![CDATA[ performance ]]>
</category>
<category>
<![CDATA[ cuda ]]>
</category>
<category>
<![CDATA[ java ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 20 Jun 2025 02:25:26 GMT</pubDate>
<atom:updated>2025-06-20T05:09:23.936Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vNV3Toh2Mn0wPF-2q5Si3g.png" /></figure><p>Kurumsal yazılım dünyasında Java, güvenilirliği, taşınabilirliği ve zengin ekosistemi sayesinde hala baskın bir konumda bulunmaktadır. Büyük şirketlerin altyapılarının temelini oluşturan bu dil, sürekli gelişen kütüphaneleri ve güçlü sanal makinesi (JVM) ile geniş bir kullanım alanına sahiptir. Ancak, modern uygulamaların artan düşük gecikme süresi ve yüksek verim talepleri, özellikle gerçek zamanlı analiz, büyük günlük işlem hatları veya derin hesaplama gerektiren yüksek performanslı hesaplama (HPC) veya veri yoğun operasyonlarda Java&#39;nın yönetilen çalışma zamanı ve çöp toplama (garbage collection) yükü bazı zorluklar yaratmaktadır.</p><p>Bu zorluklar devam ederken, başlangıçta görüntü işleme için tasarlanan Grafik İşlem Birimleri (GPU&#39;lar), günümüzde paralel hesaplama için güçlü hızlandırıcılar olarak öne çıkmıştır. NVIDIA&#39;nın geliştirdiği CUDA gibi teknolojiler, geliştiricilerin GPU&#39;ların muazzam gücünden yararlanmasını sağlayarak, hesaplama yoğun görevler için önemli hızlanmalar elde etmelerine olanak tanır. Bir CPU&#39;nun en fazla düzinelerce çekirdeği varken, bir GPU binlerce hafif iş parçacığını paralel olarak çalıştırabilir ; bu da veri-paralel iş yükleri için eşsiz bir avantaj sunar.</p><p>CUDA, öncelikli olarak C/C++ gibi düşük seviyeli diller için tasarlanmış olsa da, Java geliştiricilerinin bu uyumsuzluğu aşması ve GPU hızlandırmasını Java uygulamalarına entegre etmesi mümkündür. Bu makale de, GPU düzeyinde hızlandırmanın Java uygulamaları için ne anlama geldiğini, eşzamanlılık modelleri arasındaki temel farkları, pratik entegrasyon yollarını (JNI, JCuda vb.), somut bir kullanım senaryosunu ve kurumsal kullanıma yönelik en iyi uygulamaları inceleyerek benim gibi Java geliştiricilerine pratik bir rehber sunmayı amaçlamaktayım.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LJxg_p6dTG68clgkWBz4fA.png" /></figure><h3>Temel Kavramları Anlamak: Çoklu İş Parçacığı, Eşzamanlılık, Paralellik ve Çoklu İşlem</h3><p>GPU entegrasyonuna girmeden önce, Java geliştiricilerinin yaygın olarak kullandığı farklı yürütme modellerini net bir şekilde anlamak önemlidir. Bu kavramlar genellikle birbirinin yerine kullanılsa da, belirgin farklılıkları bulunmaktadır. Bu ayrımları kavramak, CUDA tabanlı hızlandırmanın nerede gerçekten işe yaradığını anlamaya yardımcı olacaktır.</p><h3>Java Dünyasında Bu Kavramların Yeri ve Farkları</h3><ul><li><strong>Çoklu İş Parçacığı (Multithreading):</strong> Bir CPU&#39;nun veya tek bir işlemin, aynı bellek alanı içinde birden fazla iş parçacığını eşzamanlı olarak yürütme yeteneğidir. Java&#39;da bu genellikle Thread ve Runnable sınıfları veya ExecutorService gibi daha gelişmiş yapılar kullanılarak elde edilir. İş parçacıkları hafif ve hızlı başlatılabilir olsa da, tüm iş parçacıkları aynı yığın belleği paylaştığı için yarış koşulları, kilitlenmeler ve iş parçacığı çekişmesi gibi sorunlara yol açabilir. Bu durum, performans kazanımlarını sınırlayabilir ve karmaşık senkronizasyon mekanizmaları gerektirebilir.</li><li><strong>Eşzamanlılık (Concurrency):</strong> Birden fazla görevin zaman içinde ilerlemesini sağlama, tek bir çekirdekte dönüşümlü olarak veya çekirdekler arasında paralel olarak çalıştırma yeteneğidir. Eşzamanlılık, görevlerin aynı anda tamamlanması yerine, görev yürütmesini orkestre etmekle ilgilidir. Java, java.util.concurrent paketi ile eşzamanlılığı destekler ve geliştiricilere görevleri yönetmek için güçlü araçlar sunar.</li><li><strong>Paralellik (Parallelism):</strong> Birden fazla görevin aynı anda yürütülmesidir. Gerçek paralellik, birden çok CPU çekirdeği veya yürütme birimi gibi donanım desteği gerektirir. Java, Fork/Join framework&#39;ü gibi araçlarla destek sağlar, ancak CPU tabanlı paralellik nihayetinde çekirdek sayısı ve bağlam değiştirme yükü ile sınırlıdır. Bir uygulamanın performansı, görevlerin ne kadar etkili bir şekilde paralelleştirildiğine bağlıdır.</li><li><strong>Çoklu İşlem (Multiprocessing):</strong> Her biri kendi bellek alanına sahip birden fazla işlemin, ayrı CPU çekirdeklerinde paralel olarak çalıştırılmasını içerir. Bu model, çoklu iş parçacığından daha izole ve sağlamdır, çünkü her işlem kendi bellek alanına sahiptir, bu da veri çakışması riskini azaltır. Ancak, süreçler arası iletişim ve bağlam değiştirme nedeniyle daha fazla yükü vardır. Java&#39;da gerçek çoklu işlem genellikle ayrı JVM&#39;ler başlatmak veya işi mikro hizmetlere devretmek anlamına gelir.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OeVxDztmJYoFG50BnbtDQw.png" /></figure><h3>CUDA&#39;nın Bu Modeller İçinde Nerede Parladığı: Büyük Veri Paralelliği</h3><p>Yukarıdaki tüm modeller büyük ölçüde CPU çekirdeklerine dayanırken, GPU&#39;lar binlerce hafif iş parçacığını paralel olarak çalıştırabilir. Bir CPU en fazla düzinelerce çekirdeğe sahipken, bir GPU binlerce küçük, uzmanlaşmış çekirdeğiyle aynı anda yüzlerce veya binlerce görevi ele alabilir. CUDA, matris işlemleri, görüntü işleme, toplu günlük dönüştürme veya maskeleme ve gerçek zamanlı veri analizi gibi görevler için ideal olan bu devasa veri-paralel yürütme modelinden yararlanmanızı sağlar. Bu tür minik taneli, veri düzeyinde paralellik, standart Java çoklu iş parçacığı ile neredeyse imkansızdır; bu da CUDA&#39;nın kurumsal uygulamalara gerçek değer kattığı yerdir. GPU&#39;lar, aynı işlemi birden fazla veri noktasına eşzamanlı olarak uygulayan Tek Talimat, Çoklu Veri (SIMD) modeli altında çalışır.</p><h3>CUDA ve Java: Entegrasyonun Temelleri</h3><p>Java geliştiricileri geleneksel olarak JVM&#39;nin güvenli, yönetilen dünyasında, donanım düzeyinde optimizasyonun daha düşük seviyeli endişelerinden uzakta çalışırlar. CUDA ise, belleği dikkatlice yöneterek, binlerce iş parçacığı başlatarak ve GPU kullanımını maksimize ederek performansın elde edildiği çok farklı bir dünyada yer alır.</p><h3>CUDA Nedir ve Neden Java ile Doğal Uyumlu Değil?</h3><p>Compute Unified Device Architecture (CUDA), NVIDIA&#39;nın geliştiricilerin NVIDIA GPU&#39;larında büyük ölçekli paralel yürütme için yazılım yazmasına olanak tanıyan paralel bilgi işlem platformu ve API modelidir. Tipik olarak C veya C++ aracılığıyla kullanılır ve GPU&#39;da paralel çalışan <strong>çekirdekler (kernels)</strong> olarak adlandırılan fonksiyonlar yazılır.</p><p><strong>CUDA&#39;nın güçlü olduğu alanlar:</strong></p><ul><li>Veri-paralel iş yükleri (örneğin, görüntü işleme, finansal simülasyonlar, günlük dönüşümleri).</li><li>Binlerce iş parçacığıyla minik taneli paralellik.</li><li>Hesaplama yoğun işlemler için geliştirilmiş hızlanma süreleri.</li></ul><p><strong>Java&#39;nın CUDA ile doğal uyumlu olmamasının nedenleri:</strong></p><ul><li>JVM&#39;nin GPU belleğine veya yürütme işlem hatlarına doğrudan erişimi yoktur.</li><li>Çoğu Java kütüphanesi CPU ve iş parçacığı tabanlı eşzamanlılık düşünülerek tasarlanmıştır.</li><li>Java&#39;nın bellek yönetimi (çöp toplama, nesne yaşam döngüsü) GPU dostu değildir.</li></ul><p>Ancak doğru araçlarla bu engeller aşılabilir.</p><h3>Mevcut Entegrasyon Seçenekleri</h3><p>Aşağıda, Java-CUDA entegrasyonu için mevcut seçeneklerin detaylı bir karşılaştırması yer almaktadır.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VuIuLobhx11I9N5EkbdEvg.png" /></figure><h3>Pratik Entegrasyon Adımları: Java&#39;dan CUDA Çağırmak</h3><p>Java ve CUDA&#39;nın çalışma zamanında nasıl etkileşim kurduğunu anlamak için temel bileşenler ve veri akışı incelenmelidir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NDm5d2UXiNT4mmTzD4IYlg.png" /></figure><h3>Her Katmanın Rolü</h3><ul><li><strong>Java Uygulama Katmanı:</strong> Bu, standart bir Java servisidir (örn: bir günlükleme çerçevesi). İşlem yoğun iş yükleri, geleneksel iş parçacığı havuzları yerine yerel çağrılarla GPU&#39;ya aktarılır. Bu katman, girdi verilerini hazırlamak, JNI çağrılarını tetiklemek ve sonuçları entegre etmekten sorumludur. Örneğin, saniyede binlerce kullanıcı oturumu için SSH tarzı şifreleme veya güvenli anahtar karma işlemleri GPU&#39;ya aktarılabilir, böylece CPU G/Ç ve orkestrasyon için serbest kalır.</li><li><strong>JNI Köprüsü:</strong> JNI, Java ile CUDA mantığını içeren yerel C++ kodu arasında bir köprü görevi görür. Yerel yöntemleri bildirir, paylaşılan kütüphaneleri (.so, .dll) yükler ve bellek aktarımını yönetir. Genellikle ilkel diziler verimli veri aktarımı için kullanılır. Bellek yönetimi, tür dönüşümü, savunmacı programlama ve kaynak temizliği bu katmanda kritik öneme sahiptir çünkü hatalar JVM&#39;i çökertebilir.</li><li><strong>CUDA Çekirdekleri (C/C++):</strong> Paralel işlemlerin gerçekleştiği yerdir. Bunlar, binlerce GPU iş parçacığında eşzamanlı çalışmak üzere tasarlanmış hafif C tarzı fonksiyonlardır. .cu dosyalarında yazılır ve &lt;&lt;&lt;bloklar, iş parçacıkları&gt;&gt;&gt; sözdizimi ile başlatılır. Her çekirdek, JNI&#39;dan gelen veriler üzerinde büyük paralel işlemler (örn: şifreleme, karma) gerçekleştirir.</li><li><strong>GPU Yürütme:</strong> Çekirdek başlatıldıktan sonra, CUDA iş parçacığı zamanlamasını ve bellek yönetimini üstlenir. Ancak performans ayarı, blok/iş parçacığı boyutlandırması ve cudaGetLastError() gibi API&#39;lerle hata işleme gibi manuel çabalar gerektirir. Bu katman, çalışma zamanı performansı ve hata izolasyonunda kritik bir rol oynar.</li><li><strong>Geri Dönüş Akışı:</strong> İşlemden sonra sonuçlar JNI katmanına geri döner ve oradan Java uygulamasına iletilir. Bu veriler daha sonra bir veritabanına kaydedilebilir veya başka bir sisteme gönderilebilir.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8Al8aqtwJB6baMsMnCPGRQ.png" /></figure><h3>Kurumsal Kullanım Durumu: Ölçeklenebilir Toplu Veri Şifreleme</h3><p>GPU hızlandırmanın etkisini göstermek için pratik bir senaryo olan büyük ölçekli toplu veri şifrelemesi incelenebilir. Birçok arka uç sistemi, yüksek verimle karma veya şifreleme gerektiren hassas bilgileri (kullanıcı kimlik bilgileri, API anahtarları vb.) rutin olarak işler.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qd9AW6rLgHagjnlQ-nn5EQ.png" /></figure><h3>Neden Şifreleme GPU İçin İdeal?</h3><p>Geleneksel Java kütüphaneleri (javax.crypto, Bouncy Castle) CPU&#39;ya bağlıdır ve yüksek verimli ortamlarda yetersiz kalabilir. GPU&#39;lar ise bu iş yükü için uygundur çünkü şifreleme/karma mantığı (örn: SHA-256) durumsuz, tekdüze ve yüksek derecede paralelleştirilebilirdir. Her veri parçasının işlenmesi diğerlerinden bağımsızdır, bu da iş parçacıkları arası iletişime gerek olmadığı anlamına gelir. Bu tür iş yükleri, tek iş parçacıklı uygulamalara göre 50 kata kadar gecikme iyileştirmesi sağlayabilir.</p><h3>Performans Karşılaştırması</h3><p>Aşağıdaki sentetik kıyaslama, GPU hızlandırmasının potansiyelini göstermektedir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4ec7o6RAZJ9Rh6pCqE42kA.png" /></figure><h3>Gerçek Dünya Faydaları</h3><p>Şifreleme iş yüklerini GPU&#39;ya aktarmak, CPU kaynaklarını uygulama mantığı ve G/Ç için serbest bırakır. Bu desen, güvenli API ağ geçitleri veya belge işleme hatları gibi sistemlerde iyi çalışır. Bu kullanım durumu, GPU&#39;ların yalnızca AI ile sınırlı olmadığını, genel amaçlı veri-paralel görevler (güvenli veri işleme, finansal simülasyonlar) için de son derece etkili olduğunu göstermektedir.</p><h3>En İyi Uygulamalar ve Tuzaklar: Üretime Hazırlama</h3><p>Java&#39;yı CUDA ile entegre etmek güçle birlikte karmaşıklık da getirir. Güvenilir, sürdürülebilir ve güvenli sistemler kurmak için aşağıdaki hususlar kritiktir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-t5R-3Ym8GR8O-D7yLapFA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*doKfj5PkTwYoj24-G9gmEA.png" /></figure><h4>Bellek Yönetimi</h4><p>CUDA, Java&#39;nın aksine açık bellek yönetimi gerektirir. GPU belleğini serbest bırakmayı unutmak sisteminizi çökertebilir.</p><ul><li>GPU belleğini açıkça yönetmek için cudaMalloc() ve cudaFree() kullanın.</li><li>Her JNI giriş noktasının bir temizleme adımına sahip olduğundan emin olun.</li><li>Bellek tahsis hatalarını cudaMalloc&#39;un dönüş durumlarını kontrol ederek yakalayın ve cuda-memcheck gibi araçlar kullanın.</li></ul><h4>Veri Aktarımı (Data Marshalling)</h4><p>Java ve C/C++ arasında veri aktarımı ciddi bir performans darboğazı olabilir.</p><ul><li>Karmaşık Java nesneleri yerine ilkel diziler kullanın.</li><li>Düşük gecikmeli erişim için GetPrimitiveArrayCritical() kullanın.</li><li>Dize kodlama farklılıklarına dikkat edin (Java&#39;nın UTF-8&#39;i vs. C tarzı dizeler).</li><li>Yükü en aza indirmek için yerel arabellekleri bir kez tahsis edip yeniden kullanın.</li></ul><h4>İş Parçacığı Güvenliği (Thread Safety)</h4><p>Çoğu Java servisi çok iş parçacıklıdır, bu da yerel koda çağrı yaparken risk oluşturur.</p><ul><li>JNI arayüzünüzü durumsuz olacak şekilde tasarlayın.</li><li>GPU akışları ve JNI tanıtıcıları iş parçacıkları arasında paylaşılmamalıdır.</li><li>Java&#39;nın synchronized blokları idareli kullanılmalıdır.</li></ul><h4>Yerel Kod Testi ve Hata Ayıklama</h4><p>Yerel koddaki bir çökme tüm JVM&#39;i sonlandırabilir.</p><ul><li>cudaGetLastError() gibi CUDA hata kontrol API&#39;lerini tutarlı bir şekilde kullanın.</li><li>cudaDeviceSynchronize() ile eşzamansız hataları yakalamak için güvenilir kontrol noktaları oluşturun.</li><li>NVIDIA Nsight gibi hata ayıklama araçları kullanın.</li></ul><h4>Güvenlik ve İzolasyon</h4><p>Yerel kod, tehdit yüzeyinizin bir parçasıdır.</p><ul><li>JNI&#39;yi çağırmadan önce Java tarafındaki girdileri her zaman doğrulayın.</li><li>CUDA çekirdekleri içinde dinamik bellek tahsisinden kaçının.</li><li>Saldırı yüzeyini küçültmek için yerel modüllerdeki bağımlılıkları en aza indirin.</li></ul><h4>Dağıtım ve Taşınabilirlik</h4><p>GPU hızlandırmalı kodu dağıtmak, sadece bir JAR paketlemekten daha fazlasıdır. GPU sürücü uyumluluğu, CUDA çalışma zamanı bağımlılıkları ve işletim sistemi farklılıkları gibi konuları ele almanız gerekir. Tutarlılık için CMake gibi derleme araçları kullanmak ve dağıtımları nvidia-docker ile kapsayıcı hale getirmek en iyisidir.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hygt0PtGKXiQf3cZ4GuPjw.png" /></figure><h3>Sonuç ve Gelecek</h3><p>Java ve CUDA&#39;nın birleşimi henüz ana akım olmasa da, kurumsal sistemler için yeni bir performans sınıfının kapılarını aralamaktadır. Bu entegrasyon, CPU&#39;ların tek başına eşleşemeyeceği hızlanmalar sunmaktadır.</p><h3>Neden Bu Önemli?</h3><p>Java geliştiricileri artık sadece iş parçacığı havuzları ile sınırlı değildir. CUDA&#39;ya köprü kurarak, tüm yığını yeniden yazmadan HPC tarzı yürütmeyi standart kurumsal sistemlere taşıyabilirler.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Tl7r4zJalGbw4_0W6h4MCQ.png" /></figure><ul><li><strong>Hibrit CPU-GPU Zamanlama Modelleri:</strong> İş yüklerini CPU ve GPU arasında dinamik olarak dengeleyebilen hibrit zamanlama stratejileri üzerine araştırmalar devam etmektedir. &quot;HybriMoE&quot; gibi çerçeveler, bu dengelemeyi ve önbellek yönetimini iyileştirmek için algoritmalar sunmaktadır.</li><li><strong>ONNX Tabanlı AI Model Çıkarımı (Inference):</strong> Yapay zeka modellerinin GPU&#39;larda çalıştırılması giderek daha önemli hale gelmektedir. ONNX (Open Neural Network Exchange), farklı makine öğrenimi çerçevelerinden modelleri temsil etmek için bir standart sunar. Microsoft&#39;un ONNX Runtime&#39;ı, bu modelleri JVM üzerinde çalıştırmak için bir Java bağlaması sağlar, bu da PyTorch veya TensorFlow&#39;da eğitilmiş modellerin Java uygulamalarına kolayca entegre edilmesini sağlar.</li><li><strong>Foreign Function &amp; Memory API (JEP 454) Benimsenmesi:</strong> JNI&#39;nin yerini alması beklenen bu API, yerel kütüphaneleri çağırmak için daha güvenli ve modern bir yaklaşım sunmaktadır. Bellek güvenliğini (sınır dışı erişim ve use-after-free hatalarını önleyerek) ve kullanım kolaylığını artırırken, JNI&#39;ye benzer veya daha iyi performans hedeflemektedir. Java 24&#39;te JNI kullanımına ilişkin uyarıların başlaması, bu yeni API&#39;nin gelecekte standart olacağını göstermektedir. Geliştiricilerin bu API&#39;yi yakından takip etmeleri büyük önem taşımaktadır.</li></ul><p>Bu gelişmeler, Java&#39;nın yüksek performanslı bilgi işlem alanındaki yeteneklerini daha da genişletecektir.</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=072e32246444" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Java ve Yapay Zeka: Yeni Dönemin Kapıları Aralanıyor mu? ]]>
</title>
<link>https://pehlivanmert.medium.com/java-ve-yapay-zeka-yeni-d%C3%B6nemin-kap%C4%B1lar%C4%B1-aralan%C4%B1yor-mu-facc0a6d77c8?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/facc0a6d77c8</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 18 Jun 2025 01:07:20 GMT</pubDate>
<atom:updated>2025-06-20T05:12:08.264Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qBWnKbUvnfLp74YIbEmkig.png" /></figure><p>Son dönemde Yapay Zeka (YZ) alanındaki hızlı gelişmeler, sektörün gündemini belirliyor. Genellikle Python ile özdeşleştirilen YZ geliştirme süreçleri, Java platformunda da dikkat çekici ilerlemeler kaydediyor. Oracle’ın “Java for AI” sunumu, bu konudaki mevcut ve gelecekteki çalışmaları oldukça detaylı bir şekilde ele alıyor. Bir yazılımcı olarak bu yenilikleri keşfetmek oldukça heyecan vericiydi ve sizinle de paylaşmak istedim.</p><p>Java, yüksek performans ve geliştirici verimliliği gibi temel özellikleriyle bilinen, genel amaçlı bir programlama platformu. Bu güçlü yanlar, YZ’nın özel gereksinimlerini karşılamak üzere titizlikle adapte ediliyor. Sunumda da belirtildiği gibi, platforma eklenen yenilikler sadece YZ odaklı değil, aynı zamanda daha geniş kullanım alanlarına hitap ediyor; bu da Java’nın uzun soluklu başarısının ardındaki temel felsefelerden biri.</p><h3>Java’nın YZ İçin Öne Çıkan Özellikleri</h3><p>Sunumda, YZ geliştirmeleri için kritik kabul edilen dört temel Java platformu özelliği tanıtılıyor:</p><ul><li>Foreign Function and Memory API (Proje Panama): Java dışındaki belleği (off-heap memory) daha verimli kullanmayı ve yerel kütüphanelerle etkileşimi güvenli, hızlı ve üretken bir hale getirmeyi sağlıyor. Özellikle sıfır kopyalama senaryolarında bu özellik kritik öneme sahip.</li><li>Vector API (Proje Panama): Java’da SIMD (Single Instruction, Multiple Data) programlamayı mümkün kılarak CPU’nun etkin kullanımını sağlıyor. YZ ve makine öğrenimi algoritmaları için temel olan sayısal hesaplamaları (örneğin nokta çarpımı) ciddi oranda hızlandırıyor.</li><li>Value Classes and Objects (Proje Valhalla): Yığın içi (on-heap) belleğin optimal kullanımını hedefliyor ve Float16, Bfloat16 gibi YZ’da sıkça kullanılan yeni sayı türlerinin platforma entegrasyonunu kolaylaştıracak.</li><li>Code Reflection (Proje Babylon): GPU’lar (CUDA) veya ONNX gibi farklı programlama modelleriyle etkileşimi mümkün kılıyor. Java kodunun otomatik türevini (auto-differentiation) destekleyerek, platformun bu tür spesifik detayları kütüphanelere devretmesini sağlıyor, bu da geliştiricilere esneklik sunuyor.</li></ul><h3>Mevcut Durum ve Gelecek Potansiyeli</h3><p>YZ model geliştirmenin büyük bir kısmı şu anda Python’da yoğunlaşmış durumda. Ancak sunumda bahsedilen özelliklerin Java’yı YZ ekosisteminde daha rekabetçi bir konuma getirme potansiyeli dikkat çekici. Bu özellikler olmadan da YZ çözümleri geliştirilebilir; ancak sunuma göre, bu yeni araçlar tasarım, geliştirme, sürdürme ve evrim süreçlerini önemli ölçüde kolaylaştırıyor.</p><p>Sunumda, yeni özelliklerin pratik uygulamalarını gösteren çarpıcı örneklere de yer veriliyor:</p><ul><li>Llama Model Çıkarımı: FFM ve Vector API kullanılarak Java’da Llama 2 modelinin performansındaki artış (1.3 tokenden ~15 token/saniyeye) göz dolduruyor.</li><li>Anomali Tespiti (MSET 2): Matris API, FFM API ve Vector API kullanarak Java’da uygulanan bu algoritmanın, CUDA, MATLAB ve Python/NumPy implementasyonlarından daha iyi performans gösterdiği ve halihazırda üretimde kullanıldığı belirtiliyor.</li><li>ONNX Script for Java: Code Reflection ve FFM API kullanarak Java kodundan ONNX makine öğrenimi modelleri oluşturma yeteneği sergileniyor.</li></ul><h3>Kilit Bilgiler ve Daha Fazlası</h3><ul><li>Proje Panama (FFM ve Vector API) Java 22&#39;den itibaren kullanılabilir durumda (FFM API final sürümde, Vector API ise halen geliştirme aşamasında).</li><li>Proje Valhalla ve Proje Babylon ise aktif olarak geliştirilmeye devam eden gelecek vaat eden özellikler.</li><li>Java’nın YZ alanındaki bu yenilikleri, temel olarak bellek kullanımını optimize etmeyi, donanım kullanımını verimli hale getirmeyi, yerel kodlarla etkileşimi güçlendirmeyi ve yeni sayı türlerini desteklemeyi hedefliyor.</li></ul><p>Tüm bu gelişmeler ışığında, Java platformunun YZ, yüksek performanslı hesaplama ve büyük veri alanlarındaki zorlukları ele almak için dinamik bir gelişim içinde olduğunu söyleyebiliriz. Bu özellikler, Java’da performans odaklı YZ çözümleri oluşturma potansiyelini artırıyor.</p><p>Bu konuya daha derinlemesine bakmak isterseniz, ilgili <a href="https://www.youtube.com/watch?v=-XnyJad88Ss&amp;t=2s">Oracle OpenJDK topluluğu sunumunu</a> izlemenizi şiddetle tavsiye ederim. Gerçekten ufuk açıcı bilgiler içeriyor.</p><p>Siz bu gelişmeler hakkında ne düşünüyorsunuz? Java’nın YZ ekosistemindeki yeri gelecekte nasıl şekillenebilir?</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=facc0a6d77c8" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Gelecek Kapımızda: Yapay Zekâ Yazılımcıların Sonunu Mu Getirecek, Yoksa Yeni Bir Çağ Mı Başlatacak? ]]>
</title>
<link>https://pehlivanmert.medium.com/gelecek-kap%C4%B1m%C4%B1zda-yapay-zek%C3%A2-yaz%C4%B1l%C4%B1mc%C4%B1lar%C4%B1n-sonunu-mu-getirecek-yoksa-yeni-bir-%C3%A7a%C4%9F-m%C4%B1-ba%C5%9Flatacak-4235efc6f12b?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4235efc6f12b</guid>
<category>
<![CDATA[ development ]]>
</category>
<category>
<![CDATA[ ai ]]>
</category>
<category>
<![CDATA[ developer-tools ]]>
</category>
<category>
<![CDATA[ developer ]]>
</category>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 04 Jun 2025 16:39:51 GMT</pubDate>
<atom:updated>2025-06-20T05:12:30.301Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j76ggknKxckfMfZssQgy1g.png" /></figure><p>Son yıllarda yapay zekâ (YZ) rüzgarı, yazılım geliştirme dünyasında fırtınalar estiriyor. Kod tamamlama, otomatik hata düzeltme gibi YZ destekli araçlar sayesinde projelerimiz hızla şekilleniyor; Copilot gibi yardımcılar işlerimizi %55&#39;e varan oranlarda hızlandırabiliyor. Birçoğumuz bu devrimi kucaklayarak verimliliğimizin arttığını görüyoruz. Ancak, bir kesim yazılımcı hâlâ endişeli: Ya YZ, işimizi tamamen elimizden alırsa?</p><p>Endişelerin aksine, PwC’nin 2025 YZ İş Barometresi bize umut veriyor: YZ’nin etkilediği pek çok meslekte hem istihdam hem de ücret seviyeleri artış gösteriyor. Peki, yazılımcıların geleceği nasıl şekillenecek? Gelin, bu sorunun kısa ve uzun vadeli etkilerine yakından bakalım.</p><h3>Kısa Vadede Yazılımcılar İçin Fırsatlar ve Zorluklar</h3><h4>Yeni Başlayanlar ve Junior Geliştiriciler: Öğrenme ve Adaptasyon Vakti!</h4><p>Junior yazılımcılar için YZ araçları gerçek bir oyun değiştirici. StackOverflow anketine göre, kod yazmayı öğrenenlerin %82&#39;si YZ araçlarını kullanıyor veya kullanmayı planlıyor. Bilimsel çalışmalar da gösteriyor ki, Copilot gibi araçlar özellikle deneyimsiz geliştiricilere büyük fayda sağlıyor. Rutin kodlama görevlerini hızla halletmelerine olanak tanırken, temel becerilerini pekiştirmelerine yardımcı oluyor.</p><p>Ancak dikkat! YZ’nin ürettiği kodun doğruluğunu ve kalitesini kontrol etme, algoritma mantığını kavrayarak kodu denetleme sorumluluğu hâlâ juniorların omuzlarında. Bu, kısa vadede onlar için muazzam bir öğrenme fırsatı sunarken, aynı zamanda YZ önerilerine temkinli yaklaşmayı öğrenmeleri gerektiği anlamına geliyor.</p><h4>Orta Seviye Geliştiriciler: Verimlilikte Vites Artırma Zamanı!</h4><p>Profesyonel yazılımcıların %70&#39;i kısa vadede YZ araçlarını kullanmaya başlamış veya planlıyor. Orta seviye geliştiriciler, deneyimleri sayesinde YZ’nin kod önerilerini eleştirel bir gözle değerlendirip, sadece tekrarlı işleri hızlandırmak için kullanabilirler. YZ, bu grup için zaman alan ve tekrarlayan işleri otomatikleştirerek, onları daha karmaşık problemlere ve mimari tasarıma odaklanmaya teşvik edecek. Böylece hem verimlilik kazanacaklar hem de üst düzey görevlerle birlikte yönetim becerilerini geliştirme imkanı bulacaklar.</p><h4>Kıdemli (Senior) Geliştiriciler: Stratejik Liderlik Ön Planda!</h4><p>Deneyimli yazılımcılar, genellikle mimari tasarım, ekip yönetimi ve karmaşık problem çözme gibi kritik roller üstlenirler. Copilot ile yapılan deneyler, özellikle 25–44 yaş arası geliştiricilerin YZ araçlarından önemli ölçüde fayda sağladığını gösteriyor. Kısa vadede kıdemli geliştiriciler, tekrarlı kodlama işleriyle uğraşmak yerine, ekiplerine rehberlik etmeye, süreçleri iyileştirmeye ve yeni teknolojileri entegre etmeye odaklanacaklar. YZ onlara zaman kazandırırken, asıl katma değer yaratan karmaşık işlerin sorumluluğu yine kıdemli ekibin üzerinde kalacak.</p><h3>Uzun Vadede Yazılımcılar İçin Büyük Dönüşümler</h3><h4>Yeni Başlayanlar ve Junior Geliştiriciler: Sürekli Öğrenmenin Önemi</h4><p>Uzun vadede, YZ’nin kod üretme yeteneğinin artmasıyla juniorların rollerinde köklü değişiklikler görülebilir. Bir çalışma, 2040&#39;ta makinelerin kendi kodlarının çoğunu yazabileceğini öngörüyor. Ancak endişelenmeyin! Bu senaryoda bile geliştiricilerin tamamen ortadan kalkmayacağı tahmin ediliyor; çünkü insanların özellikle <strong>veri hazırlama, algoritma tasarımı ve sistem entegrasyonu</strong> gibi alanlara odaklanması gerekecek.</p><p>Zaten yazılımcılar olarak sürekli öğrenmeye alışkın bir grubuz; 2015–2022 arasında gerekli becerilerin %30&#39;dan fazla değiştiğini görüyoruz. Türkiye’de de geleceğe yönelik raporlar, çalışanların %59&#39;unun yeniden eğitime ihtiyaç duyacağını vurguluyor. Kısacası, junior geliştiriciler için uzun vadeli yol haritası, YZ ile çalışmayı öğrenmek ve sürekli yeni beceriler kazanmak üzerine kurulu olacak.</p><h4>Orta Seviye Geliştiriciler: Liderliğe ve Yaratıcılığa Doğru!</h4><p>Geçmişteki teknolojik devrimler yeni uzmanlıklar ve iş alanları yaratarak yazılımcı talebini artırdı. Benzer şekilde, yazılım geliştirme dünyası 2030 ve ötesine evrildikçe, kodun bir kısmının YZ’ye devredilmesi beklense de geliştiricilere her zaman ihtiyaç duyulacak. YZ destekli otomasyon rutin işleri üstlenirken, yüksek düzeyde <strong>yaratıcılık ve problem çözme</strong> gerektiren görevler insanlara bırakılacak. Orta düzey geliştiriciler ise uzun vadede <strong>ekip liderliği, proje yönetimi ve yeni nesil uygulamaların geliştirilmesi</strong> gibi rollere kayarak değer katmaya devam edecekler. Yani kodun çoğu otomatikleşse bile, yazılımcıların yönlendirme ve uyarlama rolü sürecek.</p><h4>Kıdemli (Senior) Geliştiriciler: Organizasyonların Rehberleri!</h4><p>Uzun dönemde de kıdemli geliştiriciler <strong>stratejik karar alma, büyük sistemleri tasarlama ve ekipleri yönlendirme</strong> görevlerinde kilit önemde kalacak. Yapay zekâ uygulamaları yaygınlaştıkça, bu yazılımcılar yeni süreçleri uyarlama, proje planlama ve veri temelli karar alma konularında ekiplerine öncülük edecekler. Ayrıca, kurum içi eğitim programları ve hackathonlar düzenleyerek, daha az deneyimli meslektaşlarının YZ araçlarını öğrenmesine katkı sağlayacakları öngörülüyor. Böylece kıdemli geliştiriciler, hızla değişen teknolojik ortamda organizasyonların yol gösterici figürleri olmaya devam edecekler.</p><h3>YZ’nin Diğer Mesleklere Etkisi ve Küresel Trendler</h3><p>Yapay zekâ etkisi sadece yazılımcılarla sınırlı kalmayacak. Dünya Ekonomik Forumu (WEF) 2030 projeksiyonlarına göre, yazılım geliştiriciler ve YZ/ML uzmanları gibi teknoloji odaklı roller en hızlı büyüyen meslek grupları arasında yer alacak. Buna karşılık, kasiyer, sekreter ve veri girişi gibi rutin ofis işleri azalma eğiliminde. WEF ayrıca, 2025–2030 arasında dünya genelinde <strong>170 milyon yeni iş yaratılacağını</strong>, yaklaşık 92 milyon iş kaybı olacağını (net yaklaşık +78 milyon) öngörüyor. Bu veriler, YZ’nin genel istihdama büyük oranda olumlu yansıdığını gösteriyor.</p><p>Özellikle sağlık, eğitim ve yenilenebilir enerji gibi insan merkezli sektörlerde büyüme sürerken; montaj, lojistik ve müşteri hizmetleri gibi otomasyona uygun işler gözden geçirme gerektirecek. Özetle, düşük vasıflı ve tekrarlı işlerde risk yüksek, yüksek teknoloji ve yaratıcı işlerde ise yeni fırsatlar öne çıkıyor.</p><h3>Türkiye ve Avrupa Birliği Perspektifi: Dönüşüm Başlıyor!</h3><p>Türkiye özelinde, Google destekli bir çalışma önümüzdeki 10 yılda YZ’nin ulusal GSYH’ye %5&#39;e yakın katkı sağlayabileceğini ve mevcut iş pozisyonlarının %59&#39;unun YZ’den etkilenebileceğini öngörüyor. Yaklaşık 17 milyon iş YZ ile üretkenlik kazanırken, 13 milyon iş otomasyondan fazla etkilenmeyip sabit kalacak; geriye kalan %4 ise tamamen dönüşüme uğrayacak. Bu tablo, Türkiye’de net bir iş kaybı beklenmediğini gösteriyor. Ancak, YZ’nin işyerlerine entegrasyonunda <strong>şeffaflık, işçi hakları ve yeniden eğitim</strong> öncelikli konular arasında.</p><p>Avrupa Birliği genelinde de benzer bir iyimserlik hakim; ECB anketinde çalışanların %41&#39;i YZ’nin işlerini iyileştireceğini düşünürken, yalnızca %20&#39;si olumsuz etkiler bekliyor. Önemli olan, bu değişime hazırlanmak ve yaşam boyu öğrenme yaklaşımını benimsemek.</p><h3>Geleceğe Nasıl Hazırlanmalıyız?</h3><p>Yapay zekânın gelişimi, yazılım sektörü ve diğer meslek grupları için hem fırsatlar hem de meydan okumalar getiriyor. Mevcut veriler ışığında, genel kanı yeni iş yaratma eğilimlerinin ağır bastığı yönünde; ancak dönüşümden en çok etkilenecek alanlarda <strong>beceri ve yeniden eğitim ihtiyacı</strong> artacak. Bir yazılımcı olarak aşağıdaki çıkarımları öncelikli görüyorum:</p><ul><li><strong>Sürekli Öğrenme:</strong> Yapay zekâ ve makine öğrenimi temellerini, yeni YZ araçlarını öğrenmek şart. Kurslar, sertifikalar ve proje çalışmalarıyla becerimizi güncel tutmalıyız.</li><li><strong>YZ Araçlarına Uyum Sağlama:</strong> Kod tamamlama, veri analizi ve otomasyon araçlarını aktif kullanmak, verimliliğimizi artırır. Deneme atölyeleri veya hackathon’lar düzenleyerek bilgi paylaşabiliriz.</li><li><strong>Esneklik ve İletişim:</strong> İş dünyasında YZ uygulamalarını benimserken işverenlerle yakın işbirliği yapmalı, belirsizliklere karşı şeffaflık talep etmeliyiz. Diyalog kanalları bu süreçte kritik önemde.</li><li><strong>Yeni Uzmanlıklara Yönelim:</strong> Veri bilimi, yapay zekâ mühendisliği ve YZ uygulama geliştirme gibi alanlara yatırım yapmak gelecek için avantaj sağlayacak.</li><li><strong>Değer Oluşturmaya Odaklanma:</strong> Tekrarlı ve kolay otomatikleşebilir işler yerine yaratıcı, problem çözmeye yönelik görevlerde uzmanlaşmak önemli. Mimari tasarım, kullanıcı deneyimi, stratejik planlama gibi insan becerisi gerektiren konularda kendimizi geliştirmeliyiz.</li></ul><p>Sonuç olarak, kısa vadede üretkenlik artışı öne çıkarken uzun vadede iş dünyası dönüştükçe rolleri uyarlamak kaçınılmaz olacak. Yazılım geliştiricileri, YZ çağında yeni araçlara ayak uydurarak katma değer yaratmayı sürdürecekler. Doğru eğitim ve politika adımlarıyla, Türkiye ve AB’de de bu dönüşümün yeni iş fırsatlarına dönüşmesi hedefleniyor. Ancak herkesin bu değişime hazırlanması, <strong>yaşam boyu öğrenme</strong> yaklaşımını benimsemesi şart. Unutmayın, yapay zekâ büyük ihtimalle işleri yok etmeyecek, sadece dönüştürecek; önemli olan bu dönüşümden en kârlı çıkan taraf olmaktır.</p><p><strong>Peki siz bu dönüşümün neresinde yer almayı hedefliyorsunuz?</strong></p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4235efc6f12b" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot’u Quarkus ile Değiştirdim: Daha Hızlı, Daha Hafif Java Uygulamalarına Geliştirici… ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-bootu-quarkus-ile-de%C4%9Fi%C5%9Ftirdim-daha-h%C4%B1zl%C4%B1-daha-hafif-java-uygulamalar%C4%B1na-geli%C5%9Ftirici-3d7a41a19117?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/3d7a41a19117</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Tue, 27 May 2025 21:25:19 GMT</pubDate>
<atom:updated>2025-06-20T05:13:05.719Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jePivlT6_mBMahzWD2TCQQ.png" /></figure><h3>Spring Boot’u Quarkus ile Değiştirdim: Daha Hızlı, Daha Hafif Java Uygulamalarına Geliştirici Yolculuğum 🚀</h3><p><strong>Tanıdık bir dosttan yeni bir yarışmacıya geçiş deneyimimi paylaştığım, içgörülerim ve kod örnekleriyle dolu bir yazı kaleme aldım.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*41fzbNVSA4wcJZiJaDlYLA.png" /></figure><p>Yıllardır <strong>Spring Boot</strong>, Java uygulamaları geliştirmek için vazgeçilmez framework’üm oldu. Sağlam, devasa bir topluluğa ve akla gelebilecek neredeyse her ihtiyacı karşılayan bir ekosisteme sahip. Ancak son zamanlarda, sık sık “Süpersonik Atomaltı Java” olarak lanse edilen <strong>Quarkus</strong> etrafındaki heyecanı duyuyordum. İnanılmaz hızlı açılış süreleri, düşük bellek kullanımı ve GraalVM ile sorunsuz native derleme vaatleri görmezden gelinemeyecek kadar cazipti.</p><p>Bu yüzden bir denemeye karar verdim: Mevcut Spring Boot mikroservislerimden birini seçtim ve Quarkus’a taşıdım. Bu makale benim hikayem — nedenleri, nasılları, zorlukları ve sonuçları. Amacım, benzer bir geçiş yapmayı merak eden junior ve orta seviye geliştirici arkadaşlarıma pratik bir yol haritası sunmak. Quarkus’un gerçekten de söylendiği kadar iyi olup olmadığını ve geliştirme iş akışınız için ne anlama geldiğini keşfedeceğiz.</p><p>Bu yazıda şunları ele alacağız:</p><ul><li>Spring Boot dünyasında neden Quarkus’u düşünmelisiniz?</li><li>Başlangıçtaki Spring Boot uygulamamıza hızlı bir bakış.</li><li>Kod örnekleriyle Quarkus’a adım adım geçiş süreci.</li><li>Proje kurulumu, REST denetleyicileri ve bağımlılık enjeksiyonundaki temel farklar.</li><li>Performans gözlemleri (kavramsal).</li><li>Karşılaşılan zorluklar ve bunların üstesinden gelmek için ipuçları.</li></ul><h3>🤔 Neden Spring Boot’un Konfor Alanından Çıkıp Quarkus’a Yönelmeli?</h3><p>Spring Boot harika, ancak özellikle mikroservislerin, sunucusuz (serverless) yapıların ve konteynerleştirmenin yaygınlaştığı, açılış süresi ve bellek kullanımının kritik olduğu bir dünyada her zaman mükemmel bir seçim olmayabilir. Junior ve orta seviye geliştiriciler, daha fazla uygulama dağıtmaya başladıkça bu zorluklarla sıkça karşılaşırlar.</p><p>Quarkus’ta ilgimi çekenler şunlar oldu:</p><ul><li><strong>Işık Hızında Açılış Süreleri:</strong> Quarkus uygulamaları milisaniyeler içinde başlayabilir. Bu, geliştirme (daha hızlı geri bildirim döngüleri!) ve konteynerleştirilmiş ortamlarda ölçeklendirme için oyunun kurallarını değiştiriyor.</li><li><strong>Azaltılmış Bellek Kullanımı:</strong> Quarkus, inanılmaz derecede bellek verimli olacak şekilde tasarlanmıştır; bu da daha düşük altyapı maliyetleri ve daha yüksek yoğunluklu dağıtımlar anlamına gelir.</li><li><strong>GraalVM ile Native Derleme:</strong> Bu, Java kodunuzu native bir yürütülebilir dosyaya derlemenizi sağlar, bu da daha da hızlı açılış ve daha küçük çalışma zamanı boyutuyla sonuçlanır. Bu bazı karmaşıklıklar getirse de (bunlara değineceğiz), faydaları çok büyük olabilir.</li><li><strong>Geliştirici Mutluluğu (Developer Joy):</strong> Quarkus, canlı kodlama (live coding), birleşik yapılandırma ve popüler Java kütüphaneleri ile standartları için kapsamlı destek gibi özelliklerle harika bir geliştirici deneyimi sunmayı amaçlar. Bu, junior geliştiricilerin yeni sistemleri hızla anlamalarına ve oluşturmalarına yardımcı olur.</li><li><strong>İmperatif ve Reaktif Arasında Köprü:</strong> Quarkus, hem geleneksel imperatif programlamayı (Spring Boot geliştiricilerine tanıdık) hem de reaktif programlama modellerini destekler.</li></ul><p>Quarkus’un arkasındaki temel fikir, çalışma zamanı yerine <strong>derleme zamanında</strong> mümkün olduğunca fazla iş yapmaktır. Bu, bağımlılık enjeksiyonunu, yapılandırma işlemeyi ve framework başlatmayı içerir, bu da daha yalın ve daha hızlı uygulamalara yol açar. Bu yaklaşım, sadece “hızlı çözümler” yerine, temel kavramların sağlam bir şekilde anlaşılmasını teşvik ederek daha derin bir anlayış gerektirir.</p><h3>🏁 Başlangıç Noktamız: Basit Bir Spring Boot REST Servisi</h3><p>İşleri odaklı tutmak için çok basit bir Spring Boot uygulaması hayal edelim. Bir selamlama mesajı döndüren tek bir REST endpoint’i var.</p><p><strong>pom.xml (Spring Boot — Temel Bağımlılıklar):</strong></p><p>Bunun bir GitHub Gist’ten gömüldüğünü veya Medium’un kod bloğu özelliğini kullandığınızı hayal edin.</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;/dependencies&gt;</pre><p><strong>GreetingController.java (Spring Boot):</strong></p><pre>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class GreetingController {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Kodda sabit değerlerden kaçının, sabitler kullanın [cite: 187]<br> @GetMapping(&quot;/hello-spring&quot;)<br> public String greet(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;Dünya&quot;) String name) {<br> return String.format(template, name);<br> }<br>}</pre><p>Bu standart bir Spring Boot kurulumu. Şimdi, Quarkus’ta aynısını nasıl başarabileceğimize bakalım.</p><h3>🛠️ Geçiş: Spring Boot’tan Quarkus’a Adım Adım</h3><p>Geçiş, Quarkus’un kurallarını ve REST, CDI ve yapılandırma gibi yaygın görevleri nasıl ele aldığını anlamayı içerir. Bunu parça parça oluşturacak ve değişikliklerin ardındaki “neden”i açıklayacağız.</p><h4><strong>1. Yeni Bir Quarkus Projesi Oluşturma</strong></h4><p>Quarkus CLI, Maven eklentisi veya <a href="https://code.quarkus.io/">code.quarkus.io</a> adresinden bir Quarkus projesi oluşturabilirsiniz. Bu örnek için Maven pom.xml değişikliklerine odaklanacağız.</p><p><strong>pom.xml (Quarkus — Temel Bağımlılıklar):</strong></p><pre>&lt;dependencyManagement&gt;<br> &lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;<br> &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;<br> &lt;version&gt;&lt;span class=&quot;math-inline&quot;&gt;\{quarkus\.platform\.version\}&lt;/version\&gt;&lt;/31\&gt; &lt;type\&gt;pom&lt;/type\&gt;<br>&lt;scope\&gt;import&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;&lt;/32\&gt;<br>&lt;/dependencyManagement\&gt;<br>&lt;dependencies\&gt;<br>&lt;&lt;34\&gt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-resteasy\-reactive\-jackson&lt;/artifactId\&gt; &lt;/dependency\&gt;&lt;/34\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-arc&lt;/artifactId\&gt; &lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.quarkus&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-junit5&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;dependency\&gt;<br>&lt;groupId\&gt;io\.rest\-assured&lt;/groupId\&gt;<br>&lt;artifactId\&gt;rest\-assured&lt;/artifactId\&gt;<br>&lt;scope\&gt;test&lt;/scope\&gt;<br>&lt;/dependency\&gt;<br>&lt;/dependencies\&gt;<br>&lt;build\&gt;<br>&lt;plugins\&gt;<br>&lt;&lt;33\&gt;plugin\&gt;<br>&lt;groupId\&gt;io\.quarkus\.platform&lt;/groupId\&gt;<br>&lt;artifactId\&gt;quarkus\-maven\-plugin&lt;/artifactId\&gt;<br>&lt;version\&gt;&lt;/span&gt;{quarkus.platform.version}&lt;/version&gt;<br> &lt;executions&gt;<br> &lt;execution&gt;<br> &lt;goals&gt;<br> &lt;goal&gt;build&lt;/goal&gt;<br> &lt;goal&gt;generate-code&lt;/goal&gt;<br> &lt;goal&gt;generate-code-tests&lt;/goal&gt;<br> &lt;/goals&gt;<br> &lt;/execution&gt;<br> &lt;/executions&gt;<br> &lt;/plugin&gt;<br> &lt;/plugins&gt;<br>&lt;/build&gt;</pre><ul><li><strong>Temel değişiklikler:</strong> Bağımlılık yönetimi için quarkus-bom&#39;u import ediyoruz.</li><li>Spring Web MVC yerine JAX-RS (Quarkus’un kullandığı Java EE/Jakarta EE’deki REST standardı) için quarkus-resteasy-reactive kullanılır.</li><li>quarkus-arc, Quarkus&#39;un CDI (Contexts and Dependency Injection) üzerine kurulu ArC DI çözümüdür.</li></ul><h4>2. Quarkus’ta REST Endpoint’i Oluşturma</h4><p>Quarkus, REST endpoint’lerini tanımlamak için JAX-RS anotasyonlarını kullanır. Bunlar standart Java EE anotasyonlarıdır, bu nedenle Spring dışında çalıştıysanız tanıdık gelebilirler.</p><p><strong>GreetingResource.java (Quarkus):</strong></p><p>(Not: JAX-RS’te denetleyicilere genellikle “Resource” denir)</p><pre>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus&quot;) // Bu kaynak için temel yol<br>public class GreetingResource {<br> private static final String template = &quot;Merhaba, %s!&quot;; // Sabit kodlanmış dizelerden kaçının, sabitler kullanın [cite: 187]<br> @GET // HTTP GET metodu<br> @Produces(MediaType.TEXT_PLAIN) // Yanıtın içerik türü<br> public String greet(@QueryParam(&quot;name&quot;) String name) { // @RequestParam yerine @QueryParam<br> // name null veya boşsa varsayılan bir değer kullanın<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Dünyası&quot;;<br> return String.format(template, displayName);<br> }<br>}</pre><ul><li>@Path: Bu kaynak için temel URI yolunu tanımlar.</li><li>@GET: Bu metodun HTTP GET isteklerini işlediğini belirtir.</li><li>@Produces(MediaType.TEXT_PLAIN): Yanıt içerik türünü gösterir.</li><li>@QueryParam(&quot;name&quot;): &quot;name&quot; adlı sorgu parametresinin değerini enjekte eder. Bu, Spring&#39;in @RequestParam&#39;ına benzer.</li></ul><p>Bu yapı açıktır ve tek bir sorumluluğa odaklanır, temiz kod ilkelerine uyar.</p><h4>3. Bağımlılık Enjeksiyonu (CDI)</h4><p>Quarkus, CDI implementasyonu olan ArC’yi kullanır. Bunun gibi basit durumlar için hemen çok fazla fark görmeyebilirsiniz, ancak uygulamanız büyüdükçe @ApplicationScoped, @Inject vb. CDI anotasyonlarını kullanacaksınız.</p><p>GreetingResource&#39;umuzun bir servise ihtiyacı olsaydı şöyle görünürdü:</p><p><strong>GreetingService.java (Quarkus):</strong></p><pre>import jakarta.enterprise.context.ApplicationScoped; // CDI anotasyonu<br>@ApplicationScoped // Bu bean, uygulamanın ömrü boyunca yaşayacaktır<br>public class GreetingService {<br> public String getGreetingMessage(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Quarkus Servisi&quot;;<br> return String.format(&quot;Servisten merhaba, %s!&quot;, displayName);<br> }<br>}</pre><p><strong>GreetingResource.java (Quarkus — enjekte edilmiş servisle):</strong></p><pre>import jakarta.inject.Inject; // Enjeksiyon için CDI anotasyonu<br>import jakarta.ws.rs.GET;<br>import jakarta.ws.rs.Path;<br>import jakarta.ws.rs.Produces;<br>import jakarta.ws.rs.QueryParam;<br>import jakarta.ws.rs.core.MediaType;<br>@Path(&quot;/hello-quarkus-service&quot;)<br>public class GreetingResource {<br> @Inject // GreetingService&#39;i enjekte et<br> GreetingService service;<br> @GET<br> @Produces(MediaType.TEXT_PLAIN)<br> public String greet(@QueryParam(&quot;name&quot;) String name) {<br> return service.getGreetingMessage(name);<br> }<br>}</pre><p>Bu, Spring’in @Autowired ve @Service/@Component&#39;ına çok benzer. Servisler ve metotlar için anlamlı isimler kullanmak açıklık için önemlidir.</p><h4>4. Yapılandırma</h4><p>Quarkus’ta yapılandırma, Spring Boot’ta olduğu gibi src/main/resources içindeki application.properties aracılığıyla yapılır.</p><p>Örnek src/main/resources/application.properties:</p><pre>quarkus.application.name=my-quarkus-app<br>quarkus.application.version=1.0.0<br># HTTP portunu değiştirmek için (varsayılan 8080&#39;dir)<br>quarkus.http.port=8081<br># Özel özellikler<br>greeting.message.prefix=Aloha</pre><p>Bu özellikleri @ConfigProperty kullanarak enjekte edebilirsiniz:</p><pre>import org.eclipse.microprofile.config.inject.ConfigProperty;<br>import jakarta.enterprise.context.ApplicationScoped;<br>@ApplicationScoped<br>public class ConfigurableGreetingService {<br> @ConfigProperty(name = &quot;greeting.message.prefix&quot;, defaultValue = &quot;Merhaba&quot;)<br> String prefix;<br> public String greetWithConfig(String name) {<br> String displayName = (name != null &amp;&amp; !name.isEmpty()) ? name : &quot;Config Dünyası&quot;;<br> return String.format(&quot;%s, %s!&quot;, prefix, displayName);<br> }<br>}</pre><p>Bu isimler birden fazla yerde kullanılıyorsa, özellik adları için isimlendirilmiş sabitler kullanmak iyi bir uygulamadır.</p><h4>5. Geliştirme Modunda Çalıştırma</h4><p>Quarkus’un en havalı özelliklerinden biri geliştirme modudur:</p><pre>./mvnw quarkus:dev</pre><p>Veya Gradle kullanıyorsanız:</p><pre>./gradlew quarkusDev</pre><p>Bu, uygulamayı başlatır ve kodunuzda yaptığınız herhangi bir değişiklik neredeyse anında otomatik olarak yeniden yüklenir. Bu, geliştirme döngüsünü önemli ölçüde hızlandırır.</p><h4>6. Üretim için Derleme</h4><p>Standart bir JAR oluşturabilirsiniz:</p><pre>./mvnw package</pre><p>Bu, target/quarkus-app/ dizininde çalıştırılabilir bir JAR oluşturur.</p><p><strong>Native yürütülebilir dosya</strong> oluşturmak için (GraalVM’in kurulu ve yapılandırılmış olmasını gerektirir):</p><pre>./mvnw package -Pnative</pre><p>Bu, target/ dizininde native bir yürütülebilir dosya üretecektir. Bu dosya kendi kendine yeterlidir ve inanılmaz hızlı başlar. Native yürütülebilir dosyalar oluşturma süreci, özellikle bazı kütüphaneler için yansıma (reflection) ihtiyaçlarını anlamak açısından kendi başına bir öğrenme eğrisi olabilir.</p><h3>📊 Performans:</h3><h4><em>Kavramsal Grafik 1: Başlangıç Süresi</em></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zaD-sBfXUd3f-iFYMjXvLQ.png" /></figure><h4><strong>Kavramsal Grafik 2: Bellek Kullanımı (Yerleşik Küme Boyutu — RSS)</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sVt2Wf45BvPtgeeijhH8Eg.png" /></figure><h3>⚠️ Zorluklar ve Öğrenimler</h3><p>Geçiş genellikle olumluydu, ancak öğrenmek bazen zorlayıcı oldu.</p><ul><li><strong>Farklı Ekosistem ve API’ler:</strong> Birçok kavram benzer olsa da, belirli API’ler ve kütüphaneler (örneğin, REST için JAX-RS, yapılandırma için MicroProfile Config) Spring’inkinden farklıdır. Bu, bazı şeyleri unutmayı ve yeniden öğrenmeyi gerektirir. Bu, yeni kod tabanları veya framework’lerle karşılaşan junior geliştiriciler için yaygın bir engeldir.</li><li><strong>Native Derleme İncelikleri:</strong> Uygulamanız çok fazla yansıma (reflection) veya dinamik sınıf yükleme kullanıyorsa native yürütülebilir dosyalar oluşturmak bazen zor olabilir, çünkü GraalVM’in derleme zamanında bunları bilmesi gerekir. Quarkus çok yardımcı olur, ancak zaman zaman ipuçları vermeniz gerekebilir. Bu, sadece yüzeysel kodlamanın ötesinde daha derin bir anlayışa duyulan ihtiyacı pekiştirir.</li><li><strong>Daha Küçük (ama Büyüyen) Topluluk:</strong> Quarkus’un topluluğu aktif ve hızla büyüyor olsa da, henüz Spring kadar geniş değil. Bu, çok özel sorunlara çözüm bulmanın bazen biraz daha fazla araştırma gerektirebileceği anlamına gelir.</li><li><strong>“Derleme Zamanında” Düşünmek:</strong> Daha fazlasını derleme zamanında yapmaya geçiş güçlüdür ancak hafif bir zihinsel uyum gerektirir. Spring’de çalışma zamanında “sadece çalışan” bazı şeyler, Quarkus’ta derleme zamanı dostu olmak için açık yapılandırma veya eklentiler gerektirebilir.</li></ul><p>Bu karmaşık fikirleri basitleştirmek ve bunları, temel bilgilerini hala geliştirmekte olan geliştiriciler için sindirilebilir parçalara ayırmak çok önemlidir. Burada analojiler yardımcı olabilir; örneğin, Quarkus’un derleme zamanı işlemesini, bir şefin pişirmeden önce tüm malzemeleri hazırlaması (mise en place) gibi düşünmek, Spring Boot’un ise daha fazla hazırlığı gerçek pişirme işlemi sırasında yapmasına karşılık gelir.</p><h3>✅ Karar: Spring Boot vs. Quarkus — Benim Çıkarımım</h3><p>Peki, Spring Boot’u Quarkus ile değiştirmek buna değer miydi? <strong>Bu özel mikroservis için kesinlikle evet.</strong></p><p>Başlangıç süresi ve bellek azaltımındaki performans kazanımları, JVM modunda bile önemliydi. Canlı yeniden yükleme ile geliştirici deneyimi harika. Quarkus modern, yalın ve bulut tabanlı uygulamalar için mükemmel bir şekilde uygun hissettiriyor.</p><p><strong>Quarkus’u ne zaman düşünmelisiniz:</strong></p><ul><li>Yeni mikroservisler veya sunucusuz işlevler oluştururken.</li><li>Düşük bellek ayak izi ve hızlı başlangıç kritik olduğunda.</li><li>GraalVM native derlemesinden yararlanmakla ilgileniyorsanız.</li><li>Kaynak verimliliğinin maliyet tasarrufuna dönüştüğü uygulamalar için.</li></ul><p><strong>Spring Boot ne zaman hala daha iyi bir seçim olabilir:</strong></p><ul><li>Tam bir yeniden yazımın mümkün olmadığı büyük, mevcut monolitik uygulamalar.</li><li>Henüz doğrudan Quarkus eşdeğerleri olmayan belirli Spring’e özgü kütüphanelere veya modüllere büyük ölçüde bağımlı projeler.</li><li>Mevcut derin Spring uzmanlığının, acil proje hedefleri için yeni bir framework’ün öğrenme eğrisinden daha ağır bastığı ekipler.</li></ul><p>Bu geçiş, geliştiriciler olarak sürekli olarak yeni araçları ve paradigmaları keşfetmemiz gerektiği fikrini pekiştiren değerli bir öğrenme deneyimi oldu. Mesele “X her zaman Y’den iyidir” değil, ödünleşimleri anlamak ve iş için doğru aracı seçmektir. Bu yolculuk aynı zamanda, özellikle yapay zeka gibi araçların derinlemesine anlamadan hızlı çözümler sunabileceği bir dönemde, sadece framework sihrine güvenmek yerine temel Java kavramlarını anlamanın önemini de vurguladı.</p><h3>🚀 Sıra Sizde! Sonraki Adımlar ve Daha Fazla Keşif</h3><p>Quarkus ilginizi çektiyse, başlamanıza yardımcı olacak bazı kaynaklar şunlardır:</p><ul><li><strong>Quarkus Kılavuzları:</strong> <a href="https://quarkus.io/guides/">https://quarkus.io/guides/</a> — Resmi belgeler mükemmeldir ve neredeyse her şey için adım adım kılavuzlar sunar.</li><li><strong>Quarkus YouTube Kanalı:</strong> Harika eğitimler ve konuşmalar sunar.</li><li>Daha büyük projelere girişmeden önce framework’e alışmak için küçük bir <strong>“oyuncak uygulama”</strong> oluşturmayı deneyin.</li></ul><h4>💬 Sizin Düşünceleriniz Neler?</h4><p>Deneyimlerinizi duymak isterim!</p><ul><li>Quarkus’u denediniz mi? İzleniminiz neydi?</li><li>Spring Boot’tan veya başka bir framework’ten geçmeyi düşünüyor musunuz?</li><li>Öngördüğünüz en büyük zorluklar veya faydalar nelerdir?</li></ul><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d7a41a19117" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile E-posta Gönderimi ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-e-posta-g%C3%B6nderimi-d6715e02cefa?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/d6715e02cefa</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 06:12:35 GMT</pubDate>
<atom:updated>2025-06-20T05:13:43.939Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/737/1*JB9KkS2Ay2msUHwKXxCljw.png" /></figure><p>Günümüz uygulamalarının vazgeçilmez bir parçası olan e-posta iletişimi, kullanıcı kaydından bildirimlere, şifre sıfırlamadan pazarlama kampanyalarına kadar geniş bir yelpazede kullanılıyor. Spring Boot, spring-boot-starter-mail paketi ile bu süreci oldukça basitleştiriyor. Ancak, sadece basit bir metin e-postası göndermenin ötesine geçmek, HTML içerikler, ekler, şablonlar kullanmak ve asenkron gönderim gibi konular, uygulamanızın profesyonelliğini ve kullanıcı deneyimini doğrudan etkiler.</p><p>Bu kapsamlı rehberde, Spring Boot ile e-posta göndermenin temellerinden başlayarak, daha karmaşık senaryolara ve en iyi uygulamalara kadar derinlemesine bir yolculuğa çıkacağız. Amacımız, sadece e-posta göndermenizi sağlamak değil, aynı zamanda bu konuda ufkunuzu açarak daha sağlam ve esnek çözümler üretebilmenize yardımcı olmak.</p><p><strong>Makale İçeriği:</strong></p><p><strong>Temel Kurulum ve Bağımlılıklar</strong></p><p><strong>application.properties ile Yapılandırma: Sırları ve İncelikleri</strong></p><ul><li>Gmail ile Hızlı Başlangıç (Uygulama Şifresi Oluşturma)</li><li>Diğer SMTP Sağlayıcıları İçin Genel Ayarlar</li></ul><p><strong>JavaMailSender Arayüzü ve Spring Boot Auto-Configuration Sihri</strong></p><p><strong>İlk E-postamız: </strong><strong>SimpleMailMessage ile Basit Metin Gönderimi</strong></p><p><strong>Ufukları Genişletelim: </strong><strong>MimeMessage ile Gelişmiş E-posta İşlevleri</strong></p><ul><li>HTML İçerikli E-postalar Gönderme</li><li>Dosya Eki (Attachment) Ekleme</li><li>Satır İçi Görseller (Inline Images) Kullanma</li></ul><p><strong>E-posta Şablonları ile Dinamik İçerikler: Thymeleaf Entegrasyonu</strong></p><p><strong>Asenkron E-posta Gönderimi: Performansı Artırma (</strong><strong>@Async)</strong></p><p><strong>Yapılandırma ve Güvenlik İpuçları</strong></p><ul><li>Hassas Bilgilerin (Şifreler) Güvenli Yönetimi</li><li>Birden Fazla JavaMailSender Yapılandırması</li></ul><p><strong>Test Stratejileri: E-postaları Gerçekten Göndermeden Test Etme</strong></p><p><strong>En İyi Uygulamalar ve Ek Hususlar</strong></p><ul><li>Hata Yönetimi ve Yeniden Deneme Mekanizmaları</li><li>Uluslararasılaştırma (i18n)</li><li>Profesyonel E-posta Servisleri (SendGrid, Mailgun vb.) Ne Zaman Düşünülmeli?</li></ul><p><strong>Sonuç</strong></p><p>Hazırsanız, Spring Boot ile e-posta göndermenin derinliklerine dalalım!</p><h3>1. Temel Kurulum ve Bağımlılıklar</h3><p>Her Spring Boot projesinde olduğu gibi, işe pom.xml (Maven kullanıyorsanız) veya build.gradle (Gradle kullanıyorsanız) dosyamıza gerekli bağımlılığı ekleyerek başlıyoruz.</p><p><strong>Maven (</strong><strong>pom.xml):</strong></p><pre>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Bu “starter” paket, JavaMail API’sini ve Spring Framework’ün e-posta gönderimi için sunduğu soyutlama katmanlarını projenize dahil eder.</p><h3>2. application.properties ile Yapılandırma: Sırları ve İncelikleri</h3><p>Spring Boot, application.properties (veya application.yml) dosyasındaki belirli anahtarları okuyarak JavaMailSender&#39;ı otomatik olarak yapılandırır.</p><p><strong>Gmail ile Hızlı Başlangıç:</strong></p><p>En yaygın kullanılan senaryolardan biri Gmail SMTP sunucusunu kullanmaktır.</p><ul><li><strong>Adım 2.1: Google Hesabınızda Uygulama Şifresi Oluşturma (ÇOK ÖNEMLİ!)</strong> Google, güvenlik nedeniyle standart hesap şifrenizin uygulamalar tarafından doğrudan kullanılmasını kısıtlar. Bu nedenle bir “Uygulama Şifresi” oluşturmanız gerekir.</li></ul><ol><li><a href="https://myaccount.google.com/">Google Hesabınıza</a> gidin.</li><li>Sol menüden “Güvenlik” sekmesine tıklayın.</li><li>“Google’da oturum açma” bölümünde “2 Adımlı Doğrulama”nın <strong>etkin olduğundan emin olun</strong>. Değilse, etkinleştirin.</li><li>2 Adımlı Doğrulama etkinse, aynı bölümde “Uygulama şifreleri” seçeneğini göreceksiniz. (Eğer göremiyorsanız, arama çubuğuna “Uygulama şifreleri” yazın.)</li><li>“Uygulama seçin” altında “Diğer (Özel ad)” seçeneğini seçin, uygulamanıza bir isim verin (örn: “SpringBootMailApp”) ve “OLUŞTUR” butonuna tıklayın.</li><li>Google size 16 karakterlik bir uygulama şifresi verecektir. <strong>Bu şifreyi kopyalayın ve güvenli bir yere not edin.</strong> Bu pencereyi kapattıktan sonra tekrar göremezsiniz.</li></ol><ul><li><strong>Adım 2.2: </strong><strong>application.properties Dosyasını Ayarlama</strong> Aşağıdaki ayarları src/main/resources/application.properties dosyanıza ekleyin:</li></ul><pre>spring.mail.username=youremail@gmail.com # Gmail kullanıcı adınız (e-posta adresiniz) <br>spring.mail.password=BU_ALANA_KOPYALADIGINIZ_UYGULAMA_SIFRESINI_YAPISTIRIN <br># Gmail SMTP Sunucu Ayarları <br>spring.mail.host=smtp.gmail.com <br>spring.mail.port=587 # TLS için önerilen port <br># Ek JavaMail Özellikleri <br>spring.mail.properties.mail.smtp.auth=true <br>spring.mail.properties.mail.smtp.starttls.enable=true <br># TLS&#39;yi etkinleştirir <br>spring.mail.properties.mail.smtp.starttls.required=true <br># TLS zorunlu <br>spring.mail.transport.protocol=smtp <br># Kullanılacak protokol <br># İsteğe Bağlı: Hata ayıklama için loglamayı açar (üretimde kapatın) <br>spring.mail.properties.mail.debug=true</pre><ul><li><strong>Ufuk Açan Not:</strong> spring.mail.properties.* ile başlayan ayarlar, doğrudan JavaMail API&#39;sine geçirilen özelliklerdir. Bu, Spring Boot&#39;un soyutlamasının ötesinde, JavaMail&#39;in tüm gücünü kullanabileceğiniz anlamına gelir. Örneğin, bağlantı zaman aşımı (mail.smtp.connectiontimeout), yazma zaman aşımı (mail.smtp.writetimeout) gibi daha ince ayarları buradan yapabilirsiniz.</li></ul><p><strong>Diğer SMTP Sağlayıcıları İçin Genel Ayarlar:</strong></p><p>Eğer Gmail dışında bir SMTP sunucusu (örneğin, şirketinizin kendi sunucusu veya SendGrid, Mailgun gibi bir servis) kullanacaksanız, host, port, username, password ve properties ayarlarını sağlayıcınızın belgelerine göre düzenlemeniz yeterlidir.</p><h3>3. JavaMailSender Arayüzü ve Spring Boot Auto-Configuration Sihri</h3><p>Spring Boot, yukarıdaki application.properties ayarlarını kullanarak otomatik olarak bir JavaMailSender bean&#39;i oluşturur ve yönetir. Bu sayede, çoğu zaman sizin manuel bir JavaMailSender bean&#39;i tanımlamanıza gerek kalmaz.</p><p>Ancak, kaynakta belirtilen @Configuration sınıfı ile manuel bean tanımı:</p><pre>@Configuration<br>public class MailConfiguration {<br> @Bean<br> public JavaMailSender getJavaMailSender() {<br> JavaMailSenderImpl mailSender = new JavaMailSenderImpl();<br> mailSender.setHost(&quot;smtp.gmail.com&quot;);<br> // ... diğer ayarlar<br> return mailSender;<br> }<br> }</pre><p>Bu yaklaşım, eğer application.properties dosyasında zaten tüm ayarları yaptıysanız <strong>genellikle gereksizdir</strong>. Spring Boot sizin için bunu zaten yapar.</p><p><strong>Peki ne zaman manuel bean tanımına ihtiyaç duyulur?</strong></p><ul><li>Birden fazla, farklı ayarlara sahip JavaMailSender bean&#39;ine ihtiyacınız varsa (örn: biri Gmail, diğeri başka bir SMTP için).</li><li>JavaMailSenderImpl üzerinde application.properties ile ayarlanamayan çok özel programatik yapılandırmalar yapmak istiyorsanız.</li><li>Spring Boot’un otomatik yapılandırmasını devre dışı bırakıp tam kontrol sahibi olmak istiyorsanız (spring.mail.host ayarını boş bırakmak otomatik yapılandırmayı devre dışı bırakabilir).</li></ul><p>Çoğu senaryoda, Spring Boot’un otomatik yapılandırması yeterli ve tercih edilen yoldur.</p><h3>4. İlk E-postamız: SimpleMailMessage ile Basit Metin Gönderimi</h3><p>Şimdi basit bir metin e-postası gönderecek servisi oluşturalım.</p><p><strong>MailSenderService.java:</strong></p><pre>package com.example.demo.mail; // Kendi paket yapınıza göre düzenleyin<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.mail.SimpleMailMessage;<br>import org.springframework.mail.javamail.JavaMailSender;<br>import org.springframework.stereotype.Service;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // Spring Boot, application.properties&#39;teki ayarlara göre<br> // JavaMailSender bean&#39;ini otomatik olarak enjekte edecektir.<br> // @Value(&quot;${spring.mail.username}&quot;) // Gönderici adresini properties&#39;ten almak için<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> public void sendSimpleMail(String to, String subject, String body) {<br> SimpleMailMessage message = new SimpleMailMessage();<br> // message.setFrom(fromEmail); // Gönderici adresi (genellikle properties&#39;te ayarlanır ve otomatik kullanılır)<br> message.setTo(to);<br> message.setSubject(subject);<br> message.setText(body);<br> try {<br> mailSender.send(message);<br> System.out.println(&quot;Mail sent successfully to &quot; + to);<br> } catch (Exception e) {<br> System.err.println(&quot;Error while sending mail to &quot; + to + &quot;: &quot; + e.getMessage());<br> // Burada daha gelişmiş hata yönetimi yapılabilir (logging, retry vb.)<br> }<br> }<br>}</pre><pre><strong>Not:</strong> SimpleMailMessage sınıfı, adından da anlaşılacağı gibi sadece basit metin tabanlı e-postalar için uygundur. HTML, ek dosya veya satır içi görsel desteklemez.</pre><p><strong>E-postayı Tetikleme (Örnek bir Controller veya başka bir Servis):</strong></p><pre>package com.example.demo.controller; // Kendi paket yapınıza göre düzenleyin<br>import com.example.demo.mail.MailSenderService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.springframework.web.bind.annotation.RestController;<br>@RestController<br>public class MailController {<br> private final MailSenderService mailService;<br> @Autowired<br> public MailController(MailSenderService mailService) {<br> this.mailService = mailService;<br> }<br> @GetMapping(&quot;/send-test-email&quot;)<br> public String sendTestEmail(@RequestParam String to) {<br> mailService.sendSimpleMail(to, &quot;Spring Boot Test E-postası&quot;, &quot;Merhaba,\n\nBu Spring Boot uygulamasından gönderilmiş bir test e-postasıdır.&quot;);<br> return &quot;Test e-postası gönderildi: &quot; + to;<br> }<br>}</pre><p>Uygulamanızı çalıştırıp tarayıcıdan http://localhost:8080/send-test-email?to=alici_email@example.com adresine giderek test edebilirsiniz.</p><h3>5. Ufukları Genişletelim: MimeMessage ile Gelişmiş E-posta İşlevleri</h3><p>Daha zengin içerikli e-postalar için JavaMailSender&#39;ın createMimeMessage() metodunu ve MimeMessageHelper sınıfını kullanırız.</p><p><strong>Gelişmiş </strong><strong>MailSenderService.java:</strong></p><pre>// ... (önceki importlar)<br>import org.springframework.mail.javamail.MimeMessageHelper;<br>import jakarta.mail.MessagingException; // javax.mail yerine jakarta.mail (Spring Boot 3+)<br>import jakarta.mail.internet.MimeMessage;<br>import org.springframework.core.io.FileSystemResource; // Dosya ekleri için<br>import java.io.File;<br>@Service<br>public class MailSenderService {<br> private final JavaMailSender mailSender;<br> // @Value(&quot;${spring.mail.username}&quot;)<br> // private String fromEmail;<br> @Autowired<br> public MailSenderService(JavaMailSender mailSender) {<br> this.mailSender = mailSender;<br> }<br> // ... sendSimpleMail metodu ...<br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> // &#39;true&#39; parametresi multipart message oluşturulacağını belirtir.<br> // İkinci &#39;true&#39; ise UTF-8 encoding için.<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(htmlBody, true); // &#39;true&#39; HTML içeriği olduğunu belirtir.<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;HTML mail sent successfully to &quot; + to);<br> }<br> public void sendMailWithAttachment(String to, String subject, String body, String attachmentPath) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); // &#39;true&#39; for multipart message<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> helper.setText(body);<br> FileSystemResource file = new FileSystemResource(new File(attachmentPath));<br> if (file.exists()) {<br> helper.addAttachment(file.getFilename(), file); // İkinci parametre dosya kaynağı<br> System.out.println(&quot;Attachment added: &quot; + file.getFilename());<br> } else {<br> System.err.println(&quot;Attachment file not found: &quot; + attachmentPath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with attachment sent successfully to &quot; + to);<br> }<br> public void sendMailWithInlineImage(String to, String subject, String htmlBody, String imagePath, String imageContentId) throws MessagingException {<br> MimeMessage mimeMessage = mailSender.createMimeMessage();<br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);<br> // helper.setFrom(fromEmail);<br> helper.setTo(to);<br> helper.setSubject(subject);<br> // HTML içeriğinde &lt;img src=&#39;cid:imageContentId&#39;&gt; şeklinde referans verilir.<br> helper.setText(htmlBody, true);<br> FileSystemResource res = new FileSystemResource(new File(imagePath));<br> if (res.exists()) {<br> // &#39;imageContentId&#39; HTML içindeki cid ile aynı olmalı<br> helper.addInline(imageContentId, res);<br> System.out.println(&quot;Inline image added: &quot; + imageContentId);<br> } else {<br> System.err.println(&quot;Inline image file not found: &quot; + imagePath);<br> }<br> mailSender.send(mimeMessage);<br> System.out.println(&quot;Mail with inline image sent successfully to &quot; + to);<br> }<br>}</pre><ul><li><strong>Not (HTML):</strong> helper.setText(htmlBody, true); satırındaki ikinci true parametresi, gönderilen metnin HTML olarak yorumlanmasını sağlar.</li><li><strong>Not (Ek):</strong> MimeMessageHelper(mimeMessage, true) constructor&#39;ındaki true parametresi, mesajın &quot;multipart&quot; olacağını belirtir, bu da ek dosya ve satır içi görseller için gereklidir. addAttachment ile dosya adı ve kaynağını belirtirsiniz.</li><li><strong>Not (Satır İçi Görsel):</strong> addInline metodu kullanılır. HTML içinde &lt;img src=&#39;cid:myImageIdentifier&#39;&gt; şeklinde bir referans verilir ve addInline(&quot;myImageIdentifier&quot;, resource) çağrısıyla bu ID&#39;ye karşılık gelen görsel eklenir. Bu, görselin e-postanın içine gömülmesini sağlar, kırık link sorununu azaltır. E-posta istemcisinin multipart/related içeriği desteklemesi gerekir.</li></ul><h3>6. E-posta Şablonları ile Dinamik İçerikler: Thymeleaf Entegrasyonu</h3><p>Sabit HTML string’leri yerine dinamik içerikler oluşturmak için Thymeleaf gibi bir şablon motoru kullanmak çok daha pratiktir.</p><ul><li><strong>Adım 6.1: Thymeleaf Bağımlılığını Ekleme (</strong><strong>pom.xml)</strong></li></ul><pre>&lt;dependency&gt; <br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; <br>&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; <br>&lt;/dependency&gt;</pre><ul><li><strong>Adım 6.2: E-posta Şablonu Oluşturma (</strong><strong>src/main/resources/templates/email/my-template.html)</strong></li></ul><pre>&lt;!DOCTYPE html&gt; <br>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; <br>&lt;head&gt; <br>&lt;meta charset=&quot;UTF-8&quot;&gt; <br>&lt;title th:text=&quot;${subject}&quot;&gt;E-posta Başlığı&lt;/title&gt; <br>&lt;style&gt; <br>body { font-family: Arial, sans-serif; } <br>.container { padding: 20px; border: 1px solid #ddd; } <br>&lt;/style&gt; <br>&lt;/head&gt; <br>&lt;body&gt; <br>&lt;div class=&quot;container&quot;&gt; <br>&lt;h1 th:text=&quot;${title}&quot;&gt;Merhaba!&lt;/h1&gt; <br>&lt;p&gt;Sevgili &lt;strong th:text=&quot;${name}&quot;&gt;Kullanıcı&lt;/strong&gt;,&lt;/p&gt; <br>&lt;p th:text=&quot;${messageContent}&quot;&gt;Bu dinamik bir e-posta içeriğidir.&lt;/p&gt; &lt;hr&gt; &lt;p&gt;Teşekkürler,&lt;br&gt;Spring Boot Uygulamanız&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</pre><ul><li><strong>Adım 6.3: </strong><strong>MailSenderService&#39;i Güncelleme</strong></li></ul><pre>// ... (önceki importlar) <br>import org.thymeleaf.context.Context; <br>import org.thymeleaf.spring6.SpringTemplateEngine; <br>// Spring Boot 3 için spring6 <br>@Service <br>public class MailSenderService { <br>private final JavaMailSender mailSender; <br>private final SpringTemplateEngine templateEngine; <br>Thymeleaf motorunu enjekte et <br>@Value(&quot;${spring.mail.username}&quot;) <br>private String fromEmail; <br>@Autowired <br>public MailSenderService(JavaMailSender mailSender, SpringTemplateEngine templateEngine) { <br> this.mailSender = mailSender; <br> this.templateEngine = templateEngine; <br>} <br>// ... diğer metotlar ... <br>public void sendMailWithTemplate(String to, String subject, String templateName, Context context) throws MessagingException { <br> MimeMessage mimeMessage = mailSender.createMimeMessage(); <br> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;); <br> // Thymeleaf context&#39;inden HTML içeriğini işle <br> String htmlContent = templateEngine.process(&quot;email/&quot; + templateName, context); <br> // &quot;email/&quot; templates altındaki klasör <br> // helper.setFrom(fromEmail); <br> helper.setTo(to); <br> helper.setSubject(subject); <br> helper.setText(htmlContent, true); <br> mailSender.send(mimeMessage); <br> System.out.println(&quot;Templated mail sent successfully to &quot; + to); <br> } <br>}</pre><ul><li><strong>Kullanımı:</strong></li></ul><pre>// Bir controller veya başka bir serviste <br>// Context context = new Context(); <br>// context.setVariable(&quot;subject&quot;, &quot;Thymeleaf ile Merhaba!&quot;); <br>// context.setVariable(&quot;title&quot;, &quot;Hoş Geldiniz!&quot;); <br>// context.setVariable(&quot;name&quot;, &quot;Ahmet Yılmaz&quot;); <br>// context.setVariable(&quot;messageContent&quot;, &quot;Thymeleaf kullanarak dinamik bir e-posta gönderdiniz.&quot;); <br>// mailService.sendMailWithTemplate(&quot;alici@example.com&quot;, &quot;Thymeleaf Test&quot;, &quot;my-template.html&quot;, context);</pre><ul><li><strong>Not:</strong> Context nesnesi, şablona geçirilecek dinamik verileri içerir. templateEngine.process metodu, şablon adını ve context&#39;i alarak sonuç HTML&#39;i üretir. Bu yaklaşım, e-posta içeriği ile sunumunu ayırarak bakımı kolaylaştırır.</li></ul><h3>7. Asenkron E-posta Gönderimi: Performansı Artırma (@Async)</h3><p>E-posta gönderme işlemi, SMTP sunucusunun yanıt verme süresine bağlı olarak zaman alabilir. Kullanıcı etkileşimli bir işlem sırasında (örneğin, kayıt sonrası hoş geldin e-postası) senkron e-posta gönderimi, kullanıcıya yavaş bir deneyim sunabilir. @Async kullanarak e-posta gönderimini arka planda çalışacak ayrı bir thread&#39;e devredebiliriz.</p><ul><li><strong>Adım 7.1: Asenkron Desteği Etkinleştirme</strong> Ana uygulama sınıfınıza veya bir @Configuration sınıfına @EnableAsync ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.EnableAsync; <br>@SpringBootApplication <br>@EnableAsync // Asenkron metodları etkinleştirir <br>public class DemoApplication { <br> public static void main(String[] args) { <br> SpringApplication.run(DemoApplication.class, args); <br> } <br>}</pre><ul><li><strong>Adım 7.2: Servis Metodunu </strong><strong>@Async ile İşaretleme</strong> MailSenderService içindeki e-posta gönderim metotlarınıza @Async ekleyin:</li></ul><pre>import org.springframework.scheduling.annotation.Async; <br>// ... @Service <br>public class MailSenderService { <br>// ... @Async <br> // Bu metod asenkron çalışacak <br> public void sendSimpleMail(String to, String subject, String body) { <br> // ... (içerik aynı) } <br> @Async <br> public void sendHtmlMail(String to, String subject, String htmlBody) throws MessagingException { <br> // ... (içerik aynı) } <br> // Diğer metotlar için de @Async eklenebilir. <br>}</pre><ul><li><strong>Not:</strong> @Async metodların public olması ve aynı sınıf içinden çağrılmaması gerekir (proxy mekanizması nedeniyle). Eğer aynı sınıf içinden çağırmanız gerekiyorsa, kendinize enjekte ederek (self-injection) çözebilirsiniz veya e-posta gönderimini ayrı bir bean&#39;e taşıyabilirsiniz. Ayrıca, @Async için özel bir TaskExecutor yapılandırarak thread havuzu boyutunu vb. yönetebilirsiniz.</li></ul><pre> // TaskExecutor konfigürasyonu (isteğe bağlı) <br> import org.springframework.context.annotation.Bean; <br> import org.springframework.context.annotation.Configuration; <br> import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; <br> import java.util.concurrent.Executor; <br> <br> @Configuration <br> public class AsyncConfig { <br> @Bean(name = &quot;mailTaskExecutor&quot;) <br> public Executor mailTaskExecutor() { <br> ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); <br> executor.setCorePoolSize(5); <br>// Aynı anda çalışacak min thread <br> executor.setMaxPoolSize(10); <br> Max thread <br> executor.setQueueCapacity(25); <br>// Kuyruk kapasitesi <br><br> executor.setThreadNamePrefix(&quot;MailAsync-&quot;); <br> executor.initialize(); <br> return executor; <br> } <br> } <br> @Async(&quot;mailTaskExecutor&quot;) <br> Belirli bir executor kullanmak için</pre><h3>8. Yapılandırma ve Güvenlik İpuçları</h3><ul><li><strong>Hassas Bilgilerin Güvenli Yönetimi:</strong> spring.mail.password gibi hassas bilgileri doğrudan application.properties dosyasına yazmak ve bunu Git gibi versiyon kontrol sistemlerine göndermek <strong>GÜVENLİK AÇIĞIDIR.</strong></li><li><strong>Çözüm 1: Ortam Değişkenleri (Environment Variables):</strong> application.properties dosyasında: spring.mail.password=${MAIL_APP_PASSWORD} Uygulamanızı çalıştırdığınız ortamda MAIL_APP_PASSWORD adında bir ortam değişkeni tanımlayın.</li><li><strong>Çözüm 2: Spring Cloud Config Server:</strong> Merkezi ve güvenli yapılandırma yönetimi için.</li><li><strong>Çözüm 3: HashiCorp Vault:</strong> Sırların (secrets) güvenli depolanması ve erişimi için.</li><li><strong>Birden Fazla </strong><strong>JavaMailSender Yapılandırması:</strong> Farklı amaçlar için (örn: işlem e-postaları için bir SMTP, pazarlama için başka bir SMTP) farklı JavaMailSender bean&#39;leri tanımlayabilirsiniz. Bu durumda, her bir bean&#39;i @Primary ile varsayılan olarak işaretleyebilir veya @Qualifier ile belirli bir bean&#39;i enjekte edebilirsiniz.</li></ul><pre> @Configuration <br> public class MultipleMailConfig { <br> @Bean <br> @Primary <br> public JavaMailSender primaryMailSender() { <br> /* ... ayarlar ... */ <br> } <br> <br> @Bean <br> @Qualifier(&quot;marketingMailSender&quot;) <br> public JavaMailSender marketingMailSender() { <br> /* ... farklı ayarlar ... */ <br> } <br> } <br> <br> <br>// Kullanım <br> @Autowired <br> @Qualifier(&quot;marketingMailSender&quot;) <br> private JavaMailSender marketingSender;</pre><h3>9. Test Stratejileri: E-postaları Gerçekten Göndermeden Test Etme</h3><p>Entegrasyon testleri sırasında sürekli gerçek e-posta göndermek pratik değildir ve SMTP sunucunuzu gereksiz yere yorabilir.</p><ul><li><strong>Çözüm 1: Wiser (SubEthaSMTP üzerinden Spring Boot Test Desteği):</strong> Spring Boot, testler için gömülü bir SMTP sunucusu başlatmanıza olanak tanır. spring-boot-starter-test ile birlikte gelir. application-test.properties dosyasına (genellikle src/test/resources altında):</li></ul><pre>spring.mail.host=localhost spring.mail.port=2525 # Wiser için varsayılan veya testte ayarlanan port spring.mail.username=testuser spring.mail.password=testpass spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.transport.protocol=smtp</pre><ul><li>Test sınıfınızda:</li></ul><pre> import com.icegreen.greenmail.configuration.GreenMailConfiguration; <br> import com.icegreen.greenmail.junit5.GreenMailExtension; <br> import com.icegreen.greenmail.util.ServerSetupTest; <br> import jakarta.mail.internet.MimeMessage; <br> import org.junit.jupiter.api.Test; <br> import org.junit.jupiter.api.extension.RegisterExtension; <br> import org.springframework.beans.factory.annotation.Autowired; <br> import org.springframework.boot.test.context.SpringBootTest; <br> import static org.assertj.core.api.Assertions.assertThat; <br> <br> @SpringBootTest <br> public class MailServiceIntegrationTest { <br> <br> @RegisterExtension <br>// JUnit 5 için <br> static GreenMailExtension greenMail = new GreenMailExtension(ServerSetupTest.SMTP) <br> .withConfiguration(GreenMailConfiguration.aConfig().withUser(&quot;testuser&quot;, &quot;testpass&quot;)) <br> .withPerMethodLifecycle(false); // Tüm test metotları için tek bir GreenMail instance <br> <br> @Autowired <br> private MailSenderService mailService; <br> <br> @Test <br> void testSendSimpleMail() throws Exception { <br> String to = &quot;recipient@example.com&quot;; <br> String subject = &quot;Test Subject&quot;; <br> String body = &quot;Test Body&quot;; <br> <br> mailService.sendSimpleMail(to, subject, body); <br> <br> MimeMessage[] receivedMessages = greenMail.getReceivedMessages(); <br> assertThat(receivedMessages.length).isEqualTo(1); <br> MimeMessage receivedMessage = receivedMessages[0]; <br> assertThat(receivedMessage.getSubject()).isEqualTo(subject); <br> assertThat(receivedMessage.getAllRecipients()[0].toString()).isEqualTo(to); <br> <br>// İçeriği de kontrol edebilirsiniz. <br> } <br> }</pre><ul><li><em>GreenMail gibi kütüphaneler (Wiser da SubEthaSMTP’yi temel alır) gelen e-postaları yakalayıp içeriğini doğrulamanızı sağlar.</em></li><li><strong>Çözüm 2: Mocking </strong><strong>JavaMailSender:</strong> Birim testlerinde JavaMailSender&#39;ı mocklayarak send() metodunun çağrılıp çağrılmadığını ve doğru parametrelerle çağrıldığını doğrulayabilirsiniz.</li></ul><h3>10. En İyi Uygulamalar ve Ek Hususlar</h3><ul><li><strong>Logging:</strong> E-posta gönderim başarılarını ve hatalarını detaylı loglayın.</li><li><strong>Hata Yönetimi ve Yeniden Deneme:</strong> Geçici SMTP hataları (bağlantı sorunları vb.) için Spring Retry gibi mekanizmalarla yeniden deneme stratejileri uygulayabilirsiniz.</li><li><strong>Uluslararasılaştırma (i18n):</strong> E-posta içeriklerini ve başlıklarını farklı dillerde sunmak için Spring’in i18n desteğini (ResourceBundleMessageSource) Thymeleaf ile birlikte kullanın.</li><li><strong>Abonelikten Çıkma (Unsubscribe) Linkleri:</strong> Özellikle pazarlama e-postaları için yasal bir zorunluluktur ve kullanıcı deneyimi için önemlidir.</li><li><strong>Rate Limiting:</strong> SMTP sunucularının genellikle gönderim limitleri vardır. Toplu e-posta gönderimlerinde bu limitlere dikkat edin.</li><li><strong>Profesyonel E-posta Servisleri (SendGrid, Amazon SES, Mailgun vb.):</strong> Yüksek hacimli e-posta gönderimi, gelişmiş analizler, teslim edilebilirlik (deliverability) takibi, IP itibarı yönetimi gibi ihtiyaçlarınız varsa, bu tür harici servisleri kullanmayı düşünün. Genellikle kendi API’leri ve Spring Boot entegrasyon kütüphaneleri bulunur.</li></ul><h3>11. Sonuç</h3><p>Spring Boot ile e-posta göndermek, spring-boot-starter-mail sayesinde oldukça kolaylaşmıştır. Ancak, bu rehberde gördüğümüz gibi, basit bir metin e-postasından çok daha fazlasını yapabiliriz. HTML içerikler, ekler, şablonlar, asenkron gönderim ve doğru test stratejileri ile uygulamalarınızda profesyonel ve etkili bir e-posta iletişim altyapısı kurabilirsiniz.</p><p>Unutmayın, e-posta gönderimi sadece teknik bir işlem değil, aynı zamanda kullanıcı deneyiminin ve uygulamanızın imajının önemli bir parçasıdır. Bu nedenle, bu süreçlere özen göstermek ve en iyi uygulamaları takip etmek, projenizin başarısına katkı sağlayacaktır.</p><p>Umarım bu kapsamlı rehber, Spring Boot ile e-posta gönderimi konusunda ufkunuzu açmış ve size değerli bilgiler sunmuştur. Yorumlarda sorularınızı ve deneyimlerinizi paylaşmaktan çekinmeyin!</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d6715e02cefa" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Reaktif Programlama ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-reaktif-programlamaya-ad%C4%B1m-ad%C4%B1m-yeni-ba%C5%9Flayanlar-i%CC%87%C3%A7in-kapsaml%C4%B1-bir-rehber-ve-5815c96be738?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/5815c96be738</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Fri, 09 May 2025 05:03:44 GMT</pubDate>
<atom:updated>2025-06-20T05:14:00.883Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vOd2FBimvVRwHFflS44SNg.png" /></figure><p>Günümüzün yüksek trafikli ve anlık veri akışı gerektiren uygulamalarında performans ve ölçeklenebilirlik hayati önem taşıyor. İşte tam da bu noktada <strong>Reaktif Programlama</strong> devreye giriyor. Spring Boot’un <strong>Spring WebFlux</strong> ile sunduğu mükemmel destek sayesinde, geliştiriciler olarak engellemeyen (non-blocking), olay güdümlü (event-driven) uygulamalar geliştirebiliyoruz.</p><p>Bu yazıda, Spring Boot kullanarak reaktif programlamanın temellerini adım adım keşfedecek, pratik örneklerle pekiştirecek ve bu dünyaya ilk adımını atanlar için önemli ipuçları ve “ince trikler” paylaşacağım. Hadi, başlayalım!</p><h3>1. Reaktif Programlama Nedir? Neden Gerekli?</h3><p>En basit tanımıyla reaktif programlama, <strong>asenkron veri akışları</strong> ve <strong>olay güdümlü mimari</strong> üzerine kurulu bir programlama paradigmasıdır. Geleneksel (imperative) programlamada bir işlem bitmeden diğerine geçemezken (blocking), reaktif yaklaşımda işlemler birbirini beklemez. Bu sayede, özellikle I/O (Input/Output) işlemleri gibi zaman alıcı operasyonlarda kaynaklarımızı çok daha verimli kullanırız.</p><p><strong>Peki, bu ne anlama geliyor?</strong></p><p>Düşünün ki bir restoranda tek bir garson var ve her siparişi alıp, mutfağa iletip, yemek piştikten sonra servis edip, ancak ondan sonra yeni bir sipariş alabiliyor. Bu, geleneksel programlamadaki “blocking” mantığına benzer. Reaktif programlamada ise garson siparişi alır almaz mutfağa iletir ve hemen bir sonraki müşteriden sipariş almaya devam eder. Mutfak yemeği hazırladığında garsona haber verir ve garson da servisi yapar. Bu sayede çok daha fazla müşteriye aynı anda hizmet verilebilir.</p><p><strong>Reaktif Programlamanın Anahtar Kavramları:</strong></p><ul><li><strong>Reactive Streams:</strong> Asenkron veri işlemeyi “backpressure” (geri basınç) ile yönetmek için bir şartnamedir.</li><li><strong>Backpressure</strong>, <em>yayıncının (Publisher) tüketiciyi (Subscriber) veriyle boğmasını engeller. Tüketici, ne kadar veri alabileceğini yayıncıya bildirir. Bu, sistemin çökmesini önleyen kritik bir mekanizmadır.</em></li><li><strong>Publisher (Yayıncı):</strong> Bir veri akışı yayar. (Örn: Veritabanından gelen kullanıcı listesi)</li><li><strong>Subscriber (Abone):</strong> Publisher tarafından yayılan akışı tüketir. (Örn: Kullanıcı listesini alıp işleyen bir servis)</li><li><strong>Subscription (Abonelik):</strong> Publisher ve Subscriber arasındaki etkileşimi yönetir. Subscriber’ın ne kadar veri talep ettiğini ve aboneliği iptal etme gibi işlemleri kontrol eder.</li><li><strong>Processor (İşlemci):</strong> Hem Publisher hem de Subscriber özelliklerini taşır. Veriyi alıp, işleyip, farklı bir formatta tekrar yayınlayabilir.</li></ul><h3>2. Reaktif Spring Boot Projesi Kurulumu: İlk Adımlar</h3><p>Spring Boot ile reaktif programlamaya başlamak için projemize bazı temel bağımlılıkları eklememiz gerekiyor.</p><p><strong>Adım 1: Bağımlılıkları </strong><strong>pom.xml Dosyasına Ekleyelim</strong></p><p>Eğer bir Maven projesi kullanıyorsanız, pom.xml dosyanıza aşağıdaki bağımlılıkları ekleyin:</p><pre>&lt;dependencies&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br> &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br> &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;<br> &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br> &lt;optional&gt;true&lt;/optional&gt;<br> &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><ul><li><em>spring-boot-starter-webflux bağımlılığı, Netty gibi gömülü reaktif sunucuları ve reaktif HTTP istemcisi olan </em><em>WebClient&#39;ı projenize dahil eder. Geleneksel Spring MVC&#39;deki </em><em>spring-boot-starter-web ile aynı anda kullanılmamalıdır, çünkü farklı iş parçacığı modellerine dayanırlar.</em></li></ul><h3>3. Reaktif Veri Tipleri: Mono ve Flux ile Tanışma</h3><p>Spring WebFlux, Project Reactor kütüphanesini temel alır ve iki ana reaktif veri tipi sunar: Mono ve Flux.</p><ul><li><strong>Mono&lt;T&gt;:</strong> <strong>0 ya da 1</strong> eleman içeren bir akışı temsil eder. Genellikle tek bir nesne döndüreceğiniz (örneğin, ID ile bir kullanıcı getirme) veya bir işlemin tamamlandığını (void) belirten durumlarda kullanılır.</li><li><strong><em>Örnek:</em> </strong>Mono&lt;User&gt; (bir kullanıcı), Mono&lt;Void&gt; (bir işlem tamamlandı).</li><li><strong>Flux&lt;T&gt;:</strong> <strong>0&#39;dan N&#39;e kadar</strong> (yani birden fazla) eleman içeren bir akışı temsil eder. Veri akışları, listeler veya sonsuz akışlar için idealdir.</li><li><strong><em>Örnek:</em> </strong>Flux&lt;Product&gt; (tüm ürünler), Flux&lt;String&gt; (bir olay akışı).</li></ul><p><strong>Mono ve </strong><strong>Flux Örneği:</strong></p><pre>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>public class ReactiveExample {<br> public static void main(String[] args) {<br> // Tek bir değer içeren Mono<br> Mono&lt;String&gt; monoExample = Mono.just(&quot;Merhaba Reaktif Dünya!&quot;)<br> .log(); // Akıştaki olayları görmek için log() ekleyebiliriz.<br> // Mono&#39;ya abone olunduğunda veri işlenir.<br> monoExample.subscribe(<br> data -&gt; System.out.println(&quot;Mono&#39;dan gelen: &quot; + data), // onNext: Veri geldiğinde<br> error -&gt; System.err.println(&quot;Mono&#39;da hata: &quot; + error), // onError: Hata oluştuğunda<br> () -&gt; System.out.println(&quot;Mono tamamlandı!&quot;) // onComplete: Akış bittiğinde<br> );<br> System.out.println(&quot;---&quot;); // Çıktıları ayırmak için<br> // Birden fazla değer içeren Flux<br> Flux&lt;String&gt; fluxExample = Flux.just(&quot;Elma&quot;, &quot;Armut&quot;, &quot;Çilek&quot;, &quot;Muz&quot;)<br> .map(String::toUpperCase) // Her elemanı büyük harfe çevir<br> .log(); // Akıştaki olayları görmek için<br> // Flux&#39;a abone olunduğunda veri akışı başlar.<br> fluxExample.subscribe(<br> data -&gt; System.out.println(&quot;Flux&#39;tan gelen: &quot; + data),<br> error -&gt; System.err.println(&quot;Flux&#39;ta hata: &quot; + error),<br> () -&gt; System.out.println(&quot;Flux tamamlandı!&quot;)<br> );<br> }<br>}</pre><ul><li><em>Mono ve </em><em>Flux &quot;tembel&quot; (lazy) yapıdadır. Yani, onlara </em><em>subscribe() metoduyla abone olunana kadar hiçbir işlem yapmazlar. </em><em>subscribe() çağrısı, veri akışını tetikler. Bu, reaktif programlamaya yeni başlayanların sıkça gözden kaçırdığı bir noktadır. Eğer </em><em>subscribe() yapmazsanız, </em><em>map, </em><em>filter gibi operatörleriniz çalışmayacaktır!</em></li><li><em>.log() operatörü, akışın içindeki olayları (istek, yayınlama, tamamlama, iptal vb.) konsola yazdırmak için geliştirme aşamasında çok faydalıdır.</em></li></ul><h3>4. Reaktif Bir REST API İnşa Edelim: CRUD Örneği</h3><p>Şimdi Spring WebFlux ve Reaktif MongoDB kullanarak basit bir Ürün (Product) yönetimi için CRUD (Create, Read, Update, Delete) API’si oluşturalım.</p><p><strong>Adım 1: Entity Sınıfını Tanımlayalım (</strong><strong>Product.java)</strong></p><p>MongoDB’deki products koleksiyonumuza karşılık gelecek bir model sınıfı oluşturalım.</p><pre>import lombok.Data; // Getter, Setter, toString vb. için<br>import lombok.AllArgsConstructor;<br>import lombok.NoArgsConstructor;<br>import org.springframework.data.annotation.Id;<br>import org.springframework.data.mongodb.core.mapping.Document;<br>@Data // Lombok: Getter, Setter, equals, hashCode, toString metodlarını otomatik oluşturur.<br>@NoArgsConstructor // Lombok: Argümansız constructor oluşturur.<br>@AllArgsConstructor // Lombok: Tüm argümanları içeren constructor oluşturur.<br>@Document(collection = &quot;products&quot;) // Bu sınıfın MongoDB&#39;de &#39;products&#39; adlı bir koleksiyona karşılık geldiğini belirtir.<br>public class Product {<br> @Id // Bu alanın MongoDB&#39;deki _id alanı olduğunu belirtir.<br> private String id;<br> private String name;<br> private double price;<br> // Reaktif programlamada entity&#39;ler genellikle değişmez (immutable) olarak tasarlanır,<br> // ancak bu örnekte basitlik için Lombok @Data kullandık.<br>}</pre><p><strong>Adım 2: Reaktif Repository Oluşturalım (</strong><strong>ProductRepository.java)</strong></p><p>Spring Data, ReactiveMongoRepository arayüzü ile MongoDB için engellemeyen operasyonları destekler.</p><pre>import org.springframework.data.mongodb.repository.ReactiveMongoRepository;<br>import reactor.core.publisher.Flux; <br>import org.springframework.stereotype.Repository;<br>@Repository // Bu arayüzün bir Spring bileşeni (repository) olduğunu belirtir.<br>public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {<br> // ReactiveMongoRepository bize temel CRUD operasyonlarını (findAll, findById, save, deleteById vb.)<br> // Mono ve Flux dönecek şekilde hazır olarak sunar.<br> // İhtiyaç duyarsak özel sorgu metotları da tanımlayabiliriz.<br> // Spring Data, metot isminden sorguyu otomatik türetir.<br> Flux&lt;Product&gt; findByName(String name); // İsme göre ürünleri reaktif olarak getirir.<br>}</pre><ul><li><em>ReactiveMongoRepository&lt;Product, String&gt; ifadesindeki </em><em>Product entity tipini, </em><em>String ise </em><em>@Id ile işaretlediğimiz alanın tipini (yani </em><em>id alanının tipi) temsil eder.</em></li></ul><p><strong>Adım 3: Reaktif Servis Katmanını Oluşturalım (</strong><strong>ProductService.java)</strong></p><p>İş mantığımızı yöneteceğimiz servis sınıfını oluşturalım.</p><pre>import org.springframework.stereotype.Service;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired; // Alternatif olarak constructor injection<br>@Service // Bu sınıfın bir Spring bileşeni (servis) olduğunu belirtir.<br>public class ProductService {<br> private final ProductRepository productRepository;<br> // Bağımlılıkları constructor üzerinden enjekte etmek best practice&#39;dir.<br> @Autowired // Spring 4.3 ve sonrası için constructor injection&#39;da @Autowired zorunlu değil,<br> // eğer sınıfta tek bir constructor varsa.<br> public ProductService(ProductRepository productRepository) {<br> this.productRepository = productRepository;<br> }<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productRepository.findAll();<br> }<br> public Mono&lt;Product&gt; getProductById(String id) {<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Ürün bulunamadı: &quot; + id))); // Ürün yoksa özel hata fırlat<br> }<br> public Mono&lt;Product&gt; createProduct(Product product) {<br> // Gelen ürünün ID&#39;si varsa (güncelleme gibi), bunu engellemek veya farklı yönetmek isteyebilirsiniz.<br> // Bu örnekte basitçe save() çağırıyoruz. MongoDB yeni bir ID atayacaktır eğer null ise.<br> return productRepository.save(product);<br> }<br> public Mono&lt;Product&gt; updateProduct(String id, Product product) {<br> return productRepository.findById(id)<br> .flatMap(existingProduct -&gt; { // flatMap, Mono&lt;Mono&lt;Product&gt;&gt; yerine Mono&lt;Product&gt; dönmek için kullanılır.<br> existingProduct.setName(product.getName());<br> existingProduct.setPrice(product.getPrice());<br> return productRepository.save(existingProduct);<br> })<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Güncellenecek ürün bulunamadı: &quot; + id)));<br> }<br> public Mono&lt;Void&gt; deleteProduct(String id) {<br> // Önce var olup olmadığını kontrol edip sonra silmek daha güvenli olabilir.<br> return productRepository.findById(id)<br> .switchIfEmpty(Mono.error(new ProductNotFoundException(&quot;Silinecek ürün bulunamadı: &quot; + id)))<br> .flatMap(productRepository::delete); // product -&gt; productRepository.delete(product) ile aynı.<br> // deleteById de kullanılabilir: productRepository.deleteById(id)<br> }<br>}<br>// Basit bir custom exception sınıfı<br>class ProductNotFoundException extends RuntimeException {<br> public ProductNotFoundException(String message) {<br> super(message);<br> }<br>}</pre><ul><li><em>switchIfEmpty() operatörü, bir </em><em>Mono veya </em><em>Flux boş geldiğinde (yani hiç eleman yayınlamadığında) alternatif bir </em><em>Mono veya </em><em>Flux sağlamak ya. da bir hata fırlatmak için kullanılır. </em><em>getProductById örneğinde, ürün bulunamazsa </em><em>ProductNotFoundException fırlatıyoruz.</em></li><li><em>flatMap() operatörü, bir </em><em>Mono veya </em><em>Flux içindeki elemanı alıp, bu elemanla başka bir asenkron işlem (başka bir </em><em>Mono veya </em><em>Flux döndüren) yapmak istediğinizde kullanılır. Sonucu &quot;düzleştirir&quot;. Eğer </em><em>map() kullansaydık </em><em>Mono&lt;Mono&lt;Product&gt;&gt; gibi bir sonuç alırdık, </em><em>flatMap ise bunu </em><em>Mono&lt;Product&gt;&#39;a çevirir.</em></li></ul><p><strong>Adım 4: Reaktif REST Controller Oluşturalım (</strong><strong>ProductController.java)</strong></p><p>API endpoint’lerimizi dış dünyaya açacağımız controller sınıfını yazalım.</p><pre>import org.springframework.web.bind.annotation.*;<br>import reactor.core.publisher.Flux;<br>import reactor.core.publisher.Mono;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.http.HttpStatus;<br>import org.springframework.http.ResponseEntity; // ResponseEntity ile daha detaylı yanıtlar<br>@RestController // Bu sınıfın bir RESTful controller olduğunu belirtir.<br> // Gelen istekleri işler ve HTTP yanıtları döner.<br>@RequestMapping(&quot;/api/v1/products&quot;) // Bu controller&#39;daki tüm endpoint&#39;ler &quot;/api/v1/products&quot; altında olacak.<br>public class ProductController {<br> private final ProductService productService;<br> @Autowired<br> public ProductController(ProductService productService) {<br> this.productService = productService;<br> }<br> @GetMapping<br> public Flux&lt;Product&gt; getAllProducts() {<br> return productService.getAllProducts();<br> }<br> @GetMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {<br> return productService.getProductById(id)<br> .map(ResponseEntity::ok) // Product -&gt; ResponseEntity.ok(product)<br> .defaultIfEmpty(ResponseEntity.notFound().build()); // Mono boşsa 404 Not Found<br> }<br> @PostMapping<br> @ResponseStatus(HttpStatus.CREATED) // Başarılı POST isteği için 201 Created durumu döner.<br> public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {<br> // @RequestBody: Gelen JSON verisini Product nesnesine mapler.<br> return productService.createProduct(product);<br> }<br> @PutMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(@PathVariable String id, @RequestBody Product product) {<br> return productService.updateProduct(id, product)<br> .map(ResponseEntity::ok)<br> .defaultIfEmpty(ResponseEntity.notFound().build());<br> }<br> @DeleteMapping(&quot;/{id}&quot;)<br> public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteProduct(@PathVariable String id) {<br> return productService.deleteProduct(id)<br> .map(ResponseEntity.noContent()::build) // Başarılı silme sonrası 204 No Content<br> .onErrorResume(ProductNotFoundException.class, e -&gt; Mono.just(ResponseEntity.notFound().build())); // Ürün yoksa 404<br> }<br> // Hata yönetimi için merkezi bir @ExceptionHandler da eklenebilir.<br> @ExceptionHandler(ProductNotFoundException.class)<br> public ResponseEntity&lt;String&gt; handleProductNotFound(ProductNotFoundException ex) {<br> return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());<br> }<br>}</pre><ul><li><em>Controller metotlarımız artık </em><em>Mono&lt;Product&gt;, </em><em>Flux&lt;Product&gt; veya </em><em>Mono&lt;ResponseEntity&lt;T&gt;&gt; gibi reaktif tipler dönüyor. Spring WebFlux, bu reaktif tiplere abone olup, sonuçlar geldikçe HTTP yanıtını asenkron olarak yazar.</em></li><li><em>@ResponseStatus(HttpStatus.CREATED) gibi anotasyonlarla veya </em><em>ResponseEntity kullanarak HTTP durum kodlarını daha detaylı yönetebilirsiniz. </em><em>defaultIfEmpty ve </em><em>onErrorResume gibi operatörler, controller seviyesinde de hata durumlarını ve boş sonuçları yönetmek için kullanışlıdır.</em></li></ul><h3>5. Reaktif API’mizi Test Edelim</h3><p>API’nizi test etmek için Postman, Insomnia gibi araçları veya cURL komut satırı aracını kullanabilirsiniz. Spring Boot uygulamanız varsayılan olarak 8080 portunda çalışacaktır.</p><p><strong>Yeni Bir Ürün Oluşturma (POST):</strong></p><pre>curl -X POST http://localhost:8080/api/v1/products \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Akıllı Saat&quot;,&quot;price&quot;:2500.75}&#39;</pre><p><strong>Tüm Ürünleri Getirme (GET):</strong></p><pre>curl -X GET http://localhost:8080/api/v1/products</pre><p><em>Bu komut, bir JSON dizisi olarak ürünleri listeler. Eğer </em><em>text/event-stream olarak isterseniz, sunucu tarafında bunu desteklemeniz gerekir ve istemci de buna göre istek yapmalıdır.</em></p><p><strong>ID ile Ürün Getirme (GET):</strong> Önce bir ürün oluşturup ID’sini alın, sonra o ID ile sorgulayın.</p><pre># ID&#39;yi bir önceki POST isteğinin yanıtından veya GET All Products&#39;tan alın<br>curl -X GET http://localhost:8080/api/v1/products/{id}</pre><p><strong>Ürün Güncelleme (PUT):</strong></p><pre>curl -X PUT http://localhost:8080/api/v1/products/{id} \<br>-H &quot;Content-Type: application/json&quot; \<br>-d &#39;{&quot;name&quot;:&quot;Yeni Akıllı Saat Model X&quot;,&quot;price&quot;:2750.00}&#39;</pre><p><strong>Ürün Silme (DELETE):</strong></p><pre>curl -X DELETE http://localhost:8080/api/v1/products/{id}</pre><ul><li><em>Spring WebFlux ile </em><em>WebClient kullanarak reaktif API&#39;lerinizi programatik olarak test edebilirsiniz. Bu, özellikle entegrasyon testleri yazarken çok kullanışlıdır.</em></li></ul><pre>// Örnek WebClient kullanımı (test sınıfı içinde)<br>// @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br>// class ProductControllerIntegrationTests {<br>//<br>// @Autowired<br>// private WebTestClient webTestClient;<br>//<br>// @Test<br>// void testGetAllProducts() {<br>// webTestClient.get().uri(&quot;/api/v1/products&quot;)<br>// .exchange() // İsteği gönder ve yanıtı al<br>// .expectStatus().isOk() // HTTP durumunun 200 OK olmasını bekle<br>// .expectHeader().contentType(MediaType.APPLICATION_JSON) // İçerik tipinin JSON olmasını bekle<br>// .expectBodyList(Product.class).hasSize(expectedSize); // Beklenen sayıda ürün olmasını kontrol et<br>// }<br>// }</pre><h3>6. Reaktif Programlamanın Faydaları (Kısaca)</h3><ul><li><strong>Engellemeyen I/O (Non-blocking I/O):</strong> Daha az kaynakla daha fazla isteği işleyebilir. Her istek için ayrı bir thread oluşturmak yerine, az sayıda thread ile (event loop) çok sayıda isteği yönetir.</li><li><strong>Daha İyi Ölçeklenebilirlik:</strong> Özellikle mikroservis mimarilerinde ve gerçek zamanlı uygulamalarda yatay ölçeklenmeyi kolaylaştırır.</li><li><strong>Verimli Kaynak Kullanımı:</strong> Thread’lerin bloke olmasını azaltarak CPU ve bellek kullanımını optimize eder.</li><li><strong>Akış (Streaming) Yetenekleri:</strong> Büyük veri kümelerini veya sonsuz veri akışlarını (örneğin, sensör verileri, sosyal medya akışları) verimli bir şekilde işleyebilir.</li></ul><h3>7. Reaktif Programlama Ne Zaman Kullanılmalı? (Altın Kural!)</h3><p>✅ <strong>Gerçek zamanlı uygulamalar</strong> için idealdir: Sohbet uygulamaları, canlı borsa verileri, IoT (Nesnelerin İnterneti) uygulamaları, bildirim servisleri.</p><p>✅ <strong>Yüksek trafikli (high-throughput)</strong> ve ölçeklenebilirlik gerektiren servisler için çok faydalıdır. Özellikle I/O bağımlı (veritabanı, harici API çağrıları) işlemleri yoğun olan servisler.</p><p>✅ <strong>Veri akışlarının (data streams)</strong> işlenmesi gereken durumlar.</p><p>❌ <strong>Düşük eşzamanlılık (concurrency)</strong> ihtiyacı olan, basit CRUD (Create, Read, Update, Delete) tabanlı geleneksel uygulamalar için <strong>gereksiz karmaşıklık</strong> getirebilir. Eğer uygulamanızın darboğazı I/O değilse veya trafik çok düşükse, reaktif programlamanın faydalarını göremeyebilirsiniz.</p><ul><li><em>Reaktif programlama bir “gümüş kurşun” değildir. Her probleme çözüm sunmaz. Projenizin ihtiyaçlarını iyi analiz edip, reaktif mimarinin getireceği faydaların, öğrenme eğrisi ve potansiyel karmaşıklığa değip değmeyeceğine karar vermelisiniz.</em></li></ul><h3>Yeni Başlayanlar İçin Ekstra İpuçları ve Dikkat Edilmesi Gerekenler</h3><ol><li><strong>Farklı Düşünme Biçimi:</strong> Reaktif programlama, geleneksel imperative programlamadan farklı bir düşünme biçimi gerektirir. Akışları ve olayları düşünmeye alışmak zaman alabilir.</li><li><strong>subscribe() Hayati Önem Taşır:</strong> Unutmayın, Mono ve Flux tembeldir. subscribe() çağrılmadıkça hiçbir şey olmaz.</li><li><strong>Hata Yönetimi:</strong> Reaktif akışlarda hata yönetimi farklıdır. onErrorMap, onErrorResume, onErrorReturn gibi operatörlerle hataları yakalayıp yönetebilirsiniz. Merkezi hata yönetimi için @ControllerAdvice ve ExceptionHandler kullanabilirsiniz.</li><li><strong>Debugging (Hata Ayıklama):</strong> Reaktif akışları debug etmek, geleneksel kodlara göre biraz daha zorlayıcı olabilir. .log(), doOnNext(), doOnError() gibi operatörler ve Reactor&#39;un BlockHound gibi araçları yardımcı olabilir. IDE&#39;nizin reaktif debug yeteneklerini de keşfedin.</li><li><strong>Thread Yönetimi:</strong> Spring WebFlux, varsayılan olarak Netty’nin event loop’larını kullanır. Uzun süren CPU-yoğun işlemleriniz varsa, bunları Schedulers.boundedElastic() gibi farklı bir thread havuzunda çalıştırmayı düşünmelisiniz ki event loop&#39;ları bloke etmeyin.</li><li><strong>Engellemeyen Kütüphaneler:</strong> Reaktif bir sistemde, tüm çağrıların (veritabanı, harici servisler vb.) engellemeyen (non-blocking) olması önemlidir. Eğer reaktif bir akış içinde engelleme yapan bir kütüphane çağrısı yaparsanız, reaktifliğin tüm faydalarını kaybedebilirsiniz. Spring Data Reactive Repositories (MongoDB, R2DBC vs.) ve WebClient bu yüzden önemlidir.</li></ol><h3>Sonuç</h3><p>Bu yazıda, Spring Boot ve WebFlux ile reaktif programlamaya kapsamlı bir giriş yaptık. Temel kavramları, Mono ve Flux&#39;ı, reaktif bir REST API&#39;nin nasıl oluşturulacağını ve test edileceğini adım adım inceledik. Ayrıca, yeni başlayanlar için önemli ipuçları ve dikkat edilmesi gereken noktaları paylaştım.</p><p>Reaktif programlama, modern uygulama geliştirmenin güçlü bir aracıdır, ancak doğru yerde ve doğru şekilde kullanıldığında en iyi sonuçları verir. Eğer uygulamanız asenkron ve engellemeyen bir yapıya gerçekten ihtiyaç duyuyorsa, Spring WebFlux sizin için harika bir seçenektir.</p><p>Umarım bu yazı, reaktif programlama yolculuğunuzda size iyi bir başlangıç noktası sunmuştur. Yorumlarda sorularınızı ve deneyimlerinizi paylaşmaktan çekinmeyin! Mutlu kodlamalar!</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5815c96be738" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Spring Boot ile Apache Kafka Entegrasyonu: Adım Adım Rehber ]]>
</title>
<link>https://pehlivanmert.medium.com/spring-boot-ile-apache-kafka-entegrasyonu-ad%C4%B1m-ad%C4%B1m-rehber-8f2d4416f987?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/8f2d4416f987</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:21:57 GMT</pubDate>
<atom:updated>2025-06-20T05:14:23.618Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*4TWM0sbXF0b8oxc2EPkomg.png" /></figure><p>Apache Kafka, yüksek hacimli veri akışlarını işlemek için kullanılan güçlü bir dağıtık mesajlaşma sistemidir. Spring Boot ise mikroservis mimarilerinde ve modern uygulamalarda hızlı geliştirme için ideal bir framework’tür. Bu yazıda Spring Boot uygulaması ile Apache Kafka’yı nasıl entegre edeceğimizi adım adım öğreneceğiz.</p><h3>🔧 1. Gerekli Araçlar ve Kurulumlar</h3><h3>Kullandığımız Teknolojiler:</h3><ul><li><strong>Java 17+</strong></li><li><strong>Spring Boot 3.x</strong></li><li><strong>Apache Kafka (2.8+)</strong></li><li><strong>Spring Tool Suite (STS) veya IntelliJ IDEA</strong></li><li><strong>Maven (Dependency Management)</strong></li><li><strong>Postman (API Testi)</strong></li></ul><h3>Kafka Kurulumu:</h3><ol><li>Apache Kafka’yı <a href="https://kafka.apache.org/downloads">resmi sitesinden</a> indirin.</li><li>config/server.properties dosyasını açın ve gerekirse listeners ve port ayarlarını düzenleyin (varsayılan port: 9092).</li><li>Kafka’yı başlatın:</li></ol><pre># Zookeeper&#39;ı başlat bin/zookeeper-server-start.sh config/zookeeper.properties <br># Kafka broker&#39;ı başlat bin/kafka-server-start.sh config/server.properties</pre><h3>📦 2. Spring Boot Projesi Oluşturma</h3><p>STS veya IntelliJ üzerinden yeni bir Spring Boot projesi oluşturun. Gerekli bağımlılıklar:</p><pre>&lt;!-- Spring for Apache Kafka --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Web (REST API için) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Spring Boot DevTools (Geliştirme Kolaylığı) --&gt;<br>&lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br> &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>🔁 3. Ana Sınıf: Kafka Entegrasyonunu Aktif Hale Getirme</h3><p>Ana uygulama sınıfınıza @EnableKafka ekleyerek Kafka desteği aktif edilir:</p><pre>@SpringBootApplication<br>@EnableKafka<br>public class SpringBootKafkaApplication {<br> public static void main(String[] args) {<br> SpringApplication.run(SpringBootKafkaApplication.class, args);<br> }<br>}</pre><h3>🗄️ 4. Mesajları Saklamak İçin Repository Oluşturma</h3><p>Basit bir MessageRepository, alınan Kafka mesajlarını geçici olarak saklamak için kullanılır.</p><pre>@Component<br>public class MessageRepository {<br> private List&lt;String&gt; messages = new ArrayList&lt;&gt;();<br>public void addMessage(String message) {<br> messages.add(message);<br> }<br> public String getAllMessages() {<br> return messages.toString();<br> }<br>}</pre><blockquote><em>💡 Bu repository, sadece demo amaçlıdır. Gerçek senaryolarda Redis, MongoDB gibi veri tabanları kullanılabilir.</em></blockquote><h3>🚚 5. Mesaj Üretici (Producer): Kafka’ya Veri Gönderimi</h3><p>MessageProducer, Kafka topic’ine mesaj göndermek için kullanılır:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageProducer {<br><br> private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br><br> @Value(&quot;${myapp.kafka.topic}&quot;)<br> private String topic;<br><br> public void sendMessage(String message) {<br> log.info(&quot;MESAJ ÜRETİCİDEN GÖNDERİLİYOR -&gt; {}&quot;, message);<br> kafkaTemplate.send(topic, message);<br> }<br>}</pre><h3>KafkaTemplate Nedir?</h3><ul><li>Kafka ile etkileşim kurmak için kullanılan Spring’in yüksek seviye API’sidir.</li><li>KafkaTemplate sayesinde mesaj gönderimi (send) kolaylaştırılır.</li></ul><h3>📥 6. Mesaj Tüketici (Consumer): Kafka’dan Veri Alma</h3><p>@KafkaListener, belirtilen topic’teki mesajları dinler ve işler:</p><pre>@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class MessageConsumer {<br><br> private final MessageRepository messageRepo;<br><br> @KafkaListener(topics = &quot;${myapp.kafka.topic}&quot;, groupId = &quot;kafka-group&quot;)<br> public void consume(String message) {<br> log.info(&quot;MESAJ TÜKETİCİYE ULAŞTI -&gt; {}&quot;, message);<br> messageRepo.addMessage(message);<br> }<br>}</pre><h3>Anahtar Özellikler:</h3><ul><li><strong>topics</strong>: Dinlenen Kafka topic’i.</li><li><strong>groupId</strong>: Tüketici grubunu tanımlar. Aynı gruptaki tüketiciler mesajları paylaşır.</li></ul><h3>🌐 7. REST API ile Etkileşim: KafkaRestController</h3><p>REST istemcileri için basit bir arayüz sağlar:</p><pre>@Slf4j<br>@RestController<br>@RequestMapping(&quot;/api/kafka&quot;)<br>@RequiredArgsConstructor<br>public class KafkaRestController {<br><br> private final MessageProducer producer;<br> private final MessageRepository messageRepo;<br><br> // Kafka topic&#39;ine mesaj gönder<br> @GetMapping(&quot;/send&quot;)<br> public ResponseEntity&lt;String&gt; sendMsg(@RequestParam(&quot;msg&quot;) String message) {<br> log.info(&quot;REST API ÜZERİNDEN MESAJ ALINDI -&gt; {}&quot;, message);<br> producer.sendMessage(message);<br> return ResponseEntity.ok(&quot;&#39;&quot; + message + &quot;&#39; mesajı başarıyla gönderildi!&quot;);<br> }<br><br> // Alınan tüm mesajları listele<br> @GetMapping(&quot;/messages&quot;)<br> public ResponseEntity&lt;String&gt; getAllMessages() {<br> return ResponseEntity.ok(messageRepo.getAllMessages());<br> }<br>}</pre><h3>API Kullanımı:</h3><p>GET /send?msg=... Kafka topic&#39;ine mesaj gönder</p><p>GET /getAllTüm alınan mesajları listele</p><h3>⚙️ 8. Uygulama Yapılandırması: application.yml</h3><pre>server:<br> port: 9090<br>spring:<br> kafka:<br> producer:<br> bootstrap-servers: localhost:9092<br> key-serializer: org.apache.kafka.common.serialization.StringSerializer<br> value-serializer: org.apache.kafka.common.serialization.StringSerializer<br> consumer:<br> bootstrap-servers: localhost:9092<br> key-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br> value-deserializer: org.apache.kafka.common.serialization.StringDeserializer<br>myapp:<br> kafka:<br> topic: myKafkaTest</pre><h3>Yapılandırma Açıklamaları:</h3><ul><li><strong>bootstrap-servers</strong>: Kafka broker’ın adresi.</li><li><strong>key-serializer/deserializer</strong>: Anahtarların nasıl serileştirileceği.</li><li><strong>value-serializer/deserializer</strong>: Mesaj içeriğinin serileştirme biçimi.</li><li><strong>topic</strong>: Dinlenen veya yazılan Kafka topic’i.</li></ul><h3>🧠 9. Kafka Entegrasyonu İçin İpuçları ve En İyi Uygulamalar</h3><h3>1. Hata Yönetimi ve Retry Mekanizmaları</h3><ul><li>@Retryable anotasyonu ile otomatik tekrar deneme yapılabilir.</li><li>Kafka Consumer içinde Acknowledgment ile manuel commit yapılabilir.</li></ul><pre>@KafkaListener(topics = &quot;myTopic&quot;)<br>public void listen(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack) {<br> try {<br> // İşlemler<br> ack.acknowledge(); // Başarılıysa commit<br> } catch (Exception e) {<br> // Hata yönetimi<br> }<br>}</pre><h3>2. Dead Letter Queue (DLQ)</h3><ul><li>Başarısız mesajları başka bir topic’e yönlendirmek için DLQ kullanılabilir.</li></ul><h3>3. Serialization</h3><ul><li>JSON formatında mesaj göndermek için JsonSerializer kullanılabilir.</li><li>@KafkaListener metotlarında ConsumerRecord ile header bilgileri de alınabilir.</li></ul><h3>4. Partitions ve Offset Yönetimi</h3><ul><li>Topic partition sayısı artırılarak paralel tüketim sağlanabilir.</li><li>auto.offset.reset ayarı ile tüketici başlangıçta hangi offset’ten başlayacak belirlenir (örnek: earliest, latest).</li></ul><h3>🧪 10. Test Süreci</h3><h3>1. Kafka Topic Oluşturma</h3><pre>bin/kafka-topics.sh --create --topic myKafkaTest --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1</pre><h3>2. Kafka Consumer CLI ile Mesaj Dinleme</h3><pre>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic myKafkaTest --from-beginning</pre><h3>3. API ile Mesaj Gönderme</h3><pre>curl http://localhost:9090/send?msg=MerhabaKafka</pre><h3>4. Alınan Mesajları Görüntüleme</h3><pre>curl http://localhost:9090/getAll</pre><h3>📌 11. Güvenlik ve Performans İpuçları</h3><h3>1. SSL/TLS ile Güvenli Bağlantı</h3><ul><li>Kafka bağlantısı için SSL ayarları yapılabilir.</li><li>ssl.truststore.location ve ssl.keystore.location gibi parametreler application.yml’de tanımlanır.</li></ul><h3>2. Mesaj Sıkıştırması</h3><ul><li>compression.type ile mesajlar sıkıştırılabilir (gzip, snappy, lz4).</li></ul><h3>3. Mesaj Doğrulama</h3><ul><li>@Validated ve @KafkaListener ile gelen mesajlar doğrulanabilir.</li></ul><h3>🧭 12. Sonuç</h3><p>Spring Boot ile Apache Kafka entegrasyonu, mikroservislerde asenkron mesajlaşma, olay tabanlı mimariler, log toplama ve gerçek zamanlı veri işleme gibi birçok senaryoda güçlü çözümler sunar. Bu yazıda, temel yapılandırmalarla birlikte Kafka topic’ine mesaj gönderme ve alma işlemlerini basitçe adım adım öğrendik.</p><h3>✅ Öğrendiklerimiz:</h3><ul><li>Kafka ile Spring Boot entegrasyonu</li><li>Producer ve Consumer sınıfları</li><li>REST API ile Kafka etkileşimi</li><li>Yapılandırma ve hata yönetimi</li><li>Güvenlik ve performans optimizasyonları</li></ul><p>Bu temel yapıyı alarak Kafka ile daha karmaşık senaryolar (örneğin event sourcing, stream processing) da geliştirebilirsiniz.</p><h3>📘 Ekstra Kaynaklar</h3><ul><li><a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/">Spring Kafka Documentation</a></li><li><a href="https://kafka.apache.org/documentation/">Apache Kafka Official Docs</a></li><li><a href="https://kafka.apache.org/documentation/streams/">Kafka Streams ile Gerçek Zamanlı Veri İşleme</a></li><li><a href="https://www.baeldung.com/spring-kafka">Kafka ile Mikroservis Mimari Tasarımı — Baeldung</a></li></ul><p>Eğer bu yazı hoşunuza gittiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı ya da önerilerinizi yorumlarda bekliyorum. 😊</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8f2d4416f987" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
<item>
<title>
<![CDATA[ Java’da Serileştirme (Serialization) ve En İyi Uygulamalar ]]>
</title>
<link>https://pehlivanmert.medium.com/javada-serile%C5%9Ftirme-serialization-ve-en-i%CC%87yi-uygulamalar-4fd05ec48a4a?source=rss-83e9f53f33c4------2</link>
<guid isPermaLink="false">https://medium.com/p/4fd05ec48a4a</guid>
<dc:creator>
<![CDATA[ Mert Pehlivan ]]>
</dc:creator>
<pubDate>Wed, 07 May 2025 22:05:31 GMT</pubDate>
<atom:updated>2025-06-20T05:14:35.910Z</atom:updated>
<content:encoded>
<![CDATA[ <figure><img alt="" src="https://cdn-images-1.medium.com/max/629/1*pwMbKl8czO8lGyLut1HDZQ.png" /></figure><p>Java’da serileştirme (<strong>serialization</strong>), bir nesnenin durumunun (state) bayt dizisine dönüştürülmesi sürecidir. Bu işlem sayesinde nesneler kalıcı olarak saklanabilir (örneğin dosya ya da veritabanında), ağ üzerinden aktarılabilir veya geçici olarak önbellekte tutulabilir. Serileştirme sürecinin tersi olan <strong>deserileştirme (deserialization)</strong> ise bu bayt dizisinin tekrar orijinal nesneye dönüştürülmesini sağlar.</p><p>Bu yazıda Java’daki serileştirme mekanizmasını ele alacak, ne zaman kullanılması gerektiğini ve en iyi uygulama yöntemlerini adım adım inceleyeceğiz.</p><h3>📌 Serileştirme Nedir?</h3><p>Serileştirme, bir nesnenin içeriğini (durumunu) bayt dizisine çevirerek farklı ortamlarda taşınabilir hale getiren bir tekniktir. Özetle:</p><ul><li>Nesneler kalıcı olarak saklanabilir.</li><li>Ağ üzerinden gönderilip alınabilir.</li><li>Hızlıca geri yüklenebilir (deserialize edilebilir).</li></ul><p>Bir sınıfın serileştirilebilmesi için java.io.Serializable arayüzünü uygulaması gerekir. Bu, sadece bir işaretleme arayüzüdür (marker interface), herhangi bir metot içermez.</p><pre>public class Employee implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private String name;<br> private int age;</pre><pre> // constructor, getters and setters<br>}</pre><blockquote><em>⚠️ </em><em>Serializable uygulamak, sınıfınızın otomatik olarak güvenli ya da optimize edilmiş bir serileştirme sürecinden geçeceği anlamına gelmez. Dikkatli kullanım şarttır.</em></blockquote><h3>✅ Serileştirme Ne Zaman Kullanılır?</h3><h3>1. Kalıcılık (Persistence):</h3><p>Nesneleri dosyalarda veya veritabanlarında saklamak için kullanılır.</p><h3>2. İletişim (Communication):</h3><p>Ağ üzerinden nesnelerin gönderilmesi gerektiğinde (örneğin RMI — Remote Method Invocation) serileştirme devreye girer.</p><h3>3. Önbellekleme (Caching):</h3><p>Geçici olarak nesnelerin bellekte saklanması ve daha sonra hızlıca erişilmesi için kullanılır.</p><h3>🧠 Java Serileştirme İçin En İyi Uygulamalar</h3><h3>1. Gerektiği Zaman Kullanın</h3><p>Her sınıfın serileştirilebilir olması gerekmez. Sadece gerçekten ihtiyaç duyduğunuz sınıflara Serializable uygulayın. Gereksiz serileştirme, güvenlik açıklarına ve performans kayıplarına yol açabilir.</p><pre>public class Employee implements Serializable { ... }</pre><h3>2. Saklanması Gereken Alanları transient ile Gizleyin</h3><p>Bazı alanlar serileştirilmemelidir. Örneğin şifre, API anahtarı gibi hassas bilgileri transient anahtar kelimesiyle işaretleyin.</p><pre>public class User implements Serializable {<br> private String username;<br> private transient String password; // Şifre serileştirilmez<br>}</pre><h3>3. serialVersionUID Tanımlayın</h3><p>Her serileştirilebilir sınıf için private static final long serialVersionUID = 1L; tanımlanmalıdır. Bu, sınıfın sürüm numarasını temsil eder ve farklı sürümler arasında uyumluluğu sağlar.</p><blockquote><em>Eğer </em><em>serialVersionUID tanımlanmazsa, JVM otomatik olarak üretir ama bu, küçük değişikliklerde bile </em><em>InvalidClassException hatasına neden olabilir.</em></blockquote><h3>4. Özel Serileştirme Mantığı Ekleyin (İsteğe Bağlı)</h3><p>Eğer varsayılan serileştirme yeterli değilse, writeObject() ve readObject() metodlarını override ederek özel mantık ekleyebilirsiniz.</p><pre>private void writeObject(ObjectOutputStream oos) throws IOException {<br> oos.defaultWriteObject();<br> // Özel serileştirme işlemleri burada yapılabilir<br>}</pre><pre>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {<br> ois.defaultReadObject();<br> // Özel deserileştirme işlemleri burada yapılabilir<br>}</pre><h3>5. Hassas Verilerin Serileştirilmesinden Kaçının</h3><p>Şifre, kimlik bilgileri, kredi kartı bilgileri gibi veriler asla serileştirilmemelidir. Bunu önlemek için yukarıda bahsedilen transient kullanımı oldukça önemlidir.</p><h3>6. Serileştirme Proxy’leri Kullanın (Gelişmiş Seviye)</h3><p>Daha fazla kontrol ve güvenlik istiyorsanız, serileştirme proxy desenini kullanabilirsiniz. Bu yöntem, sınıfın doğrudan serileştirilmesini engeller ve özel bir yapıyla koruma sağlar.</p><pre>private Object writeReplace() {<br> return new SerializationProxy(this);<br>}</pre><pre>private static class SerializationProxy implements Serializable {<br> private static final long serialVersionUID = 1L;<br> private final String username;</pre><pre> SerializationProxy(User user) {<br> this.username = user.username;<br> }</pre><pre> private Object readResolve() {<br> return new User(username);<br> }<br>}</pre><p>Bu yaklaşım, nesne oluşturma sürecini kontrol altına alır ve güvenlik açıklarını azaltır.</p><h3>7. Alternatif Serileştirme Kütüphaneleri Kullanın</h3><p>Java’nın yerel serileştirme mekanizması, her zaman en verimli çözüm olmayabilir. Özellikle büyük sistemlerde, yüksek performans gerektiren senaryolarda şu alternatifler düşünülebilir:</p><ul><li><strong>Google Protocol Buffers (protobuf)</strong></li><li><strong>Apache Avro</strong></li><li><strong>Jackson (JSON formatında serileştirme)</strong></li><li><strong>Kryo (hızlı, kompakt serileştirme)</strong></li><li><strong>MessagePack</strong></li></ul><p>Bu kütüphaneler genellikle daha az yer kaplar, daha hızlı çalışır ve platformlar arası uyumluluk sağlar.</p><h3>🧪 Basit Bir Serileştirme &amp; Deserileştirme Örneği</h3><h3>1. Nesneyi Serileştirme</h3><pre>Employee emp = new Employee(&quot;John Doe&quot;, 30);</pre><pre>try (FileOutputStream fileOut = new FileOutputStream(&quot;employee.ser&quot;);<br> ObjectOutputStream out = new ObjectOutputStream(fileOut)) {<br> out.writeObject(emp);<br>} catch (IOException e) {<br> e.printStackTrace();<br>}</pre><h3>2. Nesneyi Deserileştirme</h3><pre>Employee emp = null;</pre><pre>try (FileInputStream fileIn = new FileInputStream(&quot;employee.ser&quot;);<br> ObjectInputStream in = new ObjectInputStream(fileIn)) {<br> emp = (Employee) in.readObject();<br>} catch (IOException | ClassNotFoundException e) {<br> e.printStackTrace();<br>}</pre><pre>System.out.println(&quot;Name: &quot; + emp.getName() + &quot;, Age: &quot; + emp.getAge());</pre><h3>🎯 Sonuç Olarak</h3><p>Java’nın serileştirme mekanizması güçlüdür ama doğru ve dikkatli kullanılması gereken bir özelliktir. Yukarıdaki en iyi uygulamalara uyarak:</p><ul><li>Performansı artırabilir,</li><li>Güvenliği güçlendirebilir,</li><li>Sürüm uyumsuzluklarından kaçınabilir,</li><li>Uygun yerlerde alternatif çözümler tercih ederek sisteminizi optimize edebilirsiniz.</li></ul><p>Unutmayın: Her nesne serileştirilmeye müsait değildir. Dikkatli planlama yapmak, hem kod kalitenizi hem de sisteminizin güvenliğini artıracaktır.</p><h3>📘 Ekstra Kaynaklar</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html">Oracle Java Documentation — Serialization</a></li><li><a href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997">Effective Java by Joshua Bloch — Item 74–78 on Serialization</a></li><li><a href="https://www.baeldung.com/java-serialization">Baeldung — Java Serialization Guide</a></li></ul><p>Eğer bu yazı faydalı geldiyse 👍 beğenmeyi unutmayın ve arkadaşlarınızla paylaşın! Sorularınızı veya deneyimlerinizi yorumlarda paylaşmaktan çekinmeyin. 😊</p><blockquote><strong>Mert Pehlivan — Java Backend Developer<br></strong><a href="https://mertpehlivan.tech"><strong>🌐 Portfolio</strong></a><strong> | </strong><a href="https://linkedin.com/in/smertpehlivan"><strong>💼 LinkedIn</strong></a><strong> | 📧 </strong><a href="mailto:pehlivanmert@outlook.com.tr"><strong>Email</strong></a><strong> | </strong><a href="https://github.com/PehlivanMert"><strong>🖥️ GitHub</strong></a></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fd05ec48a4a" width="1" height="1" alt=""> ]]>
</content:encoded>
</item>
</channel>
</rss>